<?xml version="1.0" ?><APDB><HAL_basicIOTypes_List><HAL_basicIOTypes TypeID="1" TypeName="rational" cType="float" description="a type for rational numbers" endianType="False" idHAL_IOTypesDefinition="1" sizeInBytes="4"/><HAL_basicIOTypes TypeID="2" TypeName="integer" cType="int32_t" description="a type for natural and integer numbers" endianType="True" idHAL_IOTypesDefinition="2" sizeInBytes="4"/><HAL_basicIOTypes TypeID="3" TypeName="char" cType="char" description="a type for character" endianType="False" idHAL_IOTypesDefinition="3" sizeInBytes="1"/><HAL_basicIOTypes TypeID="4" TypeName="raw" cType="uint32_t" description="4 Byte Raw Data" endianType="False" idHAL_IOTypesDefinition="4" sizeInBytes="4"/></HAL_basicIOTypes_List><HAL_VariableIOParameter_List><HAL_VariableIOParameter VariableID="1" basicTypeID="1" description="the value of the number" idHAL_VariableIOParameter="1" initFunction="True" isArray="False" name="value" updateFunction="True"/><HAL_VariableIOParameter VariableID="2" basicTypeID="2" description="the value of the number" idHAL_VariableIOParameter="2" initFunction="True" isArray="False" name="value" updateFunction="True"/><HAL_VariableIOParameter VariableID="3" basicTypeID="2" description="the length of the string" idHAL_VariableIOParameter="3" initFunction="True" isArray="False" name="length" updateFunction="True"/><HAL_VariableIOParameter VariableID="3" basicTypeID="3" description="the text of the string" idHAL_VariableIOParameter="4" initFunction="True" isArray="True" name="text" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="5" initFunction="True" isArray="False" name="a0" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="6" initFunction="True" isArray="False" name="a1" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="7" initFunction="True" isArray="False" name="a2" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="numerator coefficient" idHAL_VariableIOParameter="8" initFunction="True" isArray="False" name="b0" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="numerator coefficient" idHAL_VariableIOParameter="9" initFunction="True" isArray="False" name="b1" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="numerator coefficient" idHAL_VariableIOParameter="10" initFunction="True" isArray="False" name="b2" updateFunction="True"/><HAL_VariableIOParameter VariableID="30" basicTypeID="2" description="number of samples" idHAL_VariableIOParameter="11" initFunction="True" isArray="False" name="N" updateFunction="True"/><HAL_VariableIOParameter VariableID="4" basicTypeID="1" description="real part" idHAL_VariableIOParameter="12" initFunction="True" isArray="False" name="r" updateFunction="True"/><HAL_VariableIOParameter VariableID="4" basicTypeID="2" description="imaginary part" idHAL_VariableIOParameter="13" initFunction="True" isArray="False" name="i" updateFunction="True"/></HAL_VariableIOParameter_List><HAL_FunctionsParameter_List><HAL_FunctionsParameter descr="left side number" fid="40" idHAL_FunctionsParameter="41" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="50" idHAL_FunctionsParameter="53" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="51" idHAL_FunctionsParameter="54" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="52" idHAL_FunctionsParameter="55" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="the channel" fid="60" idHAL_FunctionsParameter="56" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the result of the action" fid="60" idHAL_FunctionsParameter="57" idParameterClass="3" idParameterType="1" name="resValue"/><HAL_FunctionsParameter descr="the channel" fid="61" idHAL_FunctionsParameter="58" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the value to be written to the output" fid="61" idHAL_FunctionsParameter="59" idParameterClass="3" idParameterType="1" name="value"/><HAL_FunctionsParameter descr="a value" fid="3" idHAL_FunctionsParameter="60" idParameterClass="1" idParameterType="2" name="value"/><HAL_FunctionsParameter descr="index at the biquad array" fid="100" idHAL_FunctionsParameter="62" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="sample frequency" fid="100" idHAL_FunctionsParameter="63" idParameterClass="1" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="cut off frequency" fid="100" idHAL_FunctionsParameter="64" idParameterClass="1" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="biquad array" fid="100" idHAL_FunctionsParameter="66" idParameterClass="2" idParameterType="10" name="bqa"/><HAL_FunctionsParameter descr="index at the biquad array" fid="101" idHAL_FunctionsParameter="71" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="sample frequency" fid="101" idHAL_FunctionsParameter="72" idParameterClass="1" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="cut off frequency" fid="101" idHAL_FunctionsParameter="73" idParameterClass="1" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="biquad array" fid="101" idHAL_FunctionsParameter="74" idParameterClass="2" idParameterType="10" name="bqa"/><HAL_FunctionsParameter descr="input" fid="110" idHAL_FunctionsParameter="77" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="150" idHAL_FunctionsParameter="79" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="the delay" fid="150" idHAL_FunctionsParameter="80" idParameterClass="2" idParameterType="20" name="delay"/><HAL_FunctionsParameter descr="output" fid="150" idHAL_FunctionsParameter="81" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="biquad array" fid="110" idHAL_FunctionsParameter="83" idParameterClass="2" idParameterType="10" name="bqa"/><HAL_FunctionsParameter descr="output" fid="110" idHAL_FunctionsParameter="84" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="window length" fid="120" idHAL_FunctionsParameter="85" idParameterClass="1" idParameterType="2" name="wl"/><HAL_FunctionsParameter descr="set to 1 if used for periodic consructs like DFT/FFT" fid="120" idHAL_FunctionsParameter="86" idParameterClass="1" idParameterType="2" name="flag"/><HAL_FunctionsParameter descr="window coefficients (array of rational values)" fid="120" idHAL_FunctionsParameter="87" idParameterClass="2" idParameterType="1" name="wnd"/><HAL_FunctionsParameter descr="FFT length" fid="130" idHAL_FunctionsParameter="88" idParameterClass="1" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="IFFT length" fid="131" idHAL_FunctionsParameter="89" idParameterClass="1" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="the channel" fid="62" idHAL_FunctionsParameter="92" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the buffer witch receives the samples" fid="62" idHAL_FunctionsParameter="93" idParameterClass="3" idParameterType="1" name="frameBuffer"/><HAL_FunctionsParameter descr="the channel" fid="63" idHAL_FunctionsParameter="94" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the buffer which is writen to the channel" fid="63" idHAL_FunctionsParameter="95" idParameterClass="3" idParameterType="1" name="frameBuffer"/><HAL_FunctionsParameter descr="input" fid="130" idHAL_FunctionsParameter="100" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="output" fid="130" idHAL_FunctionsParameter="101" idParameterClass="3" idParameterType="4" name="y"/><HAL_FunctionsParameter descr="input" fid="131" idHAL_FunctionsParameter="102" idParameterClass="3" idParameterType="4" name="x"/><HAL_FunctionsParameter descr="output" fid="131" idHAL_FunctionsParameter="103" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="IFFT structure" fid="131" idHAL_FunctionsParameter="104" idParameterClass="2" idParameterType="30" name="ifftStruct"/><HAL_FunctionsParameter descr="FFT structure" fid="130" idHAL_FunctionsParameter="105" idParameterClass="2" idParameterType="30" name="fftStruct"/><HAL_FunctionsParameter descr="the ifft info structure" fid="133" idHAL_FunctionsParameter="107" idParameterClass="2" idParameterType="30" name="ifftStruct"/><HAL_FunctionsParameter descr="the fft structure" fid="132" idHAL_FunctionsParameter="108" idParameterClass="2" idParameterType="30" name="fftStruct"/><HAL_FunctionsParameter descr="input" fid="151" idHAL_FunctionsParameter="112" idParameterClass="2" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="the delay" fid="151" idHAL_FunctionsParameter="113" idParameterClass="2" idParameterType="20" name="delay"/><HAL_FunctionsParameter descr="output" fid="151" idHAL_FunctionsParameter="114" idParameterClass="2" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="input" fid="111" idHAL_FunctionsParameter="115" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="biquad array" fid="111" idHAL_FunctionsParameter="116" idParameterClass="3" idParameterType="10" name="bqa"/><HAL_FunctionsParameter descr="output" fid="111" idHAL_FunctionsParameter="117" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="uuid of the pannel" fid="201" idHAL_FunctionsParameter="123" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="panel" fid="201" idHAL_FunctionsParameter="124" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="uuid of the button" fid="202" idHAL_FunctionsParameter="125" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="button" fid="202" idHAL_FunctionsParameter="126" idParameterClass="3" idParameterType="101" name="b"/><HAL_FunctionsParameter descr="uuid of the display" fid="203" idHAL_FunctionsParameter="127" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="display" fid="203" idHAL_FunctionsParameter="128" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="uuid of the LED" fid="204" idHAL_FunctionsParameter="129" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="LED" fid="204" idHAL_FunctionsParameter="130" idParameterClass="3" idParameterType="102" name="l"/><HAL_FunctionsParameter descr="the string" fid="5" idHAL_FunctionsParameter="131" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="5" idHAL_FunctionsParameter="132" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="length of the string" fid="5" idHAL_FunctionsParameter="133" idParameterClass="1" idParameterType="2" name="length"/><HAL_FunctionsParameter descr="the string" fid="6" idHAL_FunctionsParameter="134" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="6" idHAL_FunctionsParameter="135" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="position at the string where to start from" fid="6" idHAL_FunctionsParameter="136" idParameterClass="1" idParameterType="2" name="p"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="137" idParameterClass="1" idParameterType="4" name="v1"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="138" idParameterClass="1" idParameterType="4" name="v2"/><HAL_FunctionsParameter descr="panel index" fid="201" idHAL_FunctionsParameter="139" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="button index" fid="202" idHAL_FunctionsParameter="140" idParameterClass="1" idParameterType="2" name="bIndex"/><HAL_FunctionsParameter descr="panel" fid="202" idHAL_FunctionsParameter="141" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="202" idHAL_FunctionsParameter="142" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="display index" fid="203" idHAL_FunctionsParameter="143" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="panel" fid="203" idHAL_FunctionsParameter="144" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="203" idHAL_FunctionsParameter="145" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="LED index" fid="204" idHAL_FunctionsParameter="146" idParameterClass="1" idParameterType="2" name="lIndex"/><HAL_FunctionsParameter descr="panel" fid="204" idHAL_FunctionsParameter="147" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="204" idHAL_FunctionsParameter="148" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="x position" fid="200" idHAL_FunctionsParameter="149" idParameterClass="1" idParameterType="2" name="x"/><HAL_FunctionsParameter descr="y position" fid="200" idHAL_FunctionsParameter="150" idParameterClass="1" idParameterType="2" name="y"/><HAL_FunctionsParameter descr="x length" fid="200" idHAL_FunctionsParameter="151" idParameterClass="1" idParameterType="2" name="xle"/><HAL_FunctionsParameter descr="y length" fid="200" idHAL_FunctionsParameter="152" idParameterClass="1" idParameterType="2" name="yle"/><HAL_FunctionsParameter descr="ui" fid="200" idHAL_FunctionsParameter="153" idParameterClass="3" idParameterType="0" name="ui"/><HAL_FunctionsParameter descr="ui index" fid="200" idHAL_FunctionsParameter="154" idParameterClass="1" idParameterType="2" name="uiIndex"/><HAL_FunctionsParameter descr="button" fid="210" idHAL_FunctionsParameter="155" idParameterClass="3" idParameterType="101" name="b"/><HAL_FunctionsParameter descr="button index" fid="210" idHAL_FunctionsParameter="156" idParameterClass="1" idParameterType="2" name="bIndex"/><HAL_FunctionsParameter descr="LED" fid="211" idHAL_FunctionsParameter="157" idParameterClass="3" idParameterType="102" name="l"/><HAL_FunctionsParameter descr="LED index" fid="211" idHAL_FunctionsParameter="158" idParameterClass="1" idParameterType="2" name="lIndex"/><HAL_FunctionsParameter descr="if the flag is not zero the LED is turned on" fid="211" idHAL_FunctionsParameter="159" idParameterClass="1" idParameterType="2" name="onFlag"/><HAL_FunctionsParameter descr="the value of the CF" fid="55" idHAL_FunctionsParameter="160" idParameterClass="1" idParameterType="2" name="value"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="161" idParameterClass="1" idParameterType="4" name="v3"/><HAL_FunctionsParameter descr="display" fid="212" idHAL_FunctionsParameter="162" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="display index" fid="212" idHAL_FunctionsParameter="163" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="the string" fid="212" idHAL_FunctionsParameter="164" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="212" idHAL_FunctionsParameter="165" idParameterClass="1" idParameterType="2" name="iString"/><HAL_FunctionsParameter descr="integer vector" fid="20" idHAL_FunctionsParameter="166" idParameterClass="3" idParameterType="2" name="iv"/><HAL_FunctionsParameter descr="start index" fid="20" idHAL_FunctionsParameter="167" idParameterClass="1" idParameterType="2" name="iStart"/><HAL_FunctionsParameter descr="amount of values used" fid="20" idHAL_FunctionsParameter="168" idParameterClass="1" idParameterType="2" name="num"/><HAL_FunctionsParameter descr="value 1" fid="20" idHAL_FunctionsParameter="169" idParameterClass="1" idParameterType="2" name="v1"/><HAL_FunctionsParameter descr="value 2" fid="20" idHAL_FunctionsParameter="170" idParameterClass="1" idParameterType="2" name="v2"/><HAL_FunctionsParameter descr="value 3" fid="20" idHAL_FunctionsParameter="171" idParameterClass="1" idParameterType="2" name="v3"/><HAL_FunctionsParameter descr="vector a" fid="21" idHAL_FunctionsParameter="172" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="21" idHAL_FunctionsParameter="173" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector a" fid="22" idHAL_FunctionsParameter="175" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="22" idHAL_FunctionsParameter="176" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="22" idHAL_FunctionsParameter="177" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="23" idHAL_FunctionsParameter="178" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector a" fid="24" idHAL_FunctionsParameter="179" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="23" idHAL_FunctionsParameter="180" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector b" fid="24" idHAL_FunctionsParameter="181" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="23" idHAL_FunctionsParameter="182" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector c" fid="24" idHAL_FunctionsParameter="183" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="25" idHAL_FunctionsParameter="184" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="25" idHAL_FunctionsParameter="185" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="25" idHAL_FunctionsParameter="186" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="26" idHAL_FunctionsParameter="187" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="26" idHAL_FunctionsParameter="188" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="26" idHAL_FunctionsParameter="189" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="index at a vector" fid="40" idHAL_FunctionsParameter="190" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="40" idHAL_FunctionsParameter="191" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="40" idHAL_FunctionsParameter="192" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="left side number" fid="41" idHAL_FunctionsParameter="193" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="42" idHAL_FunctionsParameter="194" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="43" idHAL_FunctionsParameter="195" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="44" idHAL_FunctionsParameter="196" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="45" idHAL_FunctionsParameter="197" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="41" idHAL_FunctionsParameter="198" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="42" idHAL_FunctionsParameter="199" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="43" idHAL_FunctionsParameter="200" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="44" idHAL_FunctionsParameter="201" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="45" idHAL_FunctionsParameter="202" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="41" idHAL_FunctionsParameter="203" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="42" idHAL_FunctionsParameter="204" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="43" idHAL_FunctionsParameter="205" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="44" idHAL_FunctionsParameter="206" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="45" idHAL_FunctionsParameter="207" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="41" idHAL_FunctionsParameter="208" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="42" idHAL_FunctionsParameter="209" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="43" idHAL_FunctionsParameter="210" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="44" idHAL_FunctionsParameter="211" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="45" idHAL_FunctionsParameter="212" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="the variable (internally the index of the variable)" fid="56" idHAL_FunctionsParameter="214" idParameterClass="5" idParameterType="0" name="var"/></HAL_FunctionsParameter_List><HAL_MessageParameter_List><HAL_MessageParameter basicTypeID="2" descr="number of the global variables" idHAL_MessageParameter="1" isArray="False" msgID="10" name="globalVariableNumber" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="number of the local variables" idHAL_MessageParameter="2" isArray="False" msgID="10" name="localVariableNumber" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="number of the instructions" idHAL_MessageParameter="3" isArray="False" msgID="10" name="instructionNumber" positionIndex="2"/><HAL_MessageParameter basicTypeID="2" descr="the index of the variable" idHAL_MessageParameter="9" isArray="False" msgID="11" name="index" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="type id of the variable" idHAL_MessageParameter="10" isArray="False" msgID="11" name="varTypeID" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="number of variables" idHAL_MessageParameter="11" isArray="False" msgID="11" name="num" positionIndex="2"/><HAL_MessageParameter basicTypeID="2" descr="index of the function call" idHAL_MessageParameter="12" isArray="False" msgID="12" name="index" positionIndex="0"/><HAL_MessageParameter basicTypeID="4" descr="function byte code" idHAL_MessageParameter="13" isArray="True" msgID="12" name="fbc" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="global variable index" idHAL_MessageParameter="14" isArray="False" msgID="23" name="gIndex" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="amount of data elements" idHAL_MessageParameter="15" isArray="False" msgID="23" name="dataElements" positionIndex="1"/></HAL_MessageParameter_List><HAL_VariableDefinition_List><HAL_VariableDefinition VariableID="1" description="a rational number" idHAL_VariableDefinition="1" varName="rational"/><HAL_VariableDefinition VariableID="2" description="a integer number" idHAL_VariableDefinition="2" varName="integer"/><HAL_VariableDefinition VariableID="3" description="a string" idHAL_VariableDefinition="3" varName="string"/><HAL_VariableDefinition VariableID="10" description="a biquad filter" idHAL_VariableDefinition="4" varName="biquad"/><HAL_VariableDefinition VariableID="20" description="a delay" idHAL_VariableDefinition="5" varName="delay"/><HAL_VariableDefinition VariableID="30" description="FFT or IFFT sturcture" idHAL_VariableDefinition="6" varName="FFT"/><HAL_VariableDefinition VariableID="4" description="a complex number" idHAL_VariableDefinition="7" varName="complex"/><HAL_VariableDefinition VariableID="101" description="button UI" idHAL_VariableDefinition="8" varName="button"/><HAL_VariableDefinition VariableID="100" description="panel UI" idHAL_VariableDefinition="9" varName="panel"/><HAL_VariableDefinition VariableID="102" description="led UI" idHAL_VariableDefinition="10" varName="led"/><HAL_VariableDefinition VariableID="103" description="display UI" idHAL_VariableDefinition="11" varName="display"/></HAL_VariableDefinition_List><HAL_Function_List><HAL_Function descr="a &lt; b ? CF = 1 : CF = 0" fid="40" idHAL_Function="17" name="comparaIntegerLess"/><HAL_Function descr="a &gt; b ? CF = 1 : CF = 0" fid="41" idHAL_Function="18" name="comparaIntegerMore"/><HAL_Function descr="a == b ? CF = 1 : CF = 0" fid="42" idHAL_Function="19" name="comparaIntegerEqual"/><HAL_Function descr="a != b ? CF = 1 : CF = 0" fid="43" idHAL_Function="20" name="comparaIntegerNEqual"/><HAL_Function descr="a &lt;= b ? CF = 1 : CF = 0" fid="44" idHAL_Function="21" name="comparaIntegerLessEqual"/><HAL_Function descr="a &gt;= b ? CF = 1 : CF = 0" fid="45" idHAL_Function="22" name="comparaIntegerMoreEqual"/><HAL_Function descr="jumps n instructions" fid="50" idHAL_Function="23" name="jump"/><HAL_Function descr="jumps if the carry flag is set n instructions" fid="51" idHAL_Function="24" name="jumpCF"/><HAL_Function descr="jumps if the carry flag is not set n instructions" fid="52" idHAL_Function="25" name="jumpNCF"/><HAL_Function descr="reading a sample from an input" fid="60" idHAL_Function="26" name="readSample"/><HAL_Function descr="writes a sample to a output" fid="61" idHAL_Function="27" name="writeSample"/><HAL_Function descr="generate a test signal, witch can be used to meassure performance" fid="3" idHAL_Function="28" name="genTestSignal"/><HAL_Function descr="inits a biquad filter as an high pass filter" fid="100" idHAL_Function="29" name="initBiquadAsHP"/><HAL_Function descr="inits a biquad filter as a low pass filter" fid="101" idHAL_Function="32" name="initBiquadAsLP"/><HAL_Function descr="convolute biquad with an input and generate an output" fid="110" idHAL_Function="33" name="convoluteBiquad"/><HAL_Function descr="shifts the content of the delay" fid="150" idHAL_Function="34" name="shiftDelay"/><HAL_Function descr="inits an array as an &quot;von Hann&quot; window" fid="120" idHAL_Function="36" name="initHannWindow"/><HAL_Function descr="init FFT structure as real input FFT" fid="130" idHAL_Function="37" name="initRFFT"/><HAL_Function descr="init inverse FFT structure" fid="131" idHAL_Function="38" name="initIFFT"/><HAL_Function descr="reading a frames of sample from an input" fid="62" idHAL_Function="39" name="readSampleFrame"/><HAL_Function descr="writes a frame of samples to a output" fid="63" idHAL_Function="40" name="writeSampleFrame"/><HAL_Function descr="processes the IFFT" fid="133" idHAL_Function="43" name="processIFFT"/><HAL_Function descr="processes the real input FFT" fid="132" idHAL_Function="44" name="processRFFT"/><HAL_Function descr="shifts a vector into a delay and the content of the delay to a vector" fid="151" idHAL_Function="46" name="shiftVectorDelay"/><HAL_Function descr="convolute biquad with a vector of inputs and generate an output vector" fid="111" idHAL_Function="47" name="convoluteVectorBiquad"/><HAL_Function descr="inits a panel" fid="201" idHAL_Function="49" name="uiInitPanel"/><HAL_Function descr="inits a button" fid="202" idHAL_Function="50" name="uiInitButton"/><HAL_Function descr="inits a display" fid="203" idHAL_Function="51" name="uiInitDisplay"/><HAL_Function descr="inits a LED" fid="204" idHAL_Function="52" name="uiInitLED"/><HAL_Function descr="resets the size of a string" fid="5" idHAL_Function="53" name="setStringSize"/><HAL_Function descr="set the string" fid="6" idHAL_Function="54" name="setStringValues"/><HAL_Function descr="sets the dimension of a UI" fid="200" idHAL_Function="55" name="uiSetDim"/><HAL_Function descr="if the button was pressed the CF is set" fid="210" idHAL_Function="56" name="uiCheckButtonPressed"/><HAL_Function descr="set the LED state" fid="211" idHAL_Function="57" name="uiSetLED"/><HAL_Function descr="sets the carry flag" fid="55" idHAL_Function="58" name="setCF"/><HAL_Function descr="set the text of a display" fid="212" idHAL_Function="59" name="uiSetDisplay"/><HAL_Function descr="a = values" fid="20" idHAL_Function="60" name="assignConstInteger"/><HAL_Function descr="c = a + b" fid="22" idHAL_Function="61" name="addInteger"/><HAL_Function descr="c = a - b" fid="23" idHAL_Function="62" name="subInteger"/><HAL_Function descr="c = a * b" fid="24" idHAL_Function="63" name="mulInteger"/><HAL_Function descr="c = a / b" fid="25" idHAL_Function="64" name="divInteger"/><HAL_Function descr="a = b" fid="21" idHAL_Function="65" name="assignInteger"/><HAL_Function descr="c = mod(a,b)" fid="26" idHAL_Function="66" name="modInteger"/><HAL_Function descr="updates a global variable" fid="56" idHAL_Function="67" name="update"/></HAL_Function_List><HAL_MessageType_List><HAL_MessageType descr="acknowledge" idHAL_MessageType="1" msgID="1" name="ACK"/><HAL_MessageType descr="not acknowledge" idHAL_MessageType="2" msgID="2" name="NACK"/><HAL_MessageType descr="start sending a program" idHAL_MessageType="3" msgID="10" name="startPrg"/><HAL_MessageType descr="sends a variable" idHAL_MessageType="4" msgID="11" name="sendVariable"/><HAL_MessageType descr="sends an instruction" idHAL_MessageType="5" msgID="12" name="sendInstruction"/><HAL_MessageType descr="sings that the program transmission has completed" idHAL_MessageType="6" msgID="13" name="endPrg"/><HAL_MessageType descr="stops the AP" idHAL_MessageType="7" msgID="20" name="stop"/><HAL_MessageType descr="the AP executes one instruction" idHAL_MessageType="8" msgID="21" name="step"/><HAL_MessageType descr="the AP runs the program" idHAL_MessageType="9" msgID="22" name="run"/><HAL_MessageType descr="a variable going to be updated" idHAL_MessageType="10" msgID="23" name="updateVariable"/><HAL_MessageType descr="a AP is going to be logged in to the system" idHAL_MessageType="11" msgID="30" name="login"/><HAL_MessageType descr="a AP is going to be logged out of the system" idHAL_MessageType="12" msgID="31" name="logout"/></HAL_MessageType_List><HAL_MessageProcess_List><HAL_MessageProcess descr="log in the AP to the system" idHAL_MessageProcess="1" isRX="False" msgProcID="10" name="login">TX_login [handle=none]() {
	declare	recv	Node;
	declare	mNum	mNum;

	recv = ALL;
	loopAll drivers[driver] {
		mNum = getNewMsgNum();
		driver&gt;&gt;send(login(recv,mNum));
	}
return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handle login calls" idHAL_MessageProcess="2" isRX="True" msgProcID="30" name="login">RX_login [handle=login]() {
	declare	sender	Node;
	declare	driver	Driver;
	declare	mNum	mNum;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();

	if (!addNode(sender, driver)) {
		return driver&gt;&gt;send(login(sender,mNum));
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="runs the audio-processor" idHAL_MessageProcess="3" isRX="False" msgProcID="20" name="run">TX_run [handle=none](Node dest) {
	declare	driver	Driver;
	declare	sender	Node;
	declare	mNum	mNum;

	sender = getSelfSenderID();
	if (dest != ALL) {
		mNum = getNewMsgNum();
		driver = getDriver(dest);
		driver&gt;&gt;send(run(sender,mNum));
		return waitACK(mNum);
	}

	loopAll drivers[drv] {
		mNum = getNewMsgNum();
		drv&gt;&gt;send(run(sender,mNum));
		if (waitACK(mNum)) {
			return -1;
		}
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handles the run command" idHAL_MessageProcess="4" isRX="True" msgProcID="22" name="run">RX_run [handle=run]() {
	declare	sender			Node;
	declare	driver			Driver;
	declare	mNum			mNum;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();

	if (!runAP()) {
		return driver&gt;&gt;send(ACK(sender,mNum));
	} else {
		return driver&gt;&gt;send(NACK(sender,mNum));
	}
}
</HAL_MessageProcess><HAL_MessageProcess descr="log the AP out of the system" idHAL_MessageProcess="5" isRX="False" msgProcID="0" name="logout">TX_logout [handle=none]() {
	declare	recv	Node;
	declare	mNum	mNum;

	recv = ALL;
	loopAll drivers[driver] {
		mNum = getNewMsgNum();
		driver&gt;&gt;send(logout(recv,mNum));
	}
return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handle login calls" idHAL_MessageProcess="6" isRX="True" msgProcID="31" name="logout">RX_logout [handle=logout]() {
	declare	sender	Node;
	
	sender = getSender();

	removeNode(sender);
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="updates a global variable at diffrent systems" idHAL_MessageProcess="9" isRX="False" msgProcID="0" name="updateVariable">TX_updateVariable [handle=none](VarIndex vi) {
	declare	mNum	mNum;
	declare	V		Variable;

	V = getVariableByIndex(vi);

	loopAll nodes[node] {
		if (getNodeIDfromNode(node) != getSelfSenderID()) {
			mNum = getNewMsgNum();
			V&gt;&gt;call(sendUpdate(getVariableData(V),getDriverFromNode(node),ALL,mNum,vi));
			if (waitACK(mNum)) {
				return -1;
			}
		}
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="updates a global variable at diffrent systems" idHAL_MessageProcess="10" isRX="True" msgProcID="23" name="updateVariable">RX_updateVariable [handle=updateVariable]() {
	declare	sender			Node;
	declare	driver			Driver;
	declare	mNum			mNum;
	declare	V				Variable;
	declare	gIndex			int;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();
	gIndex = getMsgDataToInt(0);

	V = getVariableByIndex(gIndex);
	if (!V) {
		return -1;
	}

	V&gt;&gt;call(recvUpdate(getVariableData(V),getMsgDataRef()));

	return driver&gt;&gt;send(ACK(sender,mNum));
}</HAL_MessageProcess></HAL_MessageProcess_List><Includes_List><Includes idIncludes="8" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="9" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="10" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="11" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="12" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="13" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="14" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="15" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="16" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="17" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="18" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="19" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="23" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="24" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="25" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="26" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="27" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="28" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="29" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="30" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="31" includefile="-1" lib="string.h" syslib=""/><Includes idIncludes="32" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="33" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="34" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="35" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="36" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="37" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="42" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="43" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="44" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="45" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="46" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="47" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="48" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="49" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="50" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="51" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="52" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="53" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="54" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="55" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="56" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="57" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="58" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="59" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="60" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="61" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="62" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="63" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="64" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="65" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="66" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="67" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="68" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="69" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="70" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="71" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="72" includefile="AP" lib="" syslib="0"/><Includes idIncludes="73" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="74" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="75" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="77" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="78" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="79" includefile="sndfile.h" lib="sndfile-1" syslib="0"/><Includes idIncludes="84" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="85" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="86" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="87" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="88" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="89" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="90" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="91" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="92" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="93" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="95" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="96" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="98" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="99" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="102" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="103" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="104" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="105" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="107" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="108" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="111" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="112" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="113" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="114" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="115" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="116" includefile="fftw3.h" lib="libfftw3f-3" syslib="0"/><Includes idIncludes="117" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="120" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="129" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="132" includefile="sndfile.h" lib="sndfile-1" syslib="0"/><Includes idIncludes="133" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="134" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="135" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="136" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="140" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="141" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="142" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="143" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="148" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="149" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="150" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="151" includefile="sru21369.h" lib="" syslib="1"/><Includes idIncludes="152" includefile="cdef21369.h" lib="" syslib="1"/><Includes idIncludes="153" includefile="def21369.h" lib="" syslib="1"/><Includes idIncludes="154" includefile="signal.h" lib="" syslib="1"/><Includes idIncludes="155" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="156" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="159" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="160" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="161" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="162" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="163" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="164" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="166" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="167" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="168" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="169" includefile="sndfile.h" lib="sndfile-1" syslib="1"/><Includes idIncludes="170" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="171" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="172" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="173" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="174" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="177" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="178" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="179" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="180" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="185" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="188" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="189" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="190" includefile="winsock2.h" lib="ws2_32" syslib="1"/><Includes idIncludes="191" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="192" includefile="ws2tcpip.h" lib="" syslib="1"/><Includes idIncludes="193" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="195" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="196" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="197" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="198" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="199" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="200" includefile="winsock2.h" lib="ws2_32" syslib="1"/><Includes idIncludes="201" includefile="ws2tcpip.h" lib="" syslib="1"/><Includes idIncludes="203" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="204" includefile="semaphore.h" lib="" syslib="1"/><Includes idIncludes="205" includefile="pthread.h" lib="" syslib="1"/><Includes idIncludes="206" includefile="gtk/gtk.h" lib="gtk-win32-2.0" syslib="1"/><Includes idIncludes="207" includefile="glib.h" lib="glib-2.0" syslib="1"/><Includes idIncludes="208" includefile="gthread.h" lib="gthread-2.0" syslib="1"/><Includes idIncludes="209" includefile="glib-object.h" lib="gobject-2.0" syslib="1"/><Includes idIncludes="210" includefile="cairo.h" lib="cairo" syslib="1"/><Includes idIncludes="211" includefile="pango/pango.h" lib="pango-1.0" syslib="1"/><Includes idIncludes="212" includefile="semaphore.h" lib="pthread" syslib="1"/><Includes idIncludes="213" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="219" includefile="gdk/gdk.h" lib="gdk-win32-2.0" syslib="1"/><Includes idIncludes="224" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="225" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="230" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="231" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="232" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="233" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="235" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="236" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="237" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="238" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="239" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="240" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="242" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="243" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="244" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="245" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="246" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="247" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="248" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="249" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="250" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="251" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="252" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="253" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="254" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="255" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="256" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="257" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="258" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="265" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="266" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="267" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="268" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="269" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="270" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="271" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="272" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="273" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="274" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="275" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="276" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="277" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="278" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="279" includefile="AP.h" lib="" syslib="0"/></Includes_List><IncludeList_List><IncludeList idCode="10" idIncludes="8"/><IncludeList idCode="11" idIncludes="9"/><IncludeList idCode="12" idIncludes="10"/><IncludeList idCode="13" idIncludes="11"/><IncludeList idCode="14" idIncludes="12"/><IncludeList idCode="15" idIncludes="13"/><IncludeList idCode="16" idIncludes="14"/><IncludeList idCode="17" idIncludes="15"/><IncludeList idCode="18" idIncludes="16"/><IncludeList idCode="20" idIncludes="17"/><IncludeList idCode="21" idIncludes="18"/><IncludeList idCode="22" idIncludes="19"/><IncludeList idCode="26" idIncludes="23"/><IncludeList idCode="27" idIncludes="24"/><IncludeList idCode="28" idIncludes="25"/><IncludeList idCode="29" idIncludes="26"/><IncludeList idCode="30" idIncludes="27"/><IncludeList idCode="31" idIncludes="28"/><IncludeList idCode="32" idIncludes="29"/><IncludeList idCode="33" idIncludes="30"/><IncludeList idCode="33" idIncludes="31"/><IncludeList idCode="34" idIncludes="32"/><IncludeList idCode="34" idIncludes="33"/><IncludeList idCode="35" idIncludes="34"/><IncludeList idCode="35" idIncludes="35"/><IncludeList idCode="36" idIncludes="36"/><IncludeList idCode="36" idIncludes="37"/><IncludeList idCode="41" idIncludes="42"/><IncludeList idCode="41" idIncludes="43"/><IncludeList idCode="42" idIncludes="44"/><IncludeList idCode="42" idIncludes="45"/><IncludeList idCode="43" idIncludes="46"/><IncludeList idCode="43" idIncludes="47"/><IncludeList idCode="44" idIncludes="48"/><IncludeList idCode="44" idIncludes="49"/><IncludeList idCode="45" idIncludes="50"/><IncludeList idCode="45" idIncludes="51"/><IncludeList idCode="46" idIncludes="52"/><IncludeList idCode="46" idIncludes="53"/><IncludeList idCode="47" idIncludes="54"/><IncludeList idCode="47" idIncludes="55"/><IncludeList idCode="48" idIncludes="56"/><IncludeList idCode="48" idIncludes="57"/><IncludeList idCode="49" idIncludes="58"/><IncludeList idCode="49" idIncludes="59"/><IncludeList idCode="50" idIncludes="60"/><IncludeList idCode="50" idIncludes="61"/><IncludeList idCode="51" idIncludes="62"/><IncludeList idCode="51" idIncludes="63"/><IncludeList idCode="52" idIncludes="64"/><IncludeList idCode="53" idIncludes="65"/><IncludeList idCode="54" idIncludes="66"/><IncludeList idCode="54" idIncludes="67"/><IncludeList idCode="55" idIncludes="68"/><IncludeList idCode="55" idIncludes="69"/><IncludeList idCode="56" idIncludes="70"/><IncludeList idCode="58" idIncludes="71"/><IncludeList idCode="59" idIncludes="72"/><IncludeList idCode="60" idIncludes="73"/><IncludeList idCode="61" idIncludes="74"/><IncludeList idCode="62" idIncludes="75"/><IncludeList idCode="64" idIncludes="77"/><IncludeList idCode="65" idIncludes="78"/><IncludeList idCode="66" idIncludes="79"/><IncludeList idCode="71" idIncludes="84"/><IncludeList idCode="72" idIncludes="85"/><IncludeList idCode="73" idIncludes="86"/><IncludeList idCode="74" idIncludes="87"/><IncludeList idCode="75" idIncludes="88"/><IncludeList idCode="76" idIncludes="89"/><IncludeList idCode="77" idIncludes="90"/><IncludeList idCode="78" idIncludes="91"/><IncludeList idCode="79" idIncludes="92"/><IncludeList idCode="80" idIncludes="93"/><IncludeList idCode="81" idIncludes="95"/><IncludeList idCode="82" idIncludes="96"/><IncludeList idCode="84" idIncludes="98"/><IncludeList idCode="85" idIncludes="99"/><IncludeList idCode="87" idIncludes="102"/><IncludeList idCode="88" idIncludes="103"/><IncludeList idCode="90" idIncludes="104"/><IncludeList idCode="91" idIncludes="105"/><IncludeList idCode="93" idIncludes="107"/><IncludeList idCode="94" idIncludes="108"/><IncludeList idCode="93" idIncludes="111"/><IncludeList idCode="96" idIncludes="112"/><IncludeList idCode="96" idIncludes="113"/><IncludeList idCode="97" idIncludes="114"/><IncludeList idCode="97" idIncludes="115"/><IncludeList idCode="98" idIncludes="116"/><IncludeList idCode="99" idIncludes="117"/><IncludeList idCode="102" idIncludes="120"/><IncludeList idCode="111" idIncludes="129"/><IncludeList idCode="101" idIncludes="132"/><IncludeList idCode="101" idIncludes="133"/><IncludeList idCode="114" idIncludes="134"/><IncludeList idCode="115" idIncludes="135"/><IncludeList idCode="116" idIncludes="136"/><IncludeList idCode="120" idIncludes="140"/><IncludeList idCode="121" idIncludes="141"/><IncludeList idCode="122" idIncludes="142"/><IncludeList idCode="123" idIncludes="143"/><IncludeList idCode="125" idIncludes="148"/><IncludeList idCode="126" idIncludes="149"/><IncludeList idCode="125" idIncludes="150"/><IncludeList idCode="124" idIncludes="151"/><IncludeList idCode="124" idIncludes="152"/><IncludeList idCode="124" idIncludes="153"/><IncludeList idCode="124" idIncludes="154"/><IncludeList idCode="124" idIncludes="155"/><IncludeList idCode="127" idIncludes="156"/><IncludeList idCode="130" idIncludes="159"/><IncludeList idCode="131" idIncludes="160"/><IncludeList idCode="132" idIncludes="161"/><IncludeList idCode="133" idIncludes="162"/><IncludeList idCode="134" idIncludes="163"/><IncludeList idCode="135" idIncludes="164"/><IncludeList idCode="137" idIncludes="166"/><IncludeList idCode="138" idIncludes="167"/><IncludeList idCode="139" idIncludes="168"/><IncludeList idCode="140" idIncludes="169"/><IncludeList idCode="140" idIncludes="170"/><IncludeList idCode="141" idIncludes="171"/><IncludeList idCode="142" idIncludes="172"/><IncludeList idCode="143" idIncludes="173"/><IncludeList idCode="144" idIncludes="174"/><IncludeList idCode="145" idIncludes="177"/><IncludeList idCode="146" idIncludes="178"/><IncludeList idCode="147" idIncludes="179"/><IncludeList idCode="145" idIncludes="180"/><IncludeList idCode="152" idIncludes="185"/><IncludeList idCode="154" idIncludes="188"/><IncludeList idCode="155" idIncludes="189"/><IncludeList idCode="155" idIncludes="190"/><IncludeList idCode="155" idIncludes="191"/><IncludeList idCode="155" idIncludes="192"/><IncludeList idCode="155" idIncludes="193"/><IncludeList idCode="157" idIncludes="195"/><IncludeList idCode="158" idIncludes="196"/><IncludeList idCode="159" idIncludes="197"/><IncludeList idCode="155" idIncludes="198"/><IncludeList idCode="160" idIncludes="199"/><IncludeList idCode="152" idIncludes="200"/><IncludeList idCode="152" idIncludes="201"/><IncludeList idCode="161" idIncludes="203"/><IncludeList idCode="161" idIncludes="204"/><IncludeList idCode="152" idIncludes="205"/><IncludeList idCode="162" idIncludes="206"/><IncludeList idCode="162" idIncludes="207"/><IncludeList idCode="162" idIncludes="208"/><IncludeList idCode="162" idIncludes="209"/><IncludeList idCode="162" idIncludes="210"/><IncludeList idCode="162" idIncludes="211"/><IncludeList idCode="162" idIncludes="212"/><IncludeList idCode="162" idIncludes="213"/><IncludeList idCode="162" idIncludes="219"/><IncludeList idCode="162" idIncludes="224"/><IncludeList idCode="172" idIncludes="225"/><IncludeList idCode="177" idIncludes="230"/><IncludeList idCode="178" idIncludes="231"/><IncludeList idCode="179" idIncludes="232"/><IncludeList idCode="180" idIncludes="233"/><IncludeList idCode="182" idIncludes="235"/><IncludeList idCode="183" idIncludes="236"/><IncludeList idCode="184" idIncludes="237"/><IncludeList idCode="185" idIncludes="238"/><IncludeList idCode="186" idIncludes="239"/><IncludeList idCode="187" idIncludes="240"/><IncludeList idCode="189" idIncludes="242"/><IncludeList idCode="190" idIncludes="243"/><IncludeList idCode="191" idIncludes="244"/><IncludeList idCode="192" idIncludes="245"/><IncludeList idCode="193" idIncludes="246"/><IncludeList idCode="194" idIncludes="247"/><IncludeList idCode="195" idIncludes="248"/><IncludeList idCode="196" idIncludes="249"/><IncludeList idCode="1" idIncludes="250"/><IncludeList idCode="1" idIncludes="251"/><IncludeList idCode="197" idIncludes="252"/><IncludeList idCode="198" idIncludes="253"/><IncludeList idCode="199" idIncludes="254"/><IncludeList idCode="200" idIncludes="255"/><IncludeList idCode="201" idIncludes="256"/><IncludeList idCode="202" idIncludes="257"/><IncludeList idCode="203" idIncludes="258"/><IncludeList idCode="210" idIncludes="265"/><IncludeList idCode="211" idIncludes="266"/><IncludeList idCode="212" idIncludes="267"/><IncludeList idCode="213" idIncludes="268"/><IncludeList idCode="214" idIncludes="269"/><IncludeList idCode="215" idIncludes="270"/><IncludeList idCode="216" idIncludes="271"/><IncludeList idCode="219" idIncludes="272"/><IncludeList idCode="220" idIncludes="273"/><IncludeList idCode="221" idIncludes="274"/><IncludeList idCode="222" idIncludes="275"/><IncludeList idCode="223" idIncludes="276"/><IncludeList idCode="1" idIncludes="277"/><IncludeList idCode="224" idIncludes="278"/><IncludeList idCode="225" idIncludes="279"/></IncludeList_List><Code_List><Code idCode="1">// ==============================================
// generic vector interface for integer and
// rational types based on the std. C lib
// ==============================================

// ----------------------------------------------
// generic integer type
// ----------------------------------------------

// type for a generic vector based int type
typedef struct SAPgenericIntegerVector {
	int32_t *	pVal;
	int			num;
} TAPgenericIntegerVector;

// create int vector
TAPgenericIntegerVector * APgenericIntegerVector_create (int num) {
	int i;
	// alloc memory
	TAPgenericIntegerVector * pR = malloc (sizeof(TAPgenericIntegerVector));
	if (!pR) return NULL;
	pR-&gt;pVal = malloc (sizeof(int32_t)*num);
	if (!pR-&gt;pVal) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = num;
	// set memory
	for (i = 0; i&lt; num; i++) {
		pR-&gt;pVal[i] = 0;
	}
	return pR;
}

// destroy int vector
void APgenericIntegerVector_destroy (TAPgenericIntegerVector * pV) {
	if (pV) {
		free(pV-&gt;pVal);
		free(pV);
	}
}

// resize int vector
int APgenericIntegerVector_resize (TAPgenericIntegerVector * pV, int newNum) {
	int32_t * pI = realloc (pV-&gt;pVal, newNum * sizeof(int32_t));
	if (!pI) return -1;
	pV-&gt;pVal = pI;
	pV-&gt;num = newNum;
	return 0;
}

// assign a = values
int APgenericIntegerVector_assignConst (TAPgenericIntegerVector * pa, int iStart, int num, int32_t * pVals) {
	int i = iStart;
	int imax = i + num;
	int32_t * pD = pa-&gt;pVal + iStart;
	if (imax &gt; pa-&gt;num) imax = pa-&gt;num;

	for (; i &lt; imax; i++) {
		*pD = *pVals;
		pD++;
		pVals++;
	}
	return 0;
}

// assign a = b
int APgenericIntegerVector_assign (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb) {
	int imax = pa-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pa-&gt;pVal[i] = pb-&gt;pVal[i];
	}
	return 0;
}


// add c = a + b
int APgenericIntegerVector_add (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[i];
	}
	return 0;
}

// sub c = a - b
int APgenericIntegerVector_sub (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[i];
	}
	return 0;
}

// mul c = a * b
int APgenericIntegerVector_mul (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[i];
	}
	return 0;
}

// div c = a * b
int APgenericIntegerVector_div (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[i];
	}
	return 0;
}

// modulo c = a mod b
int APgenericIntegerVector_mod (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] % pb-&gt;pVal[i];
	}
	return 0;
}

// cmp Element cmp(a[i],b[j]):
//		res = -1: a &lt; b
//		res = 1 : a &gt; b
//		res = 0: a = b
int APgenericIntegerVector_cmpEle (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, int ia, int ib) {
	int zwv = pa-&gt;pVal[ia] - pb-&gt;pVal[ib];
	if (!zwv) return 0;
	if (zwv &lt; 0) return -1;
	return -2;
}


// ----------------------------------------------
// generic rational type
// ----------------------------------------------

// type for a generic vector based int type
typedef struct SAPgenericRationalVector {
	float *	pVal;
	int			num;
} TAPgenericRationalVector;

// create int vector
TAPgenericRationalVector * APgenericRationalVector_create (int num) {
	int i;
	// alloc memory
	TAPgenericRationalVector * pR = malloc (sizeof(TAPgenericRationalVector));
	if (!pR) return NULL;
	pR-&gt;pVal = malloc (sizeof(float)*num);
	if (!pR-&gt;pVal) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = num;
	// set memory
	for (i = 0; i&lt; num; i++) {
		pR-&gt;pVal[i] = 0;
	}
	return pR;
}

// destroy int vector
void APgenericRationalVector_destroy (TAPgenericRationalVector * pV) {
	if (pV) {
		free(pV-&gt;pVal);
		free(pV);
	}
}

// resize int vector
int APgenericRationalVector_resize (TAPgenericRationalVector * pV, int newNum) {
	float * pI = realloc (pV-&gt;pVal, newNum * sizeof(int32_t));
	if (!pI) return -1;
	pV-&gt;pVal = pI;
	pV-&gt;num = newNum;
	return 0;
}

// assign a = values
int APgenericRationalVector_assignConst (TAPgenericRationalVector * pa, int iStart, int num, int32_t * pVals) {
	int i = iStart;
	int imax = i + num;
	float * pD = pa-&gt;pVal + iStart;
	if (imax &gt; pa-&gt;num) imax = pa-&gt;num;

	for (; i &lt; imax; i++) {
		*pD = *pVals;
		pD++;
		pVals++;
	}
	return 0;
}

// assign a = b
int APgenericRationalVector_assign (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb) {
	int imax = pa-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pa-&gt;pVal[i] = pb-&gt;pVal[i];
	}
	return 0;
}


// add c = a + b
int APgenericRationalVector_add (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[i];
	}
	return 0;
}

// sub c = a - b
int APgenericRationalVector_sub (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[i];
	}
	return 0;
}

// mul c = a * b
int APgenericRationalVector_mul (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[i];
	}
	return 0;
}

// div c = a * b
int APgenericRationalVector_div (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[i];
	}
	return 0;
}

// modulo c = a mod b
int APgenericRationalVector_mod (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = fmod(pa-&gt;pVal[i],pb-&gt;pVal[i]);
	}
	return 0;
}

// cmp Element cmp(a[i],b[j]):
//		res = -1: a &lt; b
//		res = 1 : a &gt; b
//		res = 0: a = b
int APgenericRationalVector_cmpEle (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, int ia, int ib) {
	float zwv = pa-&gt;pVal[ia] - pb-&gt;pVal[ib];
	if (zwv == 0.f) return 0;
	if (zwv &lt; 0.f) return -1;
	return -2;
}</Code><Code idCode="2">// ===============================
// function implementation for assignRational(var id = 10)
// description: a = b
// ===============================

void HALfunc_ID10_assignRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: the source
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="3">// ===============================
// function implementation for addRational(var id = 11)
// description: c = a + b
// ===============================

void HALfunc_ID11_addRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="4">// ===============================
// function implementation for subRational(var id = 12)
// description: c = a - b
// ===============================

void HALfunc_ID12_subRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="5">// ===============================
// function implementation for mulRational(var id = 13)
// description: c = a * b
// ===============================

void HALfunc_ID13_mulRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="6">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// transmit the data
void HALimpl_1_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_1_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_1_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_1_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_1_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="7">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// transmit the data
void HALimpl_2_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_2_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_2_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_2_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="8">// ===============================
// variable implementation for a integer number(var id = 3)
// ===============================

// transmit the data
void HALimpl_3_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_3_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_3_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="9"></Code><Code idCode="10">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_1 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_1 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_1 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_1(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_1(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_1(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_1(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_1(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="11">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_2 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_2 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_2 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_2(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_2(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_2(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_2(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_2(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="12">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// create a mmu
TAPMMU AP_MMU_create (size_t poolSize) {

}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {

}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t amountInBytes) {

}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {

}
</Code><Code idCode="13">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// create a mmu
TAPMMU AP_MMU_create (size_t poolSize) {

}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {

}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t amountInBytes) {

}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {

}

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {
	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}

</Code><Code idCode="14">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="15">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="16">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="17">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="18">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="19"></Code><Code idCode="20">// ===============================
// AP uuid = 1
// ===============================



@

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	@
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	@
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

	@	
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
@
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
@MMUUnLock
	return pM;
error:
@MMUUnLock
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;
@
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
@MMUUnLock
}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="21">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="22">// ===============================
// AP uuid = 1
// ===============================




// the mutex type
typedef void * TAPMutex;

// create an AP mutex
TAPMutex APMutexCreate () {
	return NULL;
}

// delete mutex
void APMutexDelete (TAPMutex mtx) {

}

inline void APMutexLock (TAPMutex mtx) {

}

inline void APMutexUnlock (TAPMutex mtx) {

}



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
		TAPMutex mtx;
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
		pMMU-&gt;mtx = APMutexCreate();
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		APMutexDelete(pMMU-&gt;mtx);	
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return pM;
error:
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	APMutexUnlock(pMMU-&gt;MMUmutext);
}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="23">// ===============================
// variable implementation for a integer number(var id = 3)
// ===============================

// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len - iStart;

	for (i = 0;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}

// transmit the data
void HALimpl_3_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_3_create () {
return NULL;
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_3_delete (void * pVar) {

}
</Code><Code idCode="24">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================
// stdint.h
// transmit the data
void HALimpl_2_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVar, int * pframeSize) {
	return sizeof(int32_t);
}
// end init process
void HALimpl_2_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_2_create () {
	int * pI = malloc(sizeof(int32_t));
	*pI = 0;
	return pI;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVar) {
	return pVar;
}
// delete the variable
void HALimpl_2_delete (void * pVar) {
	free ((int32_t *)pVar);
}
</Code><Code idCode="25">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// transmit the data
void HALimpl_1_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_1_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_1_create () {
	float * pF = (float *) malloc (sizeof(float));
	if (pF) *pF = 0.0f;
	return pF;
}
// fill the frame with data
void HALimpl_1_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="26">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="27">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="28">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="29">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="30">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free pIP;	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="31">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free pIP;	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="32">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="33">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="34">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="35">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int32_t index, int32_t varTypeID)
{

}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP, int32_t i, int32_t * pRawInstr)
{

}


</Code><Code idCode="36">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int32_t index, int32_t varTypeID)
{

}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP, int32_t i, int32_t * pRawInstr)
{

}


</Code><Code idCode="37">// ===============================
// function implementation for assignRational(var id = 10)
// description: a = b
// ===============================

void HALfunc_ID10_assignRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: the source
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="38">// ===============================
// function implementation for addRational(var id = 11)
// description: c = a + b
// ===============================

void HALfunc_ID11_addRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="39">// ===============================
// function implementation for subRational(var id = 12)
// description: c = a - b
// ===============================

void HALfunc_ID12_subRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="40">// ===============================
// function implementation for mulRational(var id = 13)
// description: c = a * b
// ===============================

void HALfunc_ID13_mulRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="41">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="42">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pIP-&gt;sysEndian = eAP_littleEndian;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="43">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="44">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="45">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP&gt;sysEndian) {
		APendianConversation32Bit(-&gt;amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="46">// ===============================
// AP uuid = 1
// ===============================




// the mutex type
typedef void * TAPMutex;

// create an AP mutex
TAPMutex APMutexCreate () {
	return NULL;
}

// delete mutex
void APMutexDelete (TAPMutex mtx) {

}

inline void APMutexLock (TAPMutex mtx) {

}

inline void APMutexUnlock (TAPMutex mtx) {

}



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	TAPMutex		mtx;
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
		pMMU-&gt;mtx = APMutexCreate();
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		APMutexDelete(pMMU-&gt;mtx);	
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return pM;
error:
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	APMutexLock(pMMU-&gt;MMUmutext);
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	APMutexUnlock(pMMU-&gt;MMUmutext);
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="47">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="48">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (TAP * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = pAP-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="49">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			void *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = pAP-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="50">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem pMS = (TAPrealMsgSystem) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pSM-&gt;pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pSM-&gt;pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem *						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="51">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem *						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="52">// ===============================
// driver uuid =3
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_3 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_3 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_3 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_3(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_3(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_3(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_3(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_3(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="53">// ===============================
// driver uuid =4
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_4 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_4 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_4 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_4(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_4(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_4(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_4(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_4(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="54">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="55">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="56">// ===============================
// function implementation for jump(var id = 50)
// description: jumps n instructions
// ===============================

void HALfunc_ID50_jump(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter number descr: amount of instructions to jump
//	int32_t* pnumber = &amp;( pParams[0].fp_integer);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
};
</Code><Code idCode="57"></Code><Code idCode="58">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}

	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (pMsgIDandFunctAsso-&gt;msgID == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="59">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (pMsgIDandFunctAsso-&gt;msgID == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="60">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="61">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="62">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="63">// ===============================
// variable implementation for a biqaud filter(var id = 10)
// ===============================

typedef struct SAPBiquadDF2 {
	float	k;
	float	a1;
	float	a2;
	float	b1;
	float	b2;
	float	s1;
	float	s2;
} TAPBiquadDF2;

// transmit the data
void HALimpl_10_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_10_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_10_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_10_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_10_create () {
	TAPBiquadDF2 * pBQ = malloc(sizeof(TAPBiquadDF2));
	if (!pBQ) return NULL;
	pBQ-&gt;k =0.0;
	pBQ-&gt;a1 =0.0;
	pBQ-&gt;a2 =0.0;
	pBQ-&gt;b1 =0.0;
	pBQ-&gt;b2 =0.0;
	pBQ-&gt;s1 = 0.0;
	pBQ-&gt;s2 = 0.0;
	return pBQ;
}
// fill the frame with data
void HALimpl_10_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="64">// ===============================
// startup code for the audio processor abc
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="65">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="66">// ==============================
// descr: some helpers for the lib-snd-file group
// author: Stefan Jaritz
//
// the lib is the &quot;libsndfile-1&quot;
// ==============================

typedef struct SStjWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input
	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)
	unsigned int	sampleAmountCacheSize;	//!&lt; amount of samples cached before writing or/ at reading
} TStjWAVOpenInfo;

typedef struct SStjWAVFile {
	unsigned int	channel;			//!&lt; the channel
	SNDFILE *		pSndF;				//!&lt; the file
	unsigned int	isInput;			//!&lt; if &lt;&gt; 0 the channel is an input channel
	unsigned int	channelsAmount; 	//!&lt; the amount of channels
	unsigned int	sampleAmount;		//!&lt; the amount of samples at the cache
	unsigned int	maxSampleAmount;	//!&lt; the maximum sample amount
	unsigned int	dataOffset;			//!&lt; the offset of the channel at the sample cache
	float *			pCache;				//!&lt; the sample cache
	float *			pD;					//!&lt; pointer to the data
} TStjWAVFile;


typedef struct SStjWAVmodule {
	TStjWAVFile *	pChannels;
	unsigned int	number;
} TStjWAVmodule;

// fill the wav sample cache
int WAVmoduleFillCache (TStjWAVFile * pWF) {
	sf_count_t amount = (sf_count_t) pWF-&gt;maxSampleAmount;
	// read a data frame(s)
	amount = sf_readf_float (pWF-&gt;pSndF,pWF-&gt;pCache, amount);
	if (amount &lt; 1) return -1;
	// reset data pointers and indexes
	pWF-&gt;pD = pWF-&gt;pCache;
	pWF-&gt;sampleAmount = (unsigned int) amount;
	return 0;
}

// flushes the wav sample cache to disk
int WAVmoduleFlushCache (TStjWAVFile * pWF) {
	if (!pWF-&gt;sampleAmount) return 0;
	sf_count_t amount = (sf_count_t) pWF-&gt;sampleAmount;
	if (amount != sf_write_float (pWF-&gt;pSndF,pWF-&gt;pCache , amount)) return -1;
	pWF-&gt;pD = pWF-&gt;pCache;
	pWF-&gt;sampleAmount = 0;
	return 0;
}


//! close the set of wav files
void WAVmoduleExit (TStjWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		// if it is an output flush the samples to disk
		if (!pWF-&gt;isInput) {
			WAVmoduleFlushCache(pWF);
		}
		sf_close(pWF-&gt;pSndF);
		if (pWF-&gt;pCache) {
			free (pWF-&gt;pCache);
		}
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int WAVmoduleInit (
		int 				number,		//!&lt;(in) amount of files
		TStjWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjWAVmodule *		pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjWAVFile) * number);
	pModul-&gt;number = number;

	int 			i;
	SF_INFO 		info;
	TStjWAVFile * 	pWF = pModul-&gt;pChannels;
	size_t			cacheSize;

	for (i = 0;i &lt; number;i++) {
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info) ;
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info) ;
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;
		pWF-&gt;channelsAmount = (unsigned int) info.channels;
		pWF-&gt;dataOffset = (unsigned int) pWAVFiles[i].fileChannelNumber;
		pWF-&gt;maxSampleAmount = (unsigned int) pWAVFiles[i].sampleAmountCacheSize;
		cacheSize =  pWF-&gt;channelsAmount * pWF-&gt;maxSampleAmount * sizeof(float);
		pWF-&gt;pCache = malloc (cacheSize);
		if (!pWF-&gt;pCache) goto error;
		memset (pWF-&gt;pCache,0,cacheSize);
		pWF-&gt;sampleAmount = 0;
		// now fill the cache with data
		if (pWF-&gt;isInput) {
			if (WAVmoduleFillCache(pWF)) goto error;
		} else {
			pWF-&gt;pD = pWF-&gt;pCache;
		}
		pWF++;
	}
	return 0;
error:
	WAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjWAVFile * WAVmoduleFindChannel (
		TStjWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
		) {
	TStjWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int WAVmoduleGetInput (
		TStjWAVmodule *	pM,			//!&lt;(in) the module
		int				channel,	//!&lt;(in) the channel
		float *			pSample		//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjWAVFile * pWF = WAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}
	// if the cache is empty then fill it
	if (!pWF-&gt;sampleAmount) {
		if (WAVmoduleFillCache(pWF)) return -3;
	}
	// copy sample
	*pSample = pWF-&gt;pD[pWF-&gt;dataOffset];
	pWF-&gt;pD += pWF-&gt;channelsAmount;
	// now there is one sample less at the buffer
	pWF-&gt;sampleAmount--;
	return 0;
}

//! writes a sample to an output
int WAVmoduleSetOutput (
		TStjWAVmodule *	pM,			//!&lt;(in) the module
		int				channel,	//!&lt;(in) the channel
		float 			sample		//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjWAVFile * pWF = WAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// if the cache is full then flush it
	if (pWF-&gt;sampleAmount == pWF-&gt;maxSampleAmount) {
		if (WAVmoduleFlushCache(pWF)) return -3;
	}
	// now store the value
	pWF-&gt;pD[pWF-&gt;dataOffset] = sample;
	pWF-&gt;pD += pWF-&gt;channelsAmount;
	pWF-&gt;sampleAmount++;
	return 0;
}</Code><Code idCode="67">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter resValue descr: the result of the action
	float ** presValue = &amp;( pParams[1].fp_pD);

	WAVmoduleGetInput ();
};
</Code><Code idCode="68">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="69">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	void ** pchannel = &amp;( pParams[0].fp_pD);
// parameter resValue descr: the result of the action
	void ** presValue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="70">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	void ** pchannel = &amp;( pParams[0].fp_pD);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="71">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="72">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="73">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="74">// ===============================
// startup code for the audio processor
// ===============================
/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc (sizeof(int32_t)*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	int res = loadALCfromFile (&quot;../APgen/ALASM/bypass.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="75">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}



typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="76">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="77">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsgMsgSystem (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="78">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="79">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="80">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="81">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// int32_t* pchannel =  pParams[0].fp_integer;
// parameter resValue descr: the result of the action
	// int32_t* pSample =  pParams[1].fp_pD;
	
	// foreward declaration of the global variable
	extern TStjWAVmodule gWAVModule;

	if (WAVmoduleGetInput(&amp;gWAVModule,pParams[0].fp_integer,((TAPvarRational *)pParams[1].fp_pD)-&gt;pR)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="82">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
//	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
//	void ** pvalue = &amp;( pParams[1].fp_pD);

	// foreward declaration of the global variable
	extern TStjWAVmodule gWAVModule;
	if (WAVmoduleSetOutput(&amp;gWAVModule,pParams[0].fp_integer,*((TAPvarRational *)pParams[1].fp_pD)-&gt;pR)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="83">// ===============================
// function implementation for assignConstInteger(var id = 25)
// description: a = const b
// ===============================

void HALfunc_ID25_assignConstInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
//	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: constant integer
//	int32_t* pb = &amp;( pParams[1].fp_integer);
	*((int32_t*) pParams[0].fp_pD) = pParams[1].fp_integer;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="84">// ===============================
// AP uuid = 2
// ===============================

#define WAVsampleCache (20000000)

// the wav modul global var
TStjWAVmodule gWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	// init wav module
	TStjWAVOpenInfo wavIOs[] = {
			{1,&quot;input.wav&quot;,1,44100,0,WAVsampleCache},
			{2,&quot;bypass.wav&quot;,0,44100,0,WAVsampleCache},
			{3,&quot;subbass.wav&quot;,0,44100,0,WAVsampleCache},
			{4,&quot;lowerVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{5,&quot;upperVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{6,&quot;harmonics.wav&quot;,0,44100,0,WAVsampleCache},
	};

	if (WAVmoduleInit (sizeof(wavIOs) / sizeof(TStjWAVOpenInfo),wavIOs,&amp;gWAVModule)) {
		return -2;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close wav module
	WAVmoduleExit(&amp;gWAVModule);

	// close the AP
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="85">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="86">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// the internal integer type
typedef struct SAPvarInteger {
	unsigned int		num;
	int * 			pI;
}  TAPvarInteger;

// transmit the data
void HALimpl_2_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	*pframeSize = pI-&gt;num * sizeof(int32_t);
	return 1;
}
// end init process
void HALimpl_2_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_2_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarInteger * pI;
	pI = malloc(sizeof(TAPvarInteger));
	if (!pI) return NULL;

	pI-&gt;pI = malloc(sizeof(int32_t)*numberOfElements);
	if (!(pI-&gt;pI)) {
		free (pI);
		return NULL;
	}
	pI-&gt;num = numberOfElements;

	memset (pI-&gt;pI,0,sizeof(int32_t)*numberOfElements);
	return pI;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVarData) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	return pI-&gt;pI;
}
// delete the variable
void HALimpl_2_delete (void * pVarData) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	if (pI) {
		if (pI-&gt;pI) free (pI-&gt;pI);
		free (pI);
	}
}</Code><Code idCode="87">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// the internal rational type
typedef struct SAPvarRational {
	unsigned int		num;
	float * 			pR;
}  TAPvarRational;


// transmit the data
void HALimpl_1_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	*pframeSize = pR-&gt;num * sizeof(float);
	return 1;
}
// end init process
void HALimpl_1_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarRational * pR;
	pR = malloc(sizeof(TAPvarRational));
	if (!pR) return NULL;

	pR-&gt;pR = malloc(sizeof(float)*numberOfElements);
	if (!(pR-&gt;pR)) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = numberOfElements;

	memset (pR-&gt;pR,0,sizeof(float)*numberOfElements);
	return pR;

}
// fill the frame with data
void HALimpl_1_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	return pR;
}

// delete the variable
void HALimpl_1_delete (void * pVarData) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	if (pR) {
		if (pR-&gt;pR) free (pR-&gt;pR);
		free (pR);
	}
}</Code><Code idCode="88">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

typedef struct SAPBiquadDF2 {
	float	k;	// gain
	float	n1;	// nominator
	float	n2;
	float	d1; // denominator
	float	d2;
	float	s1; // delays
	float	s2;
} TAPBiquadDF2;

typedef struct SAPvarBiquad {
	unsigned int		num;
	TAPBiquadDF2 *	pB;	
} TAPvarBiquad;


// transmit the data
void HALimpl_10_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_10_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_10_frameGetNumber (void * pVarData, int * pframeSize) {
	return 0;
}
// end init process
void HALimpl_10_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_10_create (unsigned int numberOfElements) {
	TAPvarBiquad * pB = malloc (sizeof(TAPvarBiquad));
	if (!pB) return NULL;
	pB-&gt;pB = malloc(sizeof(TAPBiquadDF2)*numberOfElements);
	if (!pB-&gt;pB) {
		free (pB);
		return NULL;
	}
	pB-&gt;num = numberOfElements;
	int i;
	for (i = 0; i &lt; numberOfElements; i++) {
		pB-&gt;pB[i].k = 0.0;
		pB-&gt;pB[i].n1 = 0.0;
		pB-&gt;pB[i].n2 = 0.0;
		pB-&gt;pB[i].d1 = 0.0;
		pB-&gt;pB[i].d2 = 0.0;
		pB-&gt;pB[i].s1 = 0.0;
		pB-&gt;pB[i].s2 = 0.0;
	}
	return pB;
}
// fill the frame with data
void HALimpl_10_frameFill (void * pVarData, int frameNumber, void * pFrame) {
}

// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	TAPvarBiquad * pB = (TAPvarBiquad *) pVarData;
	return pB;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	TAPvarBiquad * pB = (TAPvarBiquad *) pVarData;
	if (pB) {
		if (pB-&gt;pB) {
			free (pB-&gt;pB);
		}
		free (pB);
	}
}
</Code><Code idCode="89">// ===============================
// variable implementation for a delay(var id = 20)
// ===============================

// map delay functions to the rational functions
#define HALimpl_20_init HALimpl_1_init


// transmit the data
void  (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_20_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_20_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_20_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_20_create (unsigned int numberOfElements) {
return NULL;
}
// fill the frame with data
void HALimpl_20_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_20_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_20_delete (void * pVarData) {

}</Code><Code idCode="90">// ===============================
// variable implementation for a delay(var id = 20)
// ===============================

// map delay to the rational datatype

#define HALimpl_20_create HALimpl_1_create
#define HALimpl_20_delete HALimpl_1_delete

#define HALimpl_20_initStart HALimpl_1_initStart
#define HALimpl_20_init HALimpl_1_init
#define HALimpl_20_initEnd HALimpl_1_initEnd

#define HALimpl_20_frameGetNumber HALimpl_1_frameGetNumber
#define HALimpl_20_frameFill HALimpl_1_frameFill

#define HALimpl_20_decodeData HALimpl_1_decodeData</Code><Code idCode="91">// ===============================
// AP uuid = 3
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="92">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
};
</Code><Code idCode="93">// ===============================
// function implementation for initBiquadAsLP(var id = 101)
// description: inits a biquad filter as a low pass filter
// ===============================

void HALfunc_ID101_initBiquadAsLP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter i descr: index at the biquad array
	int32_t i = pParams[0].fp_integer;
	// parameter fs descr: sample frequency
	float fs = pParams[1].fp_rational;
	// parameter fc descr: cut off frequency
	float fc = pParams[2].fp_rational;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[3].fp_pV-&gt;pData;

	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=k2/dn;
	float n1=2*k2/dn;
	float n2=k2/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;
		
	pBQA-&gt;pB[i].n1 = n1 / n0;
	pBQA-&gt;pB[i].n2 = n2 / n0;
	pBQA-&gt;pB[i].d1 = d1 / d0;
	pBQA-&gt;pB[i].d2 = d2 / d0;
	pBQA-&gt;pB[i].k = n0 / d0;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="94">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================

void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float * px = (float *) pParams[0].fp_pD;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	float x = *px;
	float y;
	int i;
	float d1;
	TAPBiquadDF2 * pF = pBQA-&gt;pB;

	for (i = 0; i &lt; pBQA-&gt;num; i++) {
		// filter
		d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + x);
		y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
		y *= pF-&gt;k;

		pF-&gt;s2 = pF-&gt;s1;
		pF-&gt;s1 = d1;
		// output is input for the next filter
		x = y;
		pF++;
	}

	// save result to the output
	*py = y;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};</Code><Code idCode="95">// ===============================
// function implementation for shiftDelay(var id = 150)
// description: shifts the content of the delay
// ===============================

void HALfunc_ID150_shiftDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float * px = (float *) pParams[0].fp_pD;
	// parameter delay descr: the delay
	TAPvarRational * pDelay = (TAPvarRational *) pParams[1].fp_pD;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// save oldest value
	int imax = pDelay-&gt;num-1;

	*py = pDelay-&gt;pR[imax];

	// shift value (we copy only num -1 values with the offset of 1)
	memcpy (pDelay-&gt;pR+1,pDelay-&gt;pR,imax);

	// save the input
	*pDelay-&gt;pR = *px;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="96">// ===============================
// function implementation for shiftDelay(var id = 150)
// description: shifts the content of the delay
// ===============================

void HALfunc_ID150_shiftDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float x = *((float *) pParams[0].fp_pD);
	// parameter delay descr: the delay
	TAPvarRational * pDelay = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// save oldest value
	int imax = pDelay-&gt;num-1;

	*py = pDelay-&gt;pR[imax];

	// shift value (we copy only num -1 values with the offset of 1)
	memcpy (pDelay-&gt;pR+1,pDelay-&gt;pR,imax*sizeof(float));

	// save the input
	*pDelay-&gt;pR = x;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="97">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter i descr: index at the biquad array
	int32_t i = pParams[0].fp_integer;
	// parameter fs descr: sample frequency
	float fs = pParams[1].fp_rational;
	// parameter fc descr: cut off frequency
	float fc = pParams[2].fp_rational;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[3].fp_pV-&gt;pData;

	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=1/dn;
	float n1=-2/dn;
	float n2=1/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;

	pBQA-&gt;pB[i].n1 = n1 / n0;
	pBQA-&gt;pB[i].n2 = n2 / n0;
	pBQA-&gt;pB[i].d1 = d1 / d0;
	pBQA-&gt;pB[i].d2 = d2 / d0;
	pBQA-&gt;pB[i].k = n0 / d0;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="98">//  ==================================
// fftw3 libis used for complex and fft &amp; ifft functions
//  ==================================</Code><Code idCode="99">// ===============================
// variable implementation for a complex number(var id = 4)
// ===============================

// the type for the complex data struct
typedef struct SAPvarComplex {
	fftwf_complex *	pC;
	int				num;
} TAPvarComplex;

// transmit the data
void HALimpl_4_init (void * pVarData, int frameNumber, void * pData) {

}

// start the init process
void HALimpl_4_initStart (void * pVarData, int frameNumber, int bigEndian) {

}

// get the frame Number and size
int HALimpl_4_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	*pframeSize = pC-&gt;num * sizeof(fftwf_complex);
	return 1;
}

// end init process
void HALimpl_4_initEnd (void * pVarData) {

}

// create a new variable
void * HALimpl_4_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarComplex * pC;
	pC = malloc(sizeof(TAPvarComplex));
	if (!pC) return NULL;

	pC-&gt;pC = fftwf_malloc(sizeof(fftwf_complex)*numberOfElements);
	if (!(pC-&gt;pC)) {
		free (pC);
		return NULL;
	}
	pC-&gt;num = numberOfElements;

	memset (pC-&gt;pC,0,sizeof(fftwf_complex)*numberOfElements);
	return pC;
}

// fill the frame with data
void HALimpl_4_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}

// decode data for the HAL functions
void * HALimpl_4_decodeData (void * pVarData) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	return pC-&gt;pC;
}

// delete the variable
void HALimpl_4_delete (void * pVarData) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	if (pC) {
		if (pC-&gt;pC) fftwf_free(pC-&gt;pC);
		free (pC);
	}
}</Code><Code idCode="100">// ===============================
// variable implementation for FFT or IFFT sturcture(var id = 30)
// ===============================

// transmit the data
void HALimpl_30_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_30_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_30_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_30_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_30_create (unsigned int numberOfElements) {
	return NULL;
}
// fill the frame with data
void HALimpl_30_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_30_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_30_delete (void * pVarData) {
	if (pVarData) {
		fftwf_destroy_plan(pVarData);
	}
}
</Code><Code idCode="101">// ============================================================
// descr: some helpers for the lib-snd-file group
// author: Stefan Jaritz
//
// the lib is the &quot;libsndfile-1&quot;
// ============================================================

// defines

typedef struct SStjFrameOverlappedWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input

	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)

	unsigned int	frameSize;				//!&lt; number of samples per frame
	unsigned int	overlappingNumber;		//!&lt; the number of samples kept in the frame at reading/writing
} TStjFrameOverlappedWAVOpenInfo;

typedef struct SStjFrameOverlappedWAVFile {
	unsigned int	channel;				//!&lt; the channel
	SNDFILE *		pSndF;					//!&lt; the file
	unsigned int	isInput;				//!&lt; if 0 the channel is an input channel

	float *			pRB;					//!&lt; the ring buffer storing/writing the samples
	unsigned int	rbFrameSize;			//!&lt; the size of the frames at the ring buffer
	unsigned int	FrameSize;				//!&lt; amount of samples at the frame
	unsigned int	nMax;					//!&lt; number of elements at the ring buffer
	unsigned int	n;						//!&lt; actual element (for inputs)/ the offset (output)
} TStjFrameOverlappedWAVFile;

typedef struct SStjFrameOverlappedWAVmodule {
	TStjFrameOverlappedWAVFile *	pChannels;
	unsigned int		number;
} TStjFrameOverlappedWAVmodule;

//! close the set of wav files
void FrameOverlappedWAVmoduleExit (TStjFrameOverlappedWAVmodule * pM);

//! initis a set of wav files for writing / reading
int FrameOverlappedWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameOverlappedWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameOverlappedWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	);

//! looking for the right channel
TStjFrameOverlappedWAVFile * FrameOverlappedWAVmoduleFindChannel (
		TStjFrameOverlappedWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
	);

//! reads a sample from a channel
int FrameOverlappedWAVmoduleGetInput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(out) pointer to the sample buffer witch is filled
	);

//! writes a sample to an output
int FrameOverlappedWAVmoduleSetOutput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(in) pointer to the sample buffer witch is filled
	);

// functions

//! close the set of wav files
void FrameOverlappedWAVmoduleExit (TStjFrameOverlappedWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjFrameOverlappedWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		sf_close(pWF-&gt;pSndF);
		free (pWF-&gt;pRB);
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int FrameOverlappedWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameOverlappedWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameOverlappedWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjFrameOverlappedWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjFrameOverlappedWAVFile) * number);
	pModul-&gt;number = number;

	int 				i;
	SF_INFO 			info;
	TStjFrameOverlappedWAVFile * 	pWF = pModul-&gt;pChannels;

	for (i = 0;i &lt; number;i++) {
		// open sndfile interface
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info) ;
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info) ;
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;

		// prepare buffers
		pWF-&gt;FrameSize = pWAVFiles[i].frameSize;
		if (pWAVFiles[i].frameSize % pWAVFiles[i].overlappingNumber) {
			goto error;
		}
		pWF-&gt;nMax = pWAVFiles[i].frameSize / pWAVFiles[i].overlappingNumber;
		pWF-&gt;rbFrameSize = pWAVFiles[i].overlappingNumber;
		// if it's an input we need a memory for the old frames witch are read before
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pRB = malloc(sizeof(float)*pWAVFiles[i].frameSize);
			if (!pWF-&gt;pRB){
				goto error;
			}
			memset(pWF-&gt;pRB,0,sizeof(float)*pWAVFiles[i].frameSize);
			pWF-&gt;n = 0;
		} else {
			pWF-&gt;pRB = NULL;
			// the n is used as offset
			pWF-&gt;n = pWAVFiles[i].frameSize - pWAVFiles[i].overlappingNumber;
		}
		pWF++;
	}
	return 0;
error:
	FrameOverlappedWAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjFrameOverlappedWAVFile * FrameOverlappedWAVmoduleFindChannel (
		TStjFrameOverlappedWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
		) {
	TStjFrameOverlappedWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int FrameOverlappedWAVmoduleGetInput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjFrameOverlappedWAVFile * pWF = FrameOverlappedWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}

	// check the offset at the ringbuffer
	if (pWF-&gt;n &gt;= pWF-&gt;nMax) pWF-&gt;n = 0;

	int offset;
	int idx = pWF-&gt;rbFrameSize * pWF-&gt;n;
	// fill the buffer

	sf_count_t am = sf_readf_float (pWF-&gt;pSndF,&amp;pWF-&gt;pRB[idx], (sf_count_t) pWF-&gt;rbFrameSize);

	if (am == 0) return -3;
	if (am != (sf_count_t) pWF-&gt;rbFrameSize) {
		offset = (sf_count_t) am;
		// calc the missing samples
		am = (sf_count_t) pWF-&gt;rbFrameSize - am;
		// set the buffer to 0
		memset(&amp;pWF-&gt;pRB[idx+offset],0,sizeof(float)*am);
	}
	// build the frame
	// on pos n is the newest frame
	// n+1 is oldest frame
	int nStart = pWF-&gt;n + 1;
	int amount;

	// copy all frames left from the newest block till the wrapping
	amount = pWF-&gt;nMax - nStart;
	if (amount) {
		memcpy(pFrame,&amp;pWF-&gt;pRB[nStart*pWF-&gt;rbFrameSize],sizeof(float)*amount*pWF-&gt;rbFrameSize);
	}
	nStart = amount;
	// wrap and copy the rest of it
	amount = pWF-&gt;nMax - amount;
	memcpy(&amp;pFrame[nStart*pWF-&gt;rbFrameSize],pWF-&gt;pRB,sizeof(float)*amount*pWF-&gt;rbFrameSize);
	// remember that we received a frame(with wrapping)
	pWF-&gt;n++;
	return 0;
}

//! writes a sample to an output
int FrameOverlappedWAVmoduleSetOutput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjFrameOverlappedWAVFile * pWF = FrameOverlappedWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// the last samples at the frame are new
	if (pWF-&gt;rbFrameSize != sf_write_float (pWF-&gt;pSndF,&amp;pFrame[pWF-&gt;n] , pWF-&gt;rbFrameSize)) return -3;

	return 0;
}

// ====================================================================
</Code><Code idCode="102">// ===============================
// AP uuid = 4
// ===============================

// the global var for the Frame WAV modul
TStjFrameWAVmodule gFrameWAVModule;


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// setup the wav modul

	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;input.wav&quot;,1,44100,1,1024,256},
			{2,&quot;output.wav&quot;,0,44100,1,1024,256}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	// closes the wav frame modul
	FrameWAVmoduleExit(&amp;gFrameWAVModule);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="103">// ===============================
// function implementation for initFFT(var id = 130)
// description: init FFT structure
// ===============================

void HALfunc_ID130_initFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  *(pParams[0].fp_integer);
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="104">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  *(pParams[0].fp_integer);
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="105">// ===============================
// function implementation for processFFT(var id = 132)
// description: processes the FFT
// ===============================

void HALfunc_ID132_processFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter fftStruct descr: the fft info structure
	TAPInterpreterVariable ** pfftStruct = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="106">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter ifftStruct descr: the ifft info structure
	TAPInterpreterVariable ** pifftStruct = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="107">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  pParams[0].fp_integer;
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarComplex * py = (TAPvarComplex *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_r2c_1d(N, px-&gt;pR, py-&gt;pC, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="108">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan * pP = pParams[0].fp_pD;
	fftwf_execute(*pP);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="109">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  pParams[0].fp_integer;
	// parameter x descr: input
	TAPvarComplex * px = (TAPvarComplex *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_c2r_1d(N, px-&gt;pC, py-&gt;pR, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="110">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan * pP = pParams[0].fp_pD;
	fftwf_execute(*pP);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="111">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;framebasedBypass.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) return EXIT_FAILURE;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);

	free (varL);
	free (instrL);

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);


#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="112">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer witch receives the samples
	TAPInterpreterVariable ** pframeBuffer = &amp;( pParams[1].fp_pV);

	extern TStjFrameWAVmodule gFrameWAVModule;
};


// parameter channel descr: the channel
	// int32_t* pchannel =  pParams[0].fp_integer;
// parameter resValue descr: the result of the action
	// int32_t* pSample =  pParams[1].fp_pD;
	
	// foreward declaration of the global variable


	if (WAVmoduleGetInput(&amp;gWAVModule,pParams[0].fp_integer,pParams[1].fp_pD)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;</Code><Code idCode="113">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	TAPInterpreterVariable ** pframeBuffer = &amp;( pParams[1].fp_pV);
};
</Code><Code idCode="114">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer witch receives the samples
error rational vartype
	float * pFrame = (float *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleGetInput(&amp;gFrameWAVModule,channel,pFrame)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="115">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer which is writen to the channel
error rational vartype
	float * pFrame = (float *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleSetOutput(&amp;gFrameWAVModule,channel,pFrame)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
}</Code><Code idCode="116">// ===============================
// variable implementation for FFT or IFFT sturcture(var id = 30)
// ===============================

// transmit the data
void HALimpl_30_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_30_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_30_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_30_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_30_create (unsigned int numberOfElements) {
	return NULL;
}
// fill the frame with data
void HALimpl_30_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_30_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_30_delete (void * pVarData) {
	if (pVarData) {
		fftwf_destroy_plan(pVarData);
	}
}
</Code><Code idCode="117">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	float * px = (float *) pParams[1].fp_pD;
	
	// parameter y descr: output
	fftwf_complex * py = (fftwf_complex *) pParams[2].fp_pD;
	
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	fftwf_plan P = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);
	*pP = P;

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="118">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	fftwf_complex * px = (fftwf_complex *) pParams[1].fp_pD;
	
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;
	
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	fftwf_plan P = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);
	*pP = P;

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};</Code><Code idCode="119">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan P = (fftwf_plan)pParams[0].fp_pD;
	fftwf_execute(P);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="120">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter fftStruct descr: the fft structure
	fftwf_execute(pParams[0].fp_pV-&gt;pData);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
}</Code><Code idCode="121">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	float * px = (float *) pParams[1].fp_pD;
	
	// parameter y descr: output
	fftwf_complex * py = (fftwf_complex *) pParams[2].fp_pD;

	// parameter fftStruct descr: FFT structure
	TAPInterpreterVariable * pFFTVar = pParams[3].fp_pV;

	if (pFFTVar-&gt;pData) fftwf_destroy_plan(pFFTVar-&gt;pData);
	pFFTVar-&gt;pData = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};


	
</Code><Code idCode="122">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;

	// parameter x descr: input
	fftwf_complex * px = (fftwf_complex *) pParams[1].fp_pD;

	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// parameter fftStruct descr: FFT structure
	TAPInterpreterVariable * pFFTVar = pParams[3].fp_pV;

	if (pFFTVar-&gt;pData) fftwf_destroy_plan(pFFTVar-&gt;pData);
	pFFTVar-&gt;pData = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="123">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter fftStruct descr: the fft structure
	fftwf_execute(pParams[0].fp_pV-&gt;pData);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="124">#define SRUDEBUG  // Check SRU Routings for errors.

#define DAC4
#define DAC3

// math defines

#ifndef M_E
	#define M_E		2.7182818284590452354
#endif

#ifndef M_LOG2E
	#define M_LOG2E		1.4426950408889634074
#endif

#ifndef M_LOG10E
	#define M_LOG10E	0.43429448190325182765
#endif

#ifndef M_LN2
	#define M_LN2		0.69314718055994530942
#endif

#ifndef M_LN10
	#define M_LN10		2.30258509299404568402
#endif

#ifndef M_PI
	#define M_PI		3.14159265358979323846
#endif

#ifndef M_PI_2
	#define M_PI_2		1.57079632679489661923
#endif

#ifndef M_PI_4
	#define M_PI_4		0.78539816339744830962
#endif

#ifndef M_1_PI
	#define M_1_PI		0.31830988618379067154
#endif

#ifndef M_2_PI
	#define M_2_PI		0.63661977236758134308
#endif

#ifndef M_2_SQRTPI
	#define M_2_SQRTPI	1.12837916709551257390
#endif

#ifndef M_SQRT2
	#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT1_2
	#define M_SQRT1_2	0.70710678118654752440
#endif

// ===============================
// // extra code for group &quot;ADSP 21369&quot;
// ===============================

// The following definition allows the SRU macro to check for errors. Once the routings have
// been verified, this definition can be removed to save some program memory space.
// The preprocessor will issue a warning stating this when using the SRU macro without this
// definition
#define SRUDEBUG  // Check SRU Routings for errors.
#include &lt;SRU.h&gt;


// c includes
#include &lt;stdio.h&gt;

// =======================================================
// AD 1835 defines
// =======================================================

//
//  AD1835.h
//
//  Configuration values for the AD1835A codec
//

#define DACCTRL1   	(0x0000)  // DAC control register 1    (R/W)
#define DACCTRL2   	(0x1000)  // DAC control register 2    (R/W)
#define DACVOL_L1   (0x2000)  // DAC volume - left 1       (R/W)
#define DACVOL_R1   (0x3000)  // DAC volume - right 1      (R/W)
#define DACVOL_L2   (0x4000)  // DAC volume - left 2       (R/W)
#define DACVOL_R2   (0x5000)  // DAC volume - right 2      (R/W)
#define DACVOL_L3   (0x6000)  // DAC volume - left 3       (R/W)
#define DACVOL_R3   (0x7000)  // DAC volume - right 3      (R/W)
#define DACVOL_L4   (0x8000)  // DAC volume - left 4       (R/W)
#define DACVOL_R4   (0x9000)  // DAC volume - right 4      (R/W)
#define ADCPEAKL   	(0xA000)  // ADC left peak              (R)
#define ADCPEAKR   	(0xB000)  // ADC right peak             (R)
#define ADCCTRL1   	(0xC000)  // ADC control 1             (R/W)
#define ADCCTRL2   	(0xD000)  // ADC control 2             (R/W)
#define ADCCTRL3   	(0xE000)  // ADC control 3             (R/W)

#define RD         	(0x0800)
#define WR         	(0x0000)  // Write to register


// DAC control register 1
#define DEEMPH44_1 	(0x0100)  // Deemphasis filter for 44.1 KHz
#define DEEMPH32   	(0x0200)  // Deemphasis filter for 32.0 KHz
#define DEEMPH48   	(0x0300)  // Deemphasis filter for 48.0 KHz

#define DACI2S     	(0x0000)  // DAC receives I2S format
#define DACRJ      	(0x0020)  // DAC receives I2S format
#define DACDSP     	(0x0040)  // DAC receives I2S format
#define DACLJ      	(0x0060)  // DAC receives I2S format
#define DACPACK256 	(0x0080)  // DAC receives I2S format

#define DAC24BIT   	(0x0000)  // 24-bit output word length
#define DAC20BIT   	(0x0008)  // 20-bit output word length
#define DAC16BIT   	(0x0010)  // 16-bit output word length

#define DACPOWERDN 	(0x0004)  // DAC into power-down mode

#define DACFS48    	(0x0000)  // Sample rate = 48 KHz (x8)
#define DACFS96    	(0x0001)  // Sample rate = 96 KHz (x4)
#define DACFS192   	(0x0002)  // Sample rate = 192 KHz (x2)


// DAC control register 2

#define DACREPLICATE  (0x0100)  // Replicate output of DAC 1/2 on 3/4, 5/6 &amp; 7/8
#define DACMUTE_R4    (0x0080)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L4    (0x0040)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R3    (0x0020)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L3    (0x0010)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R2    (0x0008)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L2    (0x0004)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R1    (0x0002)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L1    (0x0001)  // Mute DAC output channel (clear to un-mute)


//-------------------------------------------------------------------------------
//DAC Volume Control - 10-bit granularity (1024 levels)
#define DACVOL_MIN      (0x000)
#define DACVOL_LOW      (0X100)
#define DACVOL_MED      (0X200)
#define DACVOL_HI       (0X300)
#define DACVOL_MAX      (0x3FF)
#define DACVOL_MASK     (0x3FF)  // Volume in dB is in 10 LSBs
                                 //   3FF = 0 dBFS = 1023/1023
                                 //   3FE = -0.01 dBFS = 1022/1023
                                 //      ...
                                 //   002 = -50.7 dBFS = 3/1023
                                 //   001 = -54.2 dBFS = 2/1023

//-------------------------------------------------------------------------------
//  ADC Control 1

#define ADCHPF     (0x0100)  // High pass filter (AC-coupled)
#define ADCPOWERDN (0x0080)  // DAC into power-down mode
#define ADCFS48    (0x0000)  // Sample rate = 48 KHz
#define ADCFS96    (0x0040)  // Sample rate = 96 KHz

//-------------------------------------------------------------------------------
//  ADC Control 2

#define AUXSLAVE   (0x0000)  // Aux input is in slave mode
#define AUXMASTER  (0x0200)  // Aux input is in master mode

#define ADCI2S     (0x0000)  // ADC transmits in I2S format
#define ADCRJ      (0x0040)  // ADC transmits in right-justified format
#define ADCDSP     (0x0080)  // ADC transmits in DSP (TDM) format
#define ADCLJ      (0x00C0)  // ADC transmits in left-justified format
#define ADCPACK256 (0x0100)  // ADC transmits in packed 256 format
#define ADCAUX256  (0x0180)  // ADC transmits in packed 128 format

#define ADC24BIT   (0x0000)  // 24-bit output word length
#define ADC20BIT   (0x0010)  // 20-bit output word length
#define ADC16BIT   (0x0020)  // 16-bit output word length

#define ADCMUTER   (0x0002)  // Mute right channel from ADC
#define ADCMUTEL   (0x0001)  // Mute right channel from ADC

//-------------------------------------------------------------------------------
//  ADC Control 3

#define IMCLKx2    (0x0000)  // Internal MCLK = external MCLK x 2
#define IMCLKx1    (0x0040)  // Internal MCLK = external MCLK
#define IMCLKx23   (0x0080)  // Internal MCLK = external MCLK x 2/3

#define PEAKRDEN   (0x0020)  // Enable reads of peak ADC levels
#define PEAKLEVELMASK  (0x003F)  // Six significant bit of level
									// 000000 = 0dBFS, -1dB/LSB


// =======================================================
// talk through interface
// =======================================================
#define NUM_SAMPLES 1024

// Function prototypes for this talkthrough code

extern void InitPLL_SDRAM(void);
extern void processBlock(unsigned int *);

extern void InitSRU(void);
extern void Init1835viaSPI(void);

extern void InitSPORT(void);
extern void TalkThroughISR(int);
extern void ClearSPORT(void);

extern void SetupSPI1835 (void) ;
extern void DisableSPI1835 (void) ;
extern void Configure1835Register (int i) ;
extern unsigned int Get1835Register (int i) ;

extern void SetupIRQ01 (void) ;
extern void Irq0ISR (int i) ;
extern void Irq1ISR (int i) ;

extern void Delay (int i) ;

// =======================================================
// init AD1835
// =======================================================
/* Setup the SPI pramaters here in a buffer first */
unsigned int Config1835Param [] = {
            WR | DACCTRL1 | DACI2S | DAC24BIT | DACFS48,
            WR | DACCTRL2 ,//| DACMUTE_R4 | DACMUTE_L4,
            WR | DACVOL_L1 | DACVOL_MAX,
            WR | DACVOL_R1 | DACVOL_MAX,
            WR | DACVOL_L2 | DACVOL_MAX,
            WR | DACVOL_R2 | DACVOL_MAX,
            WR | DACVOL_L3 | DACVOL_MAX,
            WR | DACVOL_R3 | DACVOL_MAX,
            WR | DACVOL_L4 | DACVOL_MAX,
            WR | DACVOL_R4 | DACVOL_MAX,
            WR | ADCCTRL1 | ADCFS48,
            WR | ADCCTRL2 | ADCI2S | ADC24BIT,
            WR | ADCCTRL3 | IMCLKx2
        } ;

volatile int spiFlag ;

//Set up the SPI port to access the AD1835
void SetupSPI1835 ()
{
    /* First configure the SPI Control registers */
    /* First clear a few registers     */
    *pSPICTL = (TXFLSH | RXFLSH) ;
    *pSPIFLG = 0;
    *pSPICTL = 0;

    /* Setup the baud rate to 500 KHz */
    *pSPIBAUD = 100;

    /* Setup the SPI Flag register to FLAG3 : 0xF708*/
    *pSPIFLG = 0xF708;

    /* Now setup the SPI Control register : 0x5281*/
    *pSPICTL = (SPIEN | SPIMS | MSBF | WL16 | TIMOD1) ;

}

//Disable the SPI Port
void DisableSPI1835 ()
{
    *pSPICTL = (TXFLSH | RXFLSH);
}

//Send a word to the AD1835 via SPI
void Configure1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI to indicate that it has finished.
    while (1)
    {
        if (*pSPISTAT &amp; SPIF)
            break ;
    }
    Delay (100) ;
}

//Receive a register setting from the AD1835
unsigned int Get1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI port to indicate that it has finished
    while (1)
    {
        if (SPIF &amp; *pSPISTAT)
            break ;
    }
    Delay (100) ;
    return *pRXSPI ;
//  return i ;
}

//Set up all AD1835 registers via SPI
void Init1835viaSPI()
{
    int configSize = sizeof (Config1835Param) / sizeof (int) ;
    int i ;

    SetupSPI1835 () ;

    for (i = 0; i &lt; configSize; ++i)
    {
        Configure1835Register (Config1835Param[i]) ;
    }

    DisableSPI1835 () ;

}

//Delay loop
void Delay (int i)
{
    for (;i&gt;0;--i)
        asm (&quot;nop;&quot;) ;
}

// =======================================================
// PLL for SDRAM init
// =======================================================
void InitPLL_SDRAM(){

int i, pmctlsetting;

//Change this value to optimize the performance for quazi-sequential accesses (step &gt; 1)
#define SDMODIFY 1

    pmctlsetting= *pPMCTL;
    pmctlsetting &amp;= ~(0xFF); //Clear

    // CLKIN= 24.576 MHz, Multiplier= 27, Divisor= 1, INDIV=1, CCLK_SDCLK_RATIO= 2.
    // Core clock = (24.576 MHz * 27) /2 = 331.776 MHz
    pmctlsetting= SDCKR2|PLLM27|INDIV|DIVEN;
    *pPMCTL= pmctlsetting;
    pmctlsetting|= PLLBP;
    *pPMCTL= pmctlsetting;

    //Wait for around 4096 cycles for the pll to lock.
    for (i=0; i&lt;4096; i++)
          asm(&quot;nop;&quot;);

    *pPMCTL ^= PLLBP;       //Clear Bypass Mode
    *pPMCTL |= (CLKOUTEN);  //and start clkout


    // Programming SDRAM control registers and enabling SDRAM read optimization
    // CCLK_SDCLK_RATIO= 2.5
    // RDIV = ((f SDCLK X t REF )/NRA) - (tRAS + tRP )
    // (166*(10^6)*64*(10^-3)/4096) - (7+3) = 2583

    *pSDRRC= (0xA17)|(SDMODIFY&lt;&lt;17)|SDROPT;

    //===================================================================
    //
    // Configure SDRAM Control Register (SDCTL) for PART MT48LC4M32B2
    //
    //  SDCL3  : SDRAM CAS Latency= 3 cycles
    //  DSDCLK1: Disable SDRAM Clock 1
    //  SDPSS  : Start SDRAM Power up Sequence
    //  SDCAW8 : SDRAM Bank Column Address Width= 8 bits
    //  SDRAW12: SDRAM Row Address Width= 12 bits
    //  SDTRAS7: SDRAM tRAS Specification. Active Command delay = 7 cycles
    //  SDTRP3 : SDRAM tRP Specification. Precharge delay = 3 cycles.
    //  SDTWR2 : SDRAM tWR Specification. tWR = 2 cycles.
    //  SDTRCD3: SDRAM tRCD Specification. tRCD = 3 cycles.
    //
    //--------------------------------------------------------------------

    *pSDCTL= SDCL3|DSDCLK1|SDPSS|SDCAW8|SDRAW12|SDTRAS7|SDTRP3|SDTWR2|SDTRCD3;

    // Note that MS2 &amp; MS3 pin multiplexed with flag2 &amp; flag3.
    // MSEN bit must be enabled to access SDRAM, but LED7 cannot be driven with sdram
    *pSYSCTL |=MSEN;

    // Mapping Bank 2 to SDRAM
    // Make sure that jumper is set appropriately so that MS2 is connected to
    // chip select of 16-bit SDRAM device
    *pEPCTL |=B2SD;
    *pEPCTL &amp;= ~(B0SD|B1SD|B3SD);

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL0) Bank 0 for the ISSI IS61LV5128
    //
    //  WS2 : Wait States = 2 cycles
    //  HC1  : Bus Hold Cycle (at end of write access)= 1 cycle.
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //SRAM Settings
    *pAMICTL0 = WS2|HC1|AMIEN|BW8;

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL) Bank 1 for the AMD AM29LV08
    //
    //  WS23 : Wait States= 23 cycles
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //Flash Settings
    *pAMICTL1 = WS23|AMIEN|BW8;
}

// =======================================================
// serial Port
// =======================================================
/*
   Here is the mapping between the SPORTS and the DACS
   ADC -&gt; DSP  : SPORT0A : I2S
   DSP -&gt; DAC1 : SPORT1A : I2S
   DSP -&gt; DAC2 : SPORT1B : I2S
   DSP -&gt; DAC3 : SPORT2A : I2S
   DSP -&gt; DAC4 : SPORT2B : I2S
*/

unsigned int PCI = 0x00080000 ;
unsigned int OFFSET = 0x00080000 ;

// TCB blocks for Chaining
//Each block will be used for:
//      Filling from the ADC
//      Processing filled data
//      Sending to DAC
//
//Each one is doing only one of these steps for each SPORT interrupt.

//For this example the startup state is
// Start to 1st interrupt: gBlock_A is filled first, gBlock_C is sent
// 1st int to 2nd int: gBlock_C filled, gBlock_A processed, gBlock_B sent
// 2nd int to 3rd int: gBlock_B filled, gBlock_C processed, gBlock_A sent
// 3rd int to 4th int: gBlock_A filled, gBlock_B processed, gBlock_C sent
unsigned int gBlock_A[NUM_SAMPLES] ;
unsigned int gBlock_B[NUM_SAMPLES] ;
unsigned int gBlock_C[NUM_SAMPLES] ;

//Set up the TCBs to rotate automatically
int TCB_gBlock_A[4] = { 0, sizeof(gBlock_A), 1, 0};;
int TCB_gBlock_B[4] = { 0, sizeof(gBlock_B), 1, 0};
int TCB_gBlock_C[4] = { 0, sizeof(gBlock_C), 1, 0};

void InitSPORT()
{
    //Proceed from Block A to Block C
    TCB_gBlock_A[0] = (int) TCB_gBlock_C + 3 - OFFSET + PCI ;
    TCB_gBlock_A[3] = (unsigned int) gBlock_A - OFFSET ;

    //Proceed from Block B to Block A
    TCB_gBlock_B[0] = (int) TCB_gBlock_A + 3 - OFFSET + PCI ;
    TCB_gBlock_B[3] = (unsigned int) gBlock_B - OFFSET ;

    //Proceed from Block C to Block B
    TCB_gBlock_C[0] = (int) TCB_gBlock_B + 3 - OFFSET + PCI ;
    TCB_gBlock_C[3] = (unsigned int) gBlock_C - OFFSET ;

    //Clear the Mutlichannel control registers
    *pSPMCTL0 = 0;
    *pSPMCTL1 = 0;
    *pSPMCTL2 = 0;
    *pSPCTL0 = 0 ;
    *pSPCTL1 = 0 ;
    *pSPCTL2 = 0 ;

    //============================================================
    //
    // Configure SPORT 0 for input from ADC
    //
    //------------------------------------------------------------


    *pSPCTL0 = (OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A);

    // Enabling Chaining
    // Block A will be filled first
    *pCPSP0A = (unsigned int) TCB_gBlock_A - OFFSET + 3 ;

    //============================================================
    //
    // Configure SPORTs 1 &amp; 2 for output to DACs 1-4
    //
    //------------------------------------------------------------

    #ifdef DAC1
    *pSPCTL1 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC1
    *pCPSP1A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC2
    *pSPCTL1 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC2
    *pCPSP1B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC3
    *pSPCTL2 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC3
    *pCPSP2A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC4
    *pSPCTL2 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC4
    *pCPSP2B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif
}


// =======================================================
// init SRU
// =======================================================

void InitSRU(){

//-----------------------------------------------------------------------------
//
//  MCLK: The output of the 12.288 MHz xtal is either directly connected to the
//        codec, but also connected to DAI_P06, or just to DAI_P17. This is
//        determined by switch SW3 For this example we route the MCLK into
//        DAI_P17 and supply the clock to the ADC via DAI_P06  by routing the
//        signal through the SRU.

//  Tie the pin buffer input LOW.
    SRU(LOW,DAI_PB17_I);

//  Tie the pin buffer enable input LOW
    SRU(LOW,PBEN17_I);

//-----------------------------------------------------------------------------
//
//  Connect the ADC: The codec drives a BCLK output to DAI pin 7, a LRCLK
//          (a.k.a. frame sync) to DAI pin 8 and data to DAI pin 5.
//
//          Connect the ADC to SPORT0, using data input A
//
//          All three lines are always inputs to the SHARC so tie the pin
//          buffer inputs and pin buffer enable inputs all low.


//------------------------------------------------------------------------
//  Connect the ADC to SPORT0, using data input A

    //  Clock in on pin 7
    SRU(DAI_PB07_O,SPORT0_CLK_I);

    //  Frame sync in on pin 8
    SRU(DAI_PB08_O,SPORT0_FS_I);

    //  Data in on pin 5
    SRU(DAI_PB05_O,SPORT0_DA_I);

//------------------------------------------------------------------------
//    Tie the pin buffer inputs LOW for DAI pins 5, 7 and 8.  Even though
//    these pins are inputs to the SHARC, tying unused pin buffer inputs
//    LOW is &quot;good coding style&quot; to eliminate the possibility of
//    termination artifacts internal to the IC.  Note that signal
//    integrity is degraded only with a few specific SRU combinations.
//    In practice, this occurs VERY rarely, and these connections are
//    typically unnecessary.


    SRU(LOW,DAI_PB05_I);
    SRU(LOW,DAI_PB07_I);
    SRU(LOW,DAI_PB08_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs LOW for DAI pins 5, 6, 7 and 8 so
//  that they are always input pins.

    SRU(LOW,PBEN05_I);
    SRU(LOW,PBEN07_I);
    SRU(LOW,PBEN08_I);

//-----------------------------------------------------------------------------
//
//  Connect the DACs: The codec accepts a BCLK input from DAI pin 13 and
//          a LRCLK (a.k.a. frame sync) from DAI pin 14 and has four
//          serial data outputs to DAI pins 12, 11, 10 and 9
//
//          Connect DAC1 to SPORT1, using data output A
//          Connect DAC2 to SPORT1, using data output B
//          Connect DAC3 to SPORT2, using data output A
//          Connect DAC4 to SPORT2, using data output B
//
//          Connect the clock and frame sync inputs to SPORT1 and SPORT2
//          should come from the ADC on DAI pins 7 and 8, respectively
//
//          Connect the ADC BCLK and LRCLK back out to the DAC on DAI
//          pins 13 and 14, respectively.
//
//          All six DAC connections are always outputs from the SHARC
//          so tie the pin buffer enable inputs all high.
//

//------------------------------------------------------------------------
//  Connect the pin buffers to the SPORT data lines and ADC BCLK &amp; LRCLK

    SRU(SPORT2_DB_O,DAI_PB09_I);
    SRU(SPORT2_DA_O,DAI_PB10_I);
    SRU(SPORT1_DB_O,DAI_PB11_I);
    SRU(SPORT1_DA_O,DAI_PB12_I);

//------------------------------------------------------------------------
//  Connect the clock and frame sync input from the ADC directly
//    to the output pins driving the DACs.

    SRU(DAI_PB07_O,DAI_PB13_I);
    SRU(DAI_PB08_O,DAI_PB14_I);
    SRU(DAI_PB17_O,DAI_PB06_I);

//------------------------------------------------------------------------
//  Connect the SPORT clocks and frame syncs to the clock and
//  frame sync from the SPDIF receiver

    SRU(DAI_PB07_O,SPORT1_CLK_I);
    SRU(DAI_PB07_O,SPORT2_CLK_I);
    SRU(DAI_PB08_O,SPORT1_FS_I);
    SRU(DAI_PB08_O,SPORT2_FS_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs HIGH to make DAI pins 9-14 outputs.
    SRU(HIGH,PBEN06_I);
    SRU(HIGH,PBEN09_I);
    SRU(HIGH,PBEN10_I);
    SRU(HIGH,PBEN11_I);
    SRU(HIGH,PBEN12_I);
    SRU(HIGH,PBEN13_I);
    SRU(HIGH,PBEN14_I);
//--------------------------------------------------------------------------
// Route SPI signals to AD1835.

    SRU(SPI_MOSI_O,DPI_PB01_I)      //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I)     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I)      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG3_O, DPI_PB04_I)     //Connect SPI FLAG3 to DPI PB4.
//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peipherals to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG3_PBEN_O, DPI_PBEN04_I);

//-----------------------------------------------------------------------------



}

// =======================================================
// IRQ's
// =======================================================
void SetupIRQ01 ()
{
    //Enable the pins as IRQ0 and IRQ1
    *pSYSCTL|= IRQ0EN | IRQ1EN;
    asm (&quot;#include &lt;def21369.h&gt;&quot;) ;
    //Set the IRQ pins to be edge sensitive
    asm (&quot;bit set mode2 IRQ0E;&quot;) ;
    asm (&quot;bit set mode2 IRQ1E;&quot;) ;
}

void Irq0ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ0 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol -= 0x3F ;
    rightDAC4Vol -= 0x3F ;

    if (leftDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

void Irq1ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ1 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol += 0x3F ;
    rightDAC4Vol += 0x3F ;

    if (leftDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

// =======================================================
// SPORT IRQs
// =======================================================

    //Pointer to the blocks

unsigned int *gpProcessBuffer[3] = {gBlock_A,gBlock_C,gBlock_B};

// Counter to choose which buffer to process
volatile int gProcessBufferCounter=2;
// Semaphore to indicate to main that a block is ready for processing
volatile int gProcessBufferReady=0;

void TalkThroughISR(int sig_int)
{
    //Increment the block pointer
    gProcessBufferCounter++;
    gProcessBufferCounter %= 3;

    gProcessBufferReady = 1;
}

// =======================================================
// LED func
// =======================================================

void LEDSRUinit () {
	// Init LED Ports
	SRU(LOW,DPI_PB06_I);				// Connect GND to DPI_PB06 input (LED1)
	SRU(LOW,DPI_PB07_I);	    		// Connect GND to DPI_PB07 input (LED2)
	SRU(LOW,DPI_PB08_I);	    		// Connect GND to DPI_PB08 input (LED3)
	SRU(LOW,DPI_PB13_I);	    		// Connect GND to DPI_PB13 input (LED4)
	SRU(LOW,DPI_PB14_I);	    		// Connect GND to DPI_PB14 input (LED5)
	SRU(LOW,DAI_PB15_I);		  		// Connect GND to DAI_PB15 input (LED6)
	SRU(LOW,DAI_PB16_I);  				// Connect GND to DAI_PB16 input (LED7)

	//Enabling the Buffer using the following sequence: High -&gt; Output, Low -&gt; Input

	SRU(HIGH,DPI_PBEN06_I);				// LED 1
	SRU(HIGH,DPI_PBEN07_I);				// LED 2
	SRU(HIGH,DPI_PBEN08_I);				// LED 3
	SRU(HIGH,DPI_PBEN13_I);				// LED 4
	SRU(HIGH,DPI_PBEN14_I);				// LED 5
	SRU(HIGH,PBEN15_I);					// LED 6
	SRU(HIGH,PBEN16_I);					// LED 7
}

#define set_LED_1 SRU(HIGH,DPI_PB06_I)
#define set_LED_2 SRU(HIGH,DPI_PB07_I)
#define set_LED_3 SRU(HIGH,DPI_PB08_I)
#define set_LED_4 SRU(HIGH,DPI_PB13_I)
#define set_LED_5 SRU(HIGH,DPI_PB14_I)
#define set_LED_6 SRU(HIGH,DPI_PB15_I)
#define set_LED_7 SRU(HIGH,DPI_PB16_I)

#define clear_LED_1 SRU(LOW,DPI_PB06_I)
#define clear_LED_2 SRU(LOW,DPI_PB07_I)
#define clear_LED_3 SRU(LOW,DPI_PB08_I)
#define clear_LED_4 SRU(LOW,DPI_PB13_I)
#define clear_LED_5 SRU(LOW,DPI_PB14_I)
#define clear_LED_6 SRU(LOW,DPI_PB15_I)
#define clear_LED_7 SRU(LOW,DPI_PB16_I)


// =======================================================
// init HW
// =======================================================

void initHW() {

    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

    // init LEDs
    LEDSRUinit();
}

void startHW() {
    // Finally setup the sport to receive / transmit the data
    InitSPORT();
}


// =======================================================
// processing
// =======================================================


#ifndef INT24_MAX
	#define INT24_MIN (-16777215-1)
	#define INT24_MAX (16777215)
#endif

#define dAD1835_ChannelAmount (2)
#define dAD1835_leftChannelOffset (1)
#define dAD1835_rightChannelOffset (0)

#define dAD1835_ChannelFlag_left ('l')
#define dAD1835_ChannelFlag_right ('r')

// the adsp codec channel type
typedef struct SCodecChannel {
	unsigned int 	size;			//!&lt; size of the channel
	char			channelFlag;	//!&lt; l=left r=right channel
} TCodecChannel;

// the codec channel list
typedef struct SCodecChannelList {
	TCodecChannel *		pCC;
	int					number;
} TCodecChannelList;

// find the channel struct by a given channel
inline TCodecChannel * ADSP_getChannel (int channel) {
	extern TCodecChannelList gADSPcodecChannels;
	if ((channel &lt; 0) || (channel &gt;= gADSPcodecChannels.number)) return NULL;
	return &amp;gADSPcodecChannels.pCC[channel];
}

// wait for the sample frame
inline void ADSP_waitForSamples () {
	if (!gProcessBufferReady) {
		set_LED_1;
		while (!gProcessBufferReady) {

		};
		gProcessBufferReady = 0;
		clear_LED_1;
	}
}

// ADSP ADC 24Bit value format
// 011...11		+FS
// 0......0		0
// 111...11		-FS
//
// reads some samples from the input channel
void ADSP_readSamplesFromChannel (TCodecChannel * pIC, float * pBuffer, unsigned int amount) {
	// wait for new samples
	ADSP_waitForSamples ();

	// after that get the pointer to the buffer
	int * pBinSRC  = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pIC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}

//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBuffer = ((float) ((int)(*pBinSRC)&lt;&lt;8)) * (1.0/2147483648.0);
		pBuffer++;
		pBinSRC += dAD1835_ChannelAmount;
	}
}


// writes some samples to the output channel
void ADSP_writesSamplesToChannel (TCodecChannel * pOC, float * pBuffer, unsigned int amount) {
	int * pBinSRC = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	float tv;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pOC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}
//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBinSRC = ((int)(2147483648.0 * pBuffer[i]))&gt;&gt;8;
		pBinSRC += dAD1835_ChannelAmount;
	}
}

TCodecChannel gADSPcodecChannel []= {
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left},	// ADC left input
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left}	// DAC4 &amp; DAC3 left output
};

TCodecChannelList gADSPcodecChannels = {
		gADSPcodecChannel,
		sizeof(gADSPcodecChannel) / sizeof(TCodecChannel)
};
</Code><Code idCode="125">// ===============================
// AP uuid = 5
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="126">void main(void)
{

    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

    // Finally setup the sport to receive / transmit the data
    InitSPORT();

    // Be in infinite loop and do nothing until done.
/*    for(;;)
    {
     while(blockReady)
          processBlock(src_pointer[int_cntr]);
    }
*/
	#define dfBufferL (256)
    float fBuffer[dfBufferL];

    TCodecChannel iC = {0,NUM_SAMPLES};
    TCodecChannel oC = {0,NUM_SAMPLES};

    for (;;) {
    	readSamplesFromChannel(&amp;iC,fBuffer,dfBufferL);
    	writesSamplesFromChannel(&amp;oC,fBuffer,dfBufferL);
    	clear_LED(1);
    }
}
</Code><Code idCode="127">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPvarRational * pR = pParams[1].fp_pD;

	TCodecChannel * pC;
	
	// the channels at the AP starts with 1; at the ADSP with 0
	pC = ADSP_getChannel((int)pParams[0].fp_integer-1);
	if (!pC) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}

	ADSP_readSamplesFromChannel(pC,pR-&gt;pR,pR-&gt;num);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="128">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="129">// ===============================
// function implementation for convoluteVectorBiquad(var id = 111)
// description: convolute biquad with a vector of inputs and generate an output vector
// ===============================

void HALfunc_ID111_convoluteVectorBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPInterpreterVariable ** px = &amp;( pParams[0].fp_pV);
// parameter bqa descr: biquad array
	TAPInterpreterVariable ** pbqa = &amp;( pParams[1].fp_pV);
// parameter y descr: output
	TAPInterpreterVariable ** py = &amp;( pParams[2].fp_pV);
};
</Code><Code idCode="130">// ===============================
// function implementation for shiftVectorDelay(var id = 151)
// description: shifts a vector into a delay and the content of the delay to a vector
// ===============================

void HALfunc_ID151_shiftVectorDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPInterpreterVariable ** px = &amp;( pParams[0].fp_pV);
// parameter delay descr: the delay
	TAPInterpreterVariable ** pdelay = &amp;( pParams[1].fp_pV);
// parameter y descr: output
	TAPInterpreterVariable ** py = &amp;( pParams[2].fp_pV);
};
</Code><Code idCode="131">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="132">// ===============================
// AP uuid = 6
// ===============================

#define WAVsampleCache (65536)

// the wav modul global var
TStjWAVmodule gWAVModule;


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system

	// init wav module
	TStjWAVOpenInfo wavIOs[] = {
			{1,&quot;input.wav&quot;,1,44100,0,WAVsampleCache},
			{2,&quot;bypass.wav&quot;,0,44100,0,WAVsampleCache},
			{3,&quot;subbass.wav&quot;,0,44100,0,WAVsampleCache},
			{4,&quot;lowerVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{5,&quot;upperVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{6,&quot;harmonics.wav&quot;,0,44100,0,WAVsampleCache},
	};

	if (WAVmoduleInit (sizeof(wavIOs) / sizeof(TStjWAVOpenInfo),wavIOs,&amp;gWAVModule)) {
		return -2;
	}

	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close wav module
	WAVmoduleExit(&amp;gWAVModule);

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="133">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="134">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

#ifndef dAPuseExternalAPCode
// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif

#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

#ifndef dAPuseExternalAPCode
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#else
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifndef dAPuseExternalAPCode
	free (varL);
	free (instrL);
#endif

#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="135">// ===============================
// AP uuid = 7
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	

	initHW();

	startHW();

	// login the ap to the message system

	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="136">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter resValue descr: the result of the action
	void ** presValue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="137">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPvarRational * pR = pParams[1].fp_pD;

	TCodecChannel * pC;

	// the channels at the AP starts with 1; at the ADSP with 0
	pC = ADSP_getChannel((int)pParams[0].fp_integer-1);
	if (!pC) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}

	ADSP_writesSamplesToChannel(pC,pR-&gt;pR,pR-&gt;num);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="138">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="139">// ===============================
// function implementation for convoluteVectorBiquad(var id = 111)
// description: convolute biquad with a vector of inputs and generate an output vector
// ===============================

void HALfunc_ID111_convoluteVectorBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPvarRational * pxA = (TAPvarRational *) pParams[0].fp_pD;
// parameter bqa descr: biquad array
	TAPvarBiquad * pbqa = (TAPvarBiquad *) pParams[1].fp_pD;
// parameter y descr: output
	TAPvarRational * pyA = (TAPvarRational *) pParams[2].fp_pD;

	float * px;
	float * py;
	int i, j, imax, jmax;
	float d1, y;
	TAPBiquadDF2 * pF;

	py = pyA-&gt;pR;
	px = pxA-&gt;pR;
	imax = pxA-&gt;num;
	jmax = pbqa-&gt;num;

	for (i = 0; i &lt; imax; i++) {
		y = *px;
		pF = pbqa-&gt;pB;
		for (j = 0; j &lt; jmax; j++) {
			// filter
			d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + y); // y = x
			y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
			y *= pF-&gt;k;

			pF-&gt;s2 = pF-&gt;s1;
			pF-&gt;s1 = d1;
			// output is input for the next filter
			pF++;
		}

		// save result to the output
		*py = y;
		px++;
		py++;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="140">// ############################################
// block based processing without overlapped operations
// ############################################

#define dStjFrameWAVinitialFrameAmount (1024)

typedef struct SStjFrameWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input

	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)
} TStjFrameWAVOpenInfo;

typedef struct SStjFrameWAVFile {
	unsigned int	channel;				//!&lt; the channel
	SNDFILE *		pSndF;					//!&lt; the file
	unsigned int	isInput;				//!&lt; if 0 the channel is an input channel


	float *			pFrameBuffer;			//!&lt; the buffer witch is filled with the frames
	int				fileChannels;			//!&lt; the amount of sample channels at the file
	int				activeChannel;			//!&lt; the channel used to read
	int				frameAmount;			//!&lt; amount of frame
} TStjFrameWAVFile;

typedef struct SStjFrameWAVmodule {
	TStjFrameWAVFile *	pChannels;
	unsigned int		number;
} TStjFrameWAVmodule;

//! close the set of wav files
void FrameWAVmoduleExit (TStjFrameWAVmodule * pM);

//! initis a set of wav files for writing / reading
int FrameWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	);

//! looking for the right channel
TStjFrameWAVFile * FrameWAVmoduleFindChannel (
		TStjFrameWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
	);

//! reads a sample from a channel
int FrameWAVmoduleGetInput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be read
		float *					pFrame			//!&lt;(out) pointer to the sample buffer witch is filled
	);

//! writes a sample to an output
int FrameWAVmoduleSetOutput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be write
		float *					pFrame			//!&lt;(in) pointer to the sample buffer witch is filled
	);

//! close the set of wav files
void FrameWAVmoduleExit (TStjFrameWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjFrameWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		sf_close(pWF-&gt;pSndF);
		if (pWF-&gt;pFrameBuffer) free (pWF-&gt;pFrameBuffer);
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int FrameWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjFrameWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjFrameWAVFile) * number);
	pModul-&gt;number = number;

	int 				i;
	SF_INFO 			info;
	TStjFrameWAVFile * 	pWF = pModul-&gt;pChannels;

	for (i = 0;i &lt; number;i++) {
		// open sndfile interface
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info);
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info);
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;


		if (pWAVFiles[i].isInput) {
			pWF-&gt;pFrameBuffer = malloc (sizeof(float)*info.channels*dStjFrameWAVinitialFrameAmount);
			if (!pWF-&gt;pFrameBuffer) {
				goto error;
			}
			pWF-&gt;frameAmount = dStjFrameWAVinitialFrameAmount;
		}

		// the file channel starts at 1 - here we start at 0
		pWF-&gt;activeChannel = pWAVFiles[i].fileChannelNumber - 1;
		pWF-&gt;fileChannels = (int) info.channels;

		pWF++;
	}
	return 0;
error:
	FrameWAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjFrameWAVFile * FrameWAVmoduleFindChannel (
		TStjFrameWAVmodule *	pM,		//!&lt; the module
		int						channel	//!&lt; channel to search for
		) {
	TStjFrameWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int FrameWAVmoduleGetInput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be read
		float *					pFrame			//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjFrameWAVFile * pWF = FrameWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}

	// check the temp buffer size
	if (pWF-&gt;frameAmount &lt; sampleNumber) {
		pWF-&gt;pFrameBuffer = realloc(pWF-&gt;pFrameBuffer,sizeof(float)*pWF-&gt;fileChannels*sampleNumber);
		if (!pWF-&gt;pFrameBuffer) {
			return -3;
		}
		pWF-&gt;frameAmount = sampleNumber;
	}

	// fill the buffer
	int am = (int) sf_readf_float (pWF-&gt;pSndF,pWF-&gt;pFrameBuffer, sampleNumber);

	if (am &lt;= 0) {
		return -4;
	}

	// copy buffer
	int i;
	float * pD = pFrame;
	float * pS = pWF-&gt;pFrameBuffer;
	// add the offset so we start at the right pos at the frame
	pS += pWF-&gt;activeChannel;
	for (i = 0; i &lt; am; i++) {
		*pD = *pS;
		pD++;
		pS+= pWF-&gt;fileChannels;
	}
	// and fill the rest with 0.
	for (;i &lt; sampleNumber; i++) {
		*pD = 0.0f;
		pD++;
	}
	return 0;
}

//! writes a sample to an output
int FrameWAVmoduleSetOutput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be write
		float *					pFrame			//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjFrameWAVFile * pWF = FrameWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// the last samples at the frame are new
	if (sampleNumber != sf_write_float (pWF-&gt;pSndF,pFrame, sampleNumber)) return -3;
	return 0;
}
</Code><Code idCode="141">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer witch receives the samples
	TAPvarRational * pRA = (TAPvarRational *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleGetInput(&amp;gFrameWAVModule,(int)channel,pRA-&gt;num,pRA-&gt;pR)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="142">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	TAPvarRational * pRA = (TAPvarRational *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleSetOutput(&amp;gFrameWAVModule,(int)channel,pRA-&gt;num,pRA-&gt;pR)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="143">// ===============================
// AP uuid = 8
// ===============================

// the global var for the Frame WAV modul
TStjFrameWAVmodule gFrameWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;x.wav&quot;,1,48000,1},
			{2,&quot;y.wav&quot;,0,48000,1}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	// closes the wav frame modul
	FrameWAVmoduleExit(&amp;gFrameWAVModule);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="144">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="145">// ==============================
// MSP STK defines
// ==============================

#define MSP430F169

#include &lt;msp430f169.h&gt;
#include &lt;signal.h&gt;

#define   LED1_ON         P3OUT &amp;= ~BIT6
#define   LED1_OFF        P3OUT |= BIT6
#define   LED2_ON         P3OUT &amp;= ~BIT7
#define   LED2_OFF        P3OUT |= BIT7
#define   B1              BIT5&amp;P1IN         //B1 - P1.5
#define   B2              BIT6&amp;P1IN         //B2 - P1.6
#define   B3              BIT7&amp;P1IN         //B3 - P1.7
#define   E_HIGH          P4OUT |= BIT1
#define   E_LOW           P4OUT &amp;= ~BIT1
#define   RS_HIGH         P4OUT |= BIT3
#define   RS_LOW          P4OUT &amp;= ~BIT3
#define   LCD_Data        P4OUT
#define   LCD_LIGHT_ON    P4OUT |= BIT0
#define   LCD_LIGHT_OFF   P4OUT &amp;= ~BIT0

#define   INPUT           0
#define   OUTPUT          0xff
#define   ON              1
#define   OFF             0
#define   BUF_SIZE        25
#define   TEST_WRITE_BUF  255                   // only for testing flash
#define   TEST_READ_BUF   255                   // only for testing flash

#define   _100us          90                    // measured value (previous value == 7)
#define   MIDI_CYCLE      26                    // measured value for 32us
#define   MOD_SEQ_END     10                    // LF (line feed) for finishing MOD-MP3-X commands
#define   STOP            67
#define   _9600           94

//LCD commands
#define		DISP_ON			0x0c	 //LCD control constants
#define		DISP_OFF		0x08	 //
#define		CLR_DISP		0x01     //
#define		CUR_HOME		0x02	 //
#define		ENTRY_INC		0x06     //
#define		DD_RAM_ADDR		0x80	 //
#define		DD_RAM_ADDR2		0xc0	 //
#define		DD_RAM_ADDR3		0x28	 //
#define		CG_RAM_ADDR		0x40	 //

//NAND FLASH
#define MAX_BLOCK_NUMB		1024

#define TRANS_LDY 		50
#define WRITE_DLY		400
#define ERASE_DLY		4000

#define OUT_PORT		P5OUT
#define IN_PORT		    P5IN
#define IO_DIR			P5DIR

#define _CE_ON			P2OUT &amp;= ~BIT0
#define _CE_OFF			P2OUT |= BIT0
#define _RE_ON			P2OUT &amp;= ~BIT1
#define _RE_OFF			P2OUT |= BIT1
#define _WE_ON			P2OUT &amp;= ~BIT2
#define _WE_OFF			P2OUT |= BIT2

#define ALE_ON			P2OUT |= BIT3
#define ALE_OFF			P2OUT &amp;= ~BIT3
#define CLE_ON			P2OUT |= BIT4
#define CLE_OFF			P2OUT &amp;= ~BIT4

#define R_B                     P2IN &amp; BIT7
#define DALLAS                  P2IN &amp; BIT5

#define READ_SPARE			0x50
#define READ_0				0x00
#define READ_1				0x01
#define READ_STATUS			0x70

#define WRITE_PAGE			0x80
#define WRITE_AKN			0x10

#define ERASE_BLOCK			0x60
#define	ERASE_AKN			0xD0

#define DEV_ID				0x90

#define SAMSUNG_ID			0xECE6

// ==============================
// helper
// ==============================

#define dHIBYTE(x)   ((unsigned int)(x) &gt;&gt; 8)
#define dLOWBYTE(x)  ((unsigned char)(x))

// ==============================
// defines for the FLASH chip at the board
// ==============================


#define IN_LOG_ADDRESS_RANGE(x) ((x) &lt;= (1024*16*512))
#define dFLASH_PageSize 		(512)
#define dFLASH_HalfPageSize		(256)
#define dFLASH_2ndPageMask		(0xFF00)
#define dFLASH_NumOfBlocks		(1024)

#define dFLASH_READ_A			0x00
#define dFLASH_READ_B			0x01


enum eFLASH_areaFlags {
	eFLASH_areaFlag_A = dFLASH_READ_A,	// 0.. 255
	eFLASH_areaFlag_B = dFLASH_READ_B,	// 256 .. 511
	eFLASH_areaFlag_C = 2	// 512 .. 528
};

typedef struct SFLASH_address {
	uint16_t		ofs;
	uint16_t		page;
} TFLASH_address;

// type for logical addresses
typedef uint32_t TFLASH_logicalAddress;

typedef struct SFLASH_programVars {
	unsigned int	i; 		// count var
	unsigned int	imax;	// max value to reach number or end of page
	unsigned int	page;
	unsigned char	col;
	unsigned char	rowL;
	unsigned char	rowH;
	unsigned char	AF; 	// area function to set pointer
	unsigned char	r; 		// status value
}TFLASH_programVars;

typedef struct SFLASH_SongLUTdata {
	unsigned char	col;
	unsigned char	rowL;
	unsigned char	rowH;
	unsigned char	AF;
	unsigned int	imax;
	unsigned int	page;
} TFLASH_SongLUTdata;


// translate logical address to physical address
void FLASH_translateAdress (
		TFLASH_logicalAddress	logAddress,
		TFLASH_address *		pPhysAddress
		);


void FLASH_transl (
		TFLASH_address *pPA,
		uint8_t * 		pCol,
		uint8_t *		pAddrL,
		uint8_t *		pAddrH,
		uint8_t *		pAF
		);

// initialize global vars for first using
void init_TFLASH_programVars(TFLASH_programVars * pProgVars);

// erase flash
void FLASH_eraseAll();

// reads bytes from an address
void FLASH_readData (
		TFLASH_logicalAddress 	lA,		//!&lt; logical address
		unsigned char *			pB,		//!&lt; buffer to be filled
		unsigned int			Number	//!&lt; number of bytes to be read
	);

// writes bytes to an address
unsigned char FLASH_writeData (
		TFLASH_logicalAddress 	lA,		//!&lt; logical address
		unsigned char *			pB,		//!&lt; buffer to be read
		unsigned int			Number	//!&lt; number of bytes to be written
	);

// reads bytes from physical FLASH_address given in LUT
void FLASH_readData_with_FLASH_address (
		TFLASH_SongLUTdata	*	lut,	//!&lt; physical address
		unsigned char *			pB,		//!&lt; buffer to be filled
		unsigned int			Number	//!&lt; number of bytes to be read
	);



// ==============================
// STK API
// ==============================

// declare LCD functions
void _E(void);
void LCD_sendChar (unsigned char d);
void LCD_sendCmd (unsigned char e);
void InitLCD(void);

// hardware UART
void InitUSART0(void);
void MOD_UART_transmit_c (uint8_t c);
void MOD_UART_transmit_str (const unsigned char str []);

// initialize MSP430
void InitHW (void)
{
    WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer

    DCOCTL = 0x00;  // reset DCO control register
    DCOCTL |= BIT7 + BIT6 + BIT5 + BIT4; // setting maximum frequency of RSEL range

    BCSCTL1 &amp;= ~BIT7; //XT2-ON
    BCSCTL1 |= BIT2 + BIT1 + BIT0; // RSEL set to maximum
    BCSCTL2 |= BIT3;                 //XT2 is SMCLK
    BCSCTL2 &amp;= ~BIT7 + ~BIT6 + ~BIT5 + ~BIT4; // intern DCO for MCLK and divide CLK by 1

    //hardware ini

    P1DIR=0x0F;               //P1.0..P1.3 -&gt; output, P1.4, B1..B3 -&gt; input


    P2OUT=0x07;               //NAND FLASH ini
    P2DIR=0x1F;

    P3OUT = BIT6 | BIT7;      //LED1
    P3DIR = BIT6 | BIT7;      //LED2

    P4OUT = 0;                //LCD ini
    P4DIR = 0xff;

    InitLCD();
    InitUSART0();

}

//-----------------Delay--------------------------------------------------------
void Delay (unsigned int a)
{
  unsigned char k;
  for (k=0 ; k != a; ++k);                      //20+a*12 cycles (for 1MHz)
}

void Delayx100us(unsigned int b)
{
  unsigned int j;
  for (j=0; j!=b; ++j) Delay (_100us);
}

//-----------------LCD functions------------------------------------------------
void _E(void)
{
        E_HIGH;		    //toggle E for LCD
	_NOP();
	_NOP();
	E_LOW;
}

void LCD_sendChar (unsigned char d)
{
        unsigned char temp; // added by myself -&gt; in previous version var is declared as a global one
	Delayx100us(5);                 //.5ms
	temp = d &amp; 0xf0;		//get upper nibble
	LCD_Data &amp;= 0x0f;
	LCD_Data |= temp;
	RS_HIGH;        	        //set LCD to data mode
	_E();                           //toggle E for LCD
	temp = d &amp; 0x0f;
	temp = temp &lt;&lt; 4;               //get down nibble
	LCD_Data &amp;= 0x0f;
	LCD_Data |= temp;
	RS_HIGH;   	                //set LCD to data mode
	_E();                           //toggle E for LCD
}

void LCD_sendCmd (unsigned char e)
{
        unsigned char temp; // added by myself -&gt; in previous version var is declared as a global one
	Delayx100us(100);                //10ms //previous 10
	temp = e &amp; 0xf0;		//get upper nibble
	LCD_Data &amp;= 0x0f;
	LCD_Data |= temp;               //send CMD to LCD
	RS_LOW;     	                //set LCD to CMD mode
	_E();                           //toggle E for LCD
	temp = e &amp; 0x0f;
	temp = temp &lt;&lt; 4;               //get down nibble
	LCD_Data &amp;= 0x0f;
	LCD_Data |= temp;
	RS_LOW;            	        //set LCD to CMD mode
	_E();                           //toggle E for LCD
}

void  Write_LCD_line (const char *text, unsigned char numSigns)// void  Write_LCD_line (unsigned char text[], unsigned char numSigns)
{
  unsigned char i; // added by myself -&gt; in previous version var is declared as a global one

  Delayx100us(15);
  for (i=0; i!=16; i++)
  {
    (i &lt; numSigns) ? LCD_sendChar(text[i]) : LCD_sendChar(' ');
  }
}


// writes a string to the LCD
void  LCD_print (const char *	pStr) {
	int 			i = 0;
	const char *	pC = pStr;

	LCD_sendCmd(CLR_DISP);
	Delayx100us(100); // wait for the LCD to process
	while (i &lt; 16) {
		LCD_sendChar(*pC);
		i++;
		pC++;
		if (!(*pC)) break;
	}

	for (;i &lt; 16; i++) {
		LCD_sendChar(' ');
	}
}



void InitLCD(void)
{
    RS_LOW;
    Delayx100us(250);                   //Delay 100ms
    Delayx100us(250);
    Delayx100us(250);
    Delayx100us(250);
    LCD_Data |= BIT4 | BIT5;            //D7-D4 = 0011
    LCD_Data &amp;= ~BIT6 &amp; ~BIT7;
    _E();                               //toggle E for LCD
    Delayx100us(100);                   //10ms
    _E();                               //toggle E for LCD
    Delayx100us(100);                   //10ms
    _E();                               //toggle E for LCD
    Delayx100us(100);                   //10ms
    LCD_Data &amp;= ~BIT4;                  //D7-D4 = 0010
    _E();                               //toggle E for LCD

    LCD_sendCmd(DISP_ON);
    LCD_sendCmd(CLR_DISP);
    LCD_sendCmd(DD_RAM_ADDR);
    LCD_LIGHT_ON;
}

//-----------------USART for PC connection--------------------------------------
void InitUSART0(void)
{
    UCTL0 = CHAR;                         // 8-bit character

    UTCTL0 = SSEL1;                       // UCLK = XT2
    UBR00 = 0x41;                         // 8 000 000/9600 -&gt; low byte
    UBR10 = 0x03;                         // 8 000 000/9600 -&gt; high byte
    UMCTL0 = 0x0;


    ME1 |= UTXE0 + URXE0;                 // Enabled USART0 TXD/RXD
    IE1 |= URXIE0;                        // Enabled USART0 RX interrupt
    P3SEL |= 0x30;                        // P3.4 = USART0 TXD, P3.5 = USART0 RXD
    P3DIR |= 0x10;                        // P3.4 output direction
    _EINT();                              // Enable interrupts
}
#pragma vector=UART0RX_VECTOR
__interrupt void usart0_rx (void)
// interrupt (UART0RX_VECTOR) usart0_rx(void)
{
  unsigned char t;
  _NOP();
  while ((IFG1 &amp; UTXIFG0) == 0);           // USART0 TX buffer ready?
  t=RXBUF0;
  // disable buttons
  P1DIR=0xEF; //only P1.4 -&gt; input
  // handle received data byte
  UART_RXhandler(t);
}

//-----------------Software UART for MIDI and MOD-MP3-X-------------------------

void UART_transmit (unsigned char Transmit_Data)              //UART1 Transmit Subroutine
{
  //i=i;
  while ((IFG1 &amp; UTXIFG0) == 0);            //USART0 TX buffer ready?
  TXBUF0 = Transmit_Data;                   //send data
}
void MOD_UART_transmit_c (uint8_t c)
{
  uint16_t tx = c;
  tx |= 0x100;
  tx = tx &lt;&lt; 1;
  unsigned char i;
  for (i=0; i != 10; i++)
  {
    if (tx &amp; 0x01)
    {
      P1OUT |= BIT3;
      tx = tx &gt;&gt; 1;
      Delay (_9600);
    }
    else
    {
      P1OUT &amp;= ~BIT3;
      tx = tx &gt;&gt; 1;
      Delay (_9600);
    }
  }
}

void MOD_UART_transmit_str (const unsigned char str [])
{
  uint16_t i = 0;
  uint8_t c;
  while (str[i] != 0x0A)
  {
    c = str[i];
    MOD_UART_transmit_c (c);
    i++;
  }
  MOD_UART_transmit_c (MOD_SEQ_END);
}

void MIDI_UART_transmit_c (uint8_t c)
{
  uint16_t tx = c;
  tx |= 0x100;
  tx = tx &lt;&lt; 1;
  unsigned char i;
  for (i=0; i != 10; i++)
  {
    if (tx &amp; 0x01)
    {
      P1OUT |= BIT0;
      tx = tx &gt;&gt; 1;
      Delay (MIDI_CYCLE);
    }
    else
    {
      P1OUT &amp;= ~BIT0;
      tx = tx &gt;&gt; 1;
      Delay (MIDI_CYCLE);
    }
  }
}

void MIDI_UART_transmit_str (const unsigned char str [])
{
  uint16_t i = 0;
  uint8_t c;
  while (str[i] != 0x0A)
  {
    c = str[i];
    MIDI_UART_transmit_c (c);
    i++;
  }
}

// ==============================
// FLASH functions
// ==============================

void FLASH_transl (
		TFLASH_address *pPA,
		uint8_t * 		pCol,
		uint8_t *		pAddrL,
		uint8_t *		pAddrH,
		uint8_t *		pAF
		) {
	*pAddrL = dLOWBYTE(pPA-&gt;page);
	*pAddrH = dHIBYTE(pPA-&gt;page);

	if (pPA-&gt;ofs &amp; dFLASH_2ndPageMask) {
		*pCol = (uint8_t)((uint16_t)pPA-&gt;ofs % dFLASH_HalfPageSize);
		*pAF = eFLASH_areaFlag_B;
	} else {
		*pCol = (uint8_t)pPA-&gt;ofs;
		*pAF = eFLASH_areaFlag_A;
	}
}
// translate logical address to physical address
void FLASH_translateAdress (
		TFLASH_logicalAddress	logAddress,
		TFLASH_address *		pPhysAddress
		) {
	uint16_t page;
	uint16_t ofs;
	page = (uint16_t) (logAddress / dFLASH_PageSize);
	ofs = (uint16_t) (logAddress - page * dFLASH_PageSize);
	pPhysAddress-&gt;page = page;
	pPhysAddress-&gt;ofs = ofs;
}

// ============================================================
// external functions
// ============================================================
void FLASH_CommandLatchCycle (uint8_t com){

	// std. state

	CLE_OFF;
//	_CE_OFF;
//	ALE_ON;
	_WE_OFF;
	IO_DIR = OUTPUT;        // GPIOs(P5) as output

	// set cmd
	OUT_PORT = com;

	CLE_ON;
	_CE_ON;
	ALE_OFF;
        // wait tCLS=0, tCS=0, tALS=0
	_WE_ON;
	// wait twp = 25ns
	asm(&quot;nop;&quot;); // = 125ns
	_WE_OFF;
	// wait tclh=10ns,tch=10ns talh=10ns
	asm(&quot;nop;&quot;); // = 125ns
//	ALE_ON;
//	_CE_OFF;
	CLE_OFF;
}
void FLASH_AddressLatchCycle (
		uint8_t col,
		uint8_t rowL,
		uint8_t rowH
	){
	// std. state

//	CLE_ON;
//	_CE_OFF;
	_WE_OFF; // redundant after CommandLatchCycle
	ALE_OFF;
	IO_DIR = OUTPUT;        // GPIOs(P5) as output

	_CE_ON;
	CLE_OFF;
	ALE_ON;

	// wait tALS=0ns, tCLS = 0ns

	// set col
	OUT_PORT = col;
	_WE_ON;
	// wait tds=20ns
	asm(&quot;nop;&quot;); // = 125ns
	_WE_OFF;
	// wait tdh=10ns
	asm(&quot;nop;&quot;); // = 125ns

	// set rowL
	OUT_PORT = rowL;
	_WE_ON;
	// wait tds=20ns
	asm(&quot;nop;&quot;); // = 125ns
	_WE_OFF;
	// wait tdh=10ns
	asm(&quot;nop;&quot;); // = 125ns

	// set rowH
	OUT_PORT = rowH;
	_WE_ON;
	// wait tds=20ns
	asm(&quot;nop;&quot;); // = 125ns
	_WE_OFF;
	// wait tdh=10ns, tALH = 10ns
	asm(&quot;nop;&quot;); // = 125ns

	ALE_OFF;

}
// delete flash
unsigned char FLASH_eraseBlock (unsigned char BLOCK_ADDL, unsigned char BLOCK_ADDH)
{
    unsigned char m;
    // set the initial state
    CLE_OFF;
    _CE_OFF;
    _WE_OFF;
    ALE_OFF;
    _RE_OFF;
    IO_DIR = OUTPUT;
    // start erasing
    CLE_ON;
    _CE_ON;
	_WE_ON;
    OUT_PORT = ERASE_BLOCK;
	_WE_OFF;
	// wait tWC=50ns
	asm(&quot;nop;&quot;); // = 125ns
	CLE_OFF;
	// writing address
    ALE_ON;
    _WE_ON;
    OUT_PORT = BLOCK_ADDL;
    _WE_OFF;
	// wait tWC=50ns
	asm(&quot;nop;&quot;); // = 125ns
    _WE_ON;
    OUT_PORT = BLOCK_ADDH;
    _WE_OFF;
    ALE_OFF;
    // erase operation
    CLE_ON;
    _WE_ON;
    OUT_PORT = ERASE_AKN;
    _WE_OFF;
    CLE_OFF;
    // wait for finishing
    while ((R_B) == 0);
    CLE_ON;
    _WE_ON;
    OUT_PORT = READ_STATUS;
    _WE_OFF;
    CLE_OFF;
    IO_DIR = INPUT;
    _RE_ON;
    m = IN_PORT;
    _RE_OFF;
    CLE_ON;
    _CE_OFF;
    ALE_ON;
    return (m);
}

void FLASH_eraseAll(){
	uint16_t bc;

	for (bc = 0; bc &lt; dFLASH_NumOfBlocks; bc += 16) {
		FLASH_eraseBlock(dLOWBYTE(bc),dHIBYTE(bc));
	}
}


// reads bytes from an address
void FLASH_readData (
		TFLASH_logicalAddress 	lA,		//!&lt; logical address
		unsigned char *			pB,		//!&lt; buffer to be filled
		unsigned int			Number	//!&lt; number of bytes to be read
	)
{

	TFLASH_programVars 		vars;
	TFLASH_address 			FA;

	FLASH_translateAdress(lA,&amp;FA);


	vars.page = FA.page;
	vars.imax = ((FA.ofs + Number) &gt; dFLASH_PageSize) ? (dFLASH_PageSize - FA.ofs) : Number;
	FLASH_transl (
			&amp;FA,
			&amp;vars.col,
			&amp;vars.rowL,
			&amp;vars.rowH,
			&amp;vars.AF
		);

	for (;;) {
		// std. setup
		CLE_OFF;
		_CE_OFF;
		_WE_OFF;
		ALE_ON;
		_RE_OFF;
		IO_DIR = OUTPUT;

		_CE_ON;
		// set page
		ALE_OFF;
		CLE_ON;
		OUT_PORT = vars.AF;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		// set col
		ALE_ON;
		CLE_OFF;

		OUT_PORT = vars.col;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		OUT_PORT = vars.rowL;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		OUT_PORT = vars.rowH;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		ALE_OFF;
		// wait
		IO_DIR = INPUT;
		while (0 == (R_B)) asm(&quot;nop;&quot;);

		_RE_ON;
		asm(&quot;nop;&quot;);

		for (vars.i = 0; vars.i &lt; vars.imax; vars.i++) {
			_RE_OFF;             // /RE Read Enable = 0 =&gt; on (Data is valid after falling edge of /RE which also increments the internalcolumn address counter)
			*pB = IN_PORT;        // P5IN to unsigned char
			_RE_ON;          	// reset /RE
			pB++;
		}
		_CE_OFF;
		asm(&quot;nop;&quot;); // tCEH = 100ns
		Number -= vars.imax;
		if (!Number) goto readExit;

		vars.imax = (Number &gt; dFLASH_PageSize) ? dFLASH_PageSize : Number;

		vars.AF = eFLASH_areaFlag_A;
		vars.col = 0;
		vars.page++;
		vars.rowL = dLOWBYTE(vars.page);
		vars.rowH = dHIBYTE(vars.page);
	}
readExit: return;
}



// writes bytes to an address
unsigned char FLASH_writeData (
		TFLASH_logicalAddress 	lA,		//!&lt; logical address
		unsigned char *			pB,		//!&lt; buffer to be read
		unsigned int			Number	//!&lt; number of bytes to be written
	)
{
	TFLASH_programVars 		vars;
	TFLASH_address 			FA;
	uint8_t 				r;

	FLASH_translateAdress(lA,&amp;FA);


	vars.page = FA.page;
	vars.imax = ((FA.ofs + Number) &gt; dFLASH_PageSize) ? (dFLASH_PageSize - FA.ofs) : Number;
	FLASH_transl (
			&amp;FA,
			&amp;vars.col,
			&amp;vars.rowL,
			&amp;vars.rowH,
			&amp;vars.AF
		);
	// set pointer to area
	// std. state
	CLE_OFF;
	_CE_OFF;
	_WE_OFF;
	ALE_OFF;
	_RE_OFF;
	IO_DIR = OUTPUT;
	while (Number) {
		// set pointer to area
		_CE_ON;
		CLE_ON;
		_WE_ON;
		OUT_PORT = vars.AF;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);
		_WE_ON;
		OUT_PORT = WRITE_PAGE;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);
		CLE_OFF;
		ALE_ON;
		_WE_ON;
		OUT_PORT = vars.col;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);
		_WE_ON;
		OUT_PORT = vars.rowL;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);
		_WE_ON;
		OUT_PORT = vars.rowH;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);
		ALE_OFF;

		for (vars.i = 0; vars.i &lt; vars.imax; vars.i++) {
			_WE_ON;
			OUT_PORT = *pB;
			asm(&quot;nop;&quot;);
			_WE_OFF;
			asm(&quot;nop;&quot;);
			pB++;
		}

		CLE_ON;
		_WE_ON;
		OUT_PORT = WRITE_AKN;
		_WE_OFF;
		CLE_OFF;
		// wait for finishing
		while (0 == (R_B)) asm(&quot;nop;&quot;);
		CLE_ON;
		_WE_ON;
		OUT_PORT = READ_STATUS;
		_WE_OFF;
		CLE_OFF;
		IO_DIR = INPUT;
		_RE_ON;
		r = IN_PORT;
		_RE_OFF;
		_CE_OFF;
		r &amp;= 1;
		if (r) goto error;

		Number -= vars.imax;



		vars.imax = (Number &gt; dFLASH_PageSize) ? dFLASH_PageSize : Number;


		vars.AF = eFLASH_areaFlag_A;
		vars.col = 0;
		vars.page++;
		vars.rowL = dLOWBYTE(vars.page);
		vars.rowH = dHIBYTE(vars.page);
	}
	return 0;
error:
	return 1;
}

// reads bytes from physical FLASH_address given in LUT
void FLASH_readData_with_FLASH_address (
		TFLASH_SongLUTdata	*	lut,	//!&lt; physical address
		unsigned char *			pB,		//!&lt; buffer to be filled
		unsigned int			Number	//!&lt; number of bytes to be read
	)
{

	TFLASH_programVars 		vars;

	vars.col = lut-&gt;col;
	vars.rowL = lut-&gt;rowL;
	vars.rowH = lut-&gt;rowH;
	vars.AF = lut-&gt;AF;
	vars.imax = lut-&gt;imax;
	vars.page = lut-&gt;page;

	for (;;) {
		// std. setup
		CLE_OFF;
		_CE_OFF;
		_WE_OFF;
		ALE_ON;
		_RE_OFF;
		IO_DIR = OUTPUT;

		_CE_ON;
		// set page
		ALE_OFF;
		CLE_ON;
		OUT_PORT = vars.AF;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		// set col
		ALE_ON;
		CLE_OFF;

		OUT_PORT = vars.col;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		OUT_PORT = vars.rowL;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		OUT_PORT = vars.rowH;
		_WE_ON;
		asm(&quot;nop;&quot;);
		_WE_OFF;
		asm(&quot;nop;&quot;);

		ALE_OFF;
		// wait
		IO_DIR = INPUT;
		while (0 == (R_B)) asm(&quot;nop;&quot;);

		_RE_ON;
		asm(&quot;nop;&quot;);

		for (vars.i = 0; vars.i &lt; vars.imax; vars.i++) {
			_RE_OFF;             // /RE Read Enable = 0 =&gt; on (Data is valid after falling edge of /RE which also increments the internalcolumn address counter)
			*pB = IN_PORT;        // P5IN to unsigned char
			_RE_ON;          	// reset /RE
			pB++;
		}
		_CE_OFF;
		asm(&quot;nop;&quot;); // tCEH = 100ns
		Number -= vars.imax;
		if (!Number) goto readExit;

		vars.imax = (Number &gt; dFLASH_PageSize) ? dFLASH_PageSize : Number;

		vars.AF = eFLASH_areaFlag_A;
		vars.col = 0;
		vars.page++;
		vars.rowL = dLOWBYTE(vars.page);
		vars.rowH = dHIBYTE(vars.page);
	}
readExit: return;
}
</Code><Code idCode="146">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
//#define dAPuseExternalAPCode

#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif

int main()
{
	TAP AP;
	int rc;

	InitHW(); 	// hardware config

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		//Write_LCD_str(&quot;audio processor init failed with error code %i!&quot;,rc);
		LCD_print(&quot;AP failed&quot;);
		goto exit;
	}
	LCD_print(&quot;AP started&quot;);

#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);
	LCD_print(&quot;AP ended&quot;);

	return 0;
}
</Code><Code idCode="147">// ===============================
// AP uuid = 9
// ===============================

// no RX handling so far yet
void UART_RXhandler (unsigned char data) {
	
}

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="148">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable ** ps = &amp;( pParams[0].fp_pV);
// parameter i descr: index of the string at the array
	int32_t* pi = &amp;( pParams[1].fp_integer);
// parameter length descr: length of the string
	int32_t* plength = &amp;( pParams[2].fp_integer);
};
</Code><Code idCode="149">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable ** ps = &amp;( pParams[0].fp_pV);
// parameter i descr: index of the string at the array
	int32_t* pi = &amp;( pParams[1].fp_integer);
// parameter p descr: position at the string where to start from
	int32_t* pp = &amp;( pParams[2].fp_integer);
// parameter v1 descr: chars coded as 4 byte integer
	int32_t* pv1 = &amp;( pParams[3].fp_integer);
// parameter v2 descr: chars coded as 4 byte integer
	int32_t* pv2 = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="150">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable * pV = pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int index = (int)pParams[1].fp_integer;
// parameter length descr: length of the string
	int length = (int) pParams[2].fp_integer;


	// Boundary check
//	TAPstringVector * pSV =	pV-&gt;pData;
//	if ((index &lt; 0) || (index &gt;= pSV-&gt;num)) {
//		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
//		return;
//	}
	// is performed by the AL compiler

	// get APstring
	TAPstring * pS = &amp;((TAPstringVector *)pV-&gt;pData)-&gt;pStr[index];
	// resize and check result
	if (APstring_resize(pS,length)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -2;
		return;
	}
	// and go to next instruction
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="151">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable * pV = pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int i = (int) pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int p = (int) pParams[2].fp_integer;
// parameter v1 descr: chars coded as 4 byte integer
//	uint32_t* pv1 = &amp;( pParams[3].fp_raw);
// parameter v2 descr: chars coded as 4 byte integer
//	uint32_t* pv2 = &amp;( pParams[4].fp_raw);
	char *pSrc = (char *)&amp;(pParams[3].fp_raw);

	// dynamic adjust amount of bytes to be copied
	// int amount =   ((dAPInterpreterFuncMaxParams-3) * sizeof(int)/sizeof(char));

	// get string boundary check is performed by the ALC compiler
	TAPstring * pS = &amp;((TAPstringVector *)pV-&gt;pData)-&gt;pStr[i];

	APstring_fill(pS,p,((dAPInterpreterFuncMaxParams-3) * sizeof(uint32_t)/sizeof(char)),pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="152">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

TAPMsgDrv 	gDrvL [1];
TAP 		AP;

void * APIPthread(void * pArgs) {
	APInterpreterProcessState(AP.IP);

	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

int main()
{
	WSADATA			wsaData;
	pthread_t		IPthread;
	pthread_t		MSthread;


	int rc;

    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	printf(&quot;WSAStartup failed!&quot;);
    	return -1;
    }

	APdrviver_1_init(&amp;gDrvL[0]);

	time_t t;

	time(&amp;t);
	srand((unsigned int)t);              /* Zufallsgenerator initialisieren */

	int uuid = rand();

	printf (&quot;AP uuid %i\n&quot;,uuid);

	// start up gtk+
	APgtk_start ();

	//rc = APinit(&amp;AP,815,gDrvL,1,1000,eAP_littleEndian);
	rc = APinit(&amp;AP,(TAPNodeID)uuid,gDrvL,1,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
	if (rc) {
		printf(&quot;load programm failed with %i&quot;, rc);
		goto exit;
	}
#endif

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	printf(&quot;press a key to exit&quot;);
	getch();

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_halt);


exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}
</Code><Code idCode="153">// ===============================
// variable implementation for a string(var id = 3)
// ===============================
// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len - iStart;

	for (i = 0;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}

// --------------------------------------
// AP var interface
// --------------------------------------

// transmit the data
void HALimpl_3_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
return APstringVector_create((int) numberOfElements);
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="154">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system

	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="155">// ========| start of WIN Socket module |==================

// =============================
// pre defines from StjSockets
// =============================


enum eAdminMsgTypes {
	eAdminMsgType_login 	= 'i',
	eAdminMsgType_logout	= 'o',
	eAdminMsgType_exit		= 'e',
	eAdminMsgType_ack		= 'a',
	eAdminMsgType_nack		= 'n'
};

typedef struct SstjSocket_addr {
	struct sockaddr_in	Addr;
	int					len;
} TstjSocket_addr;


typedef struct SstjSocket_loginMsg {
	uint8_t		msgID;
	uint16_t	uuid;
	uint16_t	dataOutPort;
	uint16_t	dataInPort;
} TstjSocket_loginMsg;

typedef uint8_t TstjSocket_loginRAWmsg [7];

// creates a addinfo struct with the address of the local
struct addrinfo * stjSocket_getLocalSocketAddress (uint16_t port);

// creates a UPD server
int stjSocket_createServer (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	);


// creates a UDP client witch connects to a local server
int stjSocket_createClient (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	);

// closes socket &amp; address
void stjSocket_close (
		SOCKET				S,		//!&lt;(in) socket
		TstjSocket_addr	*	pAI		//!&lt;(in) address info
	);

// sends some data to an address
int stjSocket_send (
		SOCKET	 			S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	);

// receives some data and filles the address with the sender
int stjSocket_recv (
		SOCKET 				S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	);

// =============================
// pre defines from APclient
// =============================

typedef int (* TpfktAPClientRecvCallback) (void *pUserData, uint16_t number, uint8_t * pData);

typedef struct SAPClient {
	uint16_t					uuid;			//!&lt; uuid of the client

	SOCKET 						sAdmin;			//!&lt; admin socket
	uint16_t	 				adminPort;		//!&lt; admin port
	TstjSocket_addr				aAdmin;			//!&lt; socket address of the admin

	SOCKET						sDataIn;		//!&lt; data in socket
	uint16_t					dataInPort;		//!&lt; port of the data in socket
	TstjSocket_addr				aDataIn;		//!&lt; socket address of the data port

	SOCKET						sDataOut;		//!&lt; data out socket
	uint16_t					dataOutPort;	//!&lt; port of the data out socket
	TstjSocket_addr				aDataOut;		//!&lt; socket address of the data port

	pthread_t					recvThread;		//!&lt; receive thread
	uint8_t	*					recvBuffer;		//!&lt; temporaly receive buffer
	uint16_t					recvBufferSize;	//!&lt; size in bytes of the receive buffer
	void *						pUserData;		//!&lt; user data (can be NULL)
	TpfktAPClientRecvCallback	fktRecvCB;		//!&lt; receive call back funtion
} TAPClient;

// creates an admin client
int APclient_create (
		TAPClient *					pC,					//!&lt;(in/out) pointer to a client structure to be filled
		uint16_t 					adminPort,			//!&lt;(in) the port of the admin server port
		uint16_t					recvBufferSize,		//!&lt;(in) size in bytes of the receive buffer
		void *						pUserData,			//!&lt;(in) user data
		TpfktAPClientRecvCallback	fktCB				//!&lt;(in) callback function when receiving data
	);

//! free's the client
int APclient_close (
		TAPClient *		pC			//!&lt;(in) pointer to a client structure
	);


int APclient_send (
		TAPClient *		pC,			//!&lt;(in) pointer to a client structure
		uint16_t		num,		//!&lt;(in) amount of bytes to send
		uint8_t *		pData		//!&lt;(in) pointer to the data
	);

// =============================
// StjSockets implementation
// =============================

// ======================================
// defines
// ======================================

#define dMaxHostNameChars (254)

// creates a UPD server
int stjSocket_createServer (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	) {
	// create socket
	*pS=socket(AF_INET,SOCK_DGRAM,0);
	if (!*pS) goto mainErrorWithMsg;

	// create address
	pAI-&gt;Addr.sin_family=AF_INET; // AF_UNSPEC
	pAI-&gt;Addr.sin_port=htons(port);
	pAI-&gt;Addr.sin_addr.s_addr=ADDR_ANY;
	pAI-&gt;len = sizeof(SOCKADDR_IN);

	// bind socket to adress
	if (SOCKET_ERROR == bind(*pS,(SOCKADDR*)&amp;(pAI-&gt;Addr),pAI-&gt;len)) goto mainErrorWithMsg;
    return 0;
mainErrorWithMsg:
   	printf (&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
   	return -1;
}

// creates a UDP client witch connects to a local server
int stjSocket_createClient (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	) {
	char 				szPath[dMaxHostNameChars] = &quot;&quot;;
	struct hostent *	pHostInfo;

	// resolve hostname
    if (gethostname(szPath,dMaxHostNameChars)) goto mainErrorWithMsg;

	pHostInfo = gethostbyname(szPath);
	if (!pHostInfo) goto mainErrorWithMsg;

	// create socket
	*pS=socket(AF_INET,SOCK_DGRAM,0);
	if (!*pS) goto mainErrorWithMsg;

	// get the local ip from the host
	char * szLocalIP;
	szLocalIP = inet_ntoa (*(struct in_addr *)*pHostInfo-&gt;h_addr_list);

	unsigned long addr = inet_addr(szLocalIP);
	if ((INADDR_NONE == addr) || (INADDR_ANY == addr)) {
		closesocket(*pS);
		printf (&quot;unknown inet address\\nerror: %s\\n&quot;,gai_strerror(WSAGetLastError()));
		return -2;
	}

	// create address
	pAI-&gt;Addr.sin_family=AF_INET; // AF_UNSPEC
	pAI-&gt;Addr.sin_port=htons(port);
	pAI-&gt;Addr.sin_addr.s_addr= addr;
	pAI-&gt;len = sizeof(SOCKADDR_IN);

    return 0;
mainErrorWithMsg:
   	printf (&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
   	return -1;
}

// closes socket &amp; address
void stjSocket_close (
		SOCKET				S,		//!&lt;(in) socket
		TstjSocket_addr	*	pAI		//!&lt;(in) address info
	) {
	// pAI is self build so we don't need a free call
	//freeaddrinfo(gMsgServer.aiAdmin);
	closesocket(S);
}

// sends some data to an address
int stjSocket_send (
		SOCKET	 			S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	) {
	int n;
	n = sendto (S, (const char *) pData, dataSize, 0,(struct sockaddr *)&amp;(pAddr-&gt;Addr), pAddr-&gt;len);
	if (n != dataSize) {
		fprintf (stderr,&quot;sending data failed (%i bytes send)!(error: %s)!\\n&quot;,n,gai_strerror(WSAGetLastError()));
		return -1;
	}
	return 0;
}

// receives some data and filles the address with the sender
int stjSocket_recv (
		SOCKET 				S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	) {
	int n;
	n = recvfrom(S, (char *) pData, dataSize, 0,(struct sockaddr *)&amp;(pAddr-&gt;Addr), &amp;pAddr-&gt;len);
	if (n != dataSize) {
		fprintf (stderr,&quot;receiving data failed (%i bytes received)!(error: %s)!\\n&quot;,n,gai_strerror(WSAGetLastError()));
		return -1;
	}
	return 0;
}

// =============================
// APClient implementation
// =============================
// =====================================
// pre defs
// =====================================

// the thread function for receiving data
void * APclient_RecvThread (void *);


// =====================================
// functions
// =====================================


// creates an admin client
int APclient_create (
		TAPClient *					pC,					//!&lt;(in/out) pointer to a client structure to be filled
		uint16_t 					adminPort,			//!&lt;(in) the port of the admin server port
		uint16_t					recvBufferSize,		//!&lt;(in) size in bytes of the receive buffer
		void *						pUserData,			//!&lt;(in) user data
		TpfktAPClientRecvCallback	fktCB				//!&lt;(in) callback function when receiving data
	) {
	uint8_t					msgID;

	// 0. save the user data
	pC-&gt;pUserData = pUserData;

	// 1. create a socket to communicate with the admin port
	if (stjSocket_createClient(
			adminPort,
			&amp;(pC-&gt;sAdmin),
			&amp;(pC-&gt;aAdmin)
		)) {
		return -1;
	}

	pC-&gt;adminPort = adminPort;
	// 2. setup
	// request login
	msgID = eAdminMsgType_login;
	if (stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	// get the ports
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (msgID != eAdminMsgType_login) {
		fprintf(stderr,&quot;admin send wrong message back\\n&quot;);
		goto abortAndError;
	}

	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;uuid),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;dataInPort),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;dataOutPort),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;


	printf(&quot;data in: %u\\ndata out: %u\\n&quot;,(unsigned int)pC-&gt;dataInPort,(unsigned int)pC-&gt;dataOutPort);

	// create data sockets
	if (stjSocket_createServer(
			pC-&gt;dataInPort,
			&amp;(pC-&gt;sDataIn),
			&amp;(pC-&gt;aDataIn)
		)) goto DataSocketCreationError;

	// create recv buffer &amp; threads
	pC-&gt;recvBuffer = malloc((size_t)recvBufferSize);
	if (!pC) goto abortAndError;
	pC-&gt;recvBufferSize = recvBufferSize;
	pC-&gt;fktRecvCB = fktCB;

	// now we can start the handling thread
	pthread_create(&amp;pC-&gt;recvThread,NULL,APclient_RecvThread,pC);

	// send ack to server
	msgID = eAdminMsgType_ack;
	if (stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;

	// wait till server is ready
	if (stjSocket_recv(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (eAdminMsgType_ack != msgID) {
		fprintf(stderr,&quot;admin error\\n&quot;);
		return -10;
	}

	// now open the client data port
	if (stjSocket_createClient(
			pC-&gt;dataOutPort,
			&amp;(pC-&gt;sDataOut),
			&amp;(pC-&gt;aDataOut)
		)) goto DataSocketCreationError;

	// some info
    printf (&quot;client setup with uuid=%u data-in port:%u data-out port:%u\\n&quot;,(unsigned int)pC-&gt;uuid,(unsigned int)pC-&gt;dataInPort,(unsigned int)pC-&gt;dataOutPort);
    fflush(stdout);
	return 0;

abortAndError:
	msgID = eAdminMsgType_nack;
	stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin));
	return -2;

sendFailed:
	fprintf(stderr,&quot;sending to admin failed\\n&quot;);
	fprintf (stderr,&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
	return -3;

receivedFailed:
	fprintf(stderr,&quot;receiving from admin failed\\n&quot;);
	fprintf (stderr,&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
	return -4;

DataSocketCreationError:
	fprintf(stderr,&quot;creating data sockets failed\\n&quot;);
	fprintf (stderr,&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
	return -4;
}

//! free's the client
int APclient_close (
		TAPClient *		pC			//!&lt;(in/out) pointer to a client structure to be filled
	) {
	// vars
	uint8_t				msgID;

	// request logout
	msgID = eAdminMsgType_logout;
	if (stjSocket_send(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;uuid),2,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	// wait till server finished it
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (msgID != eAdminMsgType_ack) {
		fprintf(stderr,&quot;logout failed\\n&quot;);
	}

	stjSocket_close(pC-&gt;sAdmin,&amp;(pC-&gt;aAdmin));
	stjSocket_close(pC-&gt;sDataIn,&amp;(pC-&gt;aDataIn));
	stjSocket_close(pC-&gt;sDataOut,&amp;(pC-&gt;aDataOut));

	// wait till thread is gone
	pthread_join(pC-&gt;recvThread,NULL);


	return 0;
sendFailed:
	fprintf(stderr,&quot;sending to admin failed\\n&quot;);
	return -3;

receivedFailed:
	fprintf(stderr,&quot;receiving from admin failed\\n&quot;);
	return -4;
}

// the thread function for receiving data
void * APclient_RecvThread (
		void *	pArg
	) {
	uint16_t			msgLen;
	uint8_t *			pNB;

	TAPClient *			pC = pArg;

	// get data
	for (;;) {
		// read amount of data to be received
		if (stjSocket_recv(pC-&gt;sDataIn,&amp;msgLen,2,&amp;(pC-&gt;aDataIn))) goto recvError;
		// check if we have enough memory allocated at the buffer
		if (msgLen &gt; pC-&gt;recvBufferSize) {
			pNB = realloc(pC-&gt;recvBuffer,msgLen);
			if (pNB) {
				pC-&gt;recvBuffer = pNB;
				pC-&gt;recvBufferSize = msgLen;
			} else {
				fprintf (stderr,&quot;realloc memory failed&quot;);
				goto recvError;
			}
		}
		// transmit data
		if (stjSocket_recv(pC-&gt;sDataIn,pC-&gt;recvBuffer,msgLen,&amp;(pC-&gt;aDataIn))) goto recvError;
		// and handle the data
		pC-&gt;fktRecvCB(pC-&gt;pUserData, msgLen, pC-&gt;recvBuffer);

	}
	pthread_exit((void *)0);
	return NULL;

recvError:
	// close data connections
	fprintf (stderr,&quot;receiving data failed!&quot;);
	pthread_exit((void *)-3);
	return NULL;
}


int APclient_send (
		TAPClient *		pC,			//!&lt;(in) pointer to a client structure
		uint16_t		num,		//!&lt;(in) amount of bytes to send
		uint8_t *		pData		//!&lt;(in) pointer to the data
	) {
	if (stjSocket_send(pC-&gt;sDataOut,&amp;pC-&gt;uuid,2,&amp;(pC-&gt;aDataOut))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sDataOut,&amp;num,2,&amp;(pC-&gt;aDataOut))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sDataOut,pData,(int)num,&amp;(pC-&gt;aDataOut))) goto sendFailed;

	return 0;
sendFailed:
	fprintf(stderr,&quot;sending data to server failed\\n&quot;);
	return -1;

}
// ========| end of WIN Socket module |==================</Code><Code idCode="156"></Code><Code idCode="157">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drv_open_1 (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_close_1 (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_destroy_1 (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_ACK_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_NACK_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_startPrg_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_sendVariable_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_sendInstruction_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_endPrg_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_stop_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_step_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_run_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_updateVariable_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_login_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_logout_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="158">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="159">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="160">// ===============================
// driver uuid =1
// ===============================

// ------------------------------
// drv own functions
// ------------------------------

#define dAPClientServerAdminPort (50000)
#define dAPClientInitBuffer (1024)

// struct for the drv data
typedef struct SAPTCPIPdrv {
	TAPClient 					cl;			//!&lt; tcp/ip client
	TAPMsgHeader				txHeader;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TAPTCPIPdrv;

// ------------------------------
// drv own functions
// ------------------------------

int drv_1_sendHeader (
		TAPClient * pCl,
		uint32_t * pH,
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	pH[eAPMsgHeaderPosition_msgTypeID] = msgId;
	pH[eAPMsgHeaderPosition_msgNumber] = num;
	pH[eAPMsgHeaderPosition_receiver] = recv;
	pH[eAPMsgHeaderPosition_length] = length;
	if (APclient_send(pCl,sizeof(TAPMsgHeader),(uint8_t *)pH)) return -1;
	return 0;
}

// call back function of the TCP/IP driver
int drv_1_cbAPClient (void *pvDC, uint16_t number, uint8_t * pData) {
	TAPReceiveStateMachine * pSM = pvDC;
	return pSM-&gt;state (pSM, (uint32_t *) pData, number / sizeof(uint32_t));
}

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = NULL;

	pDC = malloc(sizeof(TAPTCPIPdrv));
	if (!pDC) return -1;
	if (APclient_create(&amp;(pDC-&gt;cl),dAPClientServerAdminPort,dAPClientInitBuffer,&amp;(pDC-&gt;rxSM),drv_1_cbAPClient)) return -2;
	// init header
	pDC-&gt;txHeader[eAPMsgHeaderPosition_endian] = ((TAP *) pAP)-&gt;sysEndian;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgTypeID] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgNumber] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = pDC;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;pDC-&gt;rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		APclient_close(&amp;pDC-&gt;cl);
	}
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		free(pDC);
		pDrv-&gt;pDrvData = NULL;
	}
	return 0;
}
//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_ACK, receiver, mNum, 0);
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_NACK, receiver, mNum, 0);
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_startPrg, receiver, mNum, 0) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;globalVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;localVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;instructionNumber)
		) return -10;
	return 0;
}

//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendVariable, receiver, mNum, 3) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;varTypeID) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;num)
		) return -10;
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t)*dAPInterpreterFuncMaxParams,(uint8_t *)fbc)
		) return -10;
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_endPrg, receiver, mNum, 0);
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_stop, receiver, mNum, 0);
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_step, receiver, mNum, 0);
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_run, receiver, mNum, 0);
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t i, uint32_t * data) {
	return -1;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_login, receiver, mNum, 0);
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_logout, receiver, mNum, 0);
}
</Code><Code idCode="161"></Code><Code idCode="162">// -------------------------------------------
// AP gtk helper
// -------------------------------------------

PangoFontDescription * gAPgtkMonoSpaceFont = NULL;


// a helper for destroying &quot;undestroyed&quot; UI's
void APgtk_helper_destroy (GtkWidget * pWG) {
	if (pWG) {
		if (pWG-&gt;object.parent_instance.ref_count) {
			gtk_widget_destroy(pWG);
		}
	}
}

// -------------------------------------------
// AP panel
// -------------------------------------------

// struct for a panel
typedef struct SAPgtkPanel {
	GtkWidget *		pWnd;		//!&lt; pointer to the window
	GtkWidget *		pBox;		//!&lt; placement box
} TAPgtkPanel;


// create a panel
int gtkAP_local_PanelCreate (
		TAPgtkPanel * 	pP,		//!&lt;(in/out) structure to be filled
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {
	// Create a new window
	pP-&gt;pWnd = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	if (!pP-&gt;pWnd) return -1;

	// UI's are at fixed positions
	pP-&gt;pBox = gtk_fixed_new();
	if (!pP-&gt;pBox) return -2;

	gtk_container_add(GTK_CONTAINER(pP-&gt;pWnd), pP-&gt;pBox);

	// setup main wnd
	gtk_window_set_title (GTK_WINDOW (pP-&gt;pWnd), &quot;AP Panel&quot;);
	gtk_window_set_default_size (GTK_WINDOW (pP-&gt;pWnd),xle, yle);
	gtk_window_move(GTK_WINDOW (pP-&gt;pWnd),x, y);

	// It's a good idea to do this for all windows
	//gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;destroy&quot;, GTK_SIGNAL_FUNC (gtk_exit), NULL);
	gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;destroy&quot;, GTK_SIGNAL_FUNC (gtk_widget_destroy), NULL);

	//gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;delete_event&quot;, GTK_SIGNAL_FUNC (gtk_exit), NULL);
	gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;delete_event&quot;, GTK_SIGNAL_FUNC (gtk_widget_destroy), NULL);

	// Sets the border width of the window
	gtk_container_set_border_width (GTK_CONTAINER (pP-&gt;pWnd), 1);

	gtk_widget_realize(pP-&gt;pWnd);

	gtk_widget_show_all(pP-&gt;pWnd);

	return(0);
}


// destroys a panel
void gtkAP_local_PanelDestroy (
		TAPgtkPanel * 	pP
	) {
	APgtk_helper_destroy(pP-&gt;pWnd);
	APgtk_helper_destroy(pP-&gt;pBox);
	pP-&gt;pWnd = NULL;
	pP-&gt;pBox = NULL;
}

// -------------------------------------------
// AP button
// -------------------------------------------

// struct for a AP button
typedef struct SAPgtkButton {
	GtkWidget *		pB;				//!&lt; pointer to the button
	int				pressCounter;	//!&lt; counter of the press event
} TAPgtkButton;

// call back to handle click calls
void gtkAP_cb_ButtonClicked (GtkWidget *widget, gpointer data) {
	TAPgtkButton * pB = (TAPgtkButton *) data;
	pB-&gt;pressCounter++;
}

// creates a AP button
int gtkAP_local_ButtonCreate (
		TAPgtkButton * 	pB,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {


	pB-&gt;pressCounter = 0;
	// create button
	pB-&gt;pB = gtk_button_new_with_label  (&quot;&quot;);
	if (!pB-&gt;pB) return -1;

	// bind it to the window
	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pB-&gt;pB, x, y);
	gtk_widget_set_size_request(pB-&gt;pB, xle, yle);

	gtk_widget_modify_font(gtk_bin_get_child (GTK_BIN(pB-&gt;pB)),gAPgtkMonoSpaceFont);

	gtk_widget_show (pB-&gt;pB);

	// set msg handler
	g_signal_connect(G_OBJECT(pB-&gt;pB), &quot;clicked&quot;, G_CALLBACK(gtkAP_cb_ButtonClicked), pB);


	return 0;
}

// destroys a button
void gtkAP_local_ButtonDestroy (
		TAPgtkButton * 	pB
	) {
	APgtk_helper_destroy(pB-&gt;pB);

	pB-&gt;pB = NULL;
	pB-&gt;pressCounter = 0;
}

// -------------------------------------------
// AP LED
// -------------------------------------------

// struct for a AP led
typedef struct SAPgtkLED {
	GtkWidget *		pLED;				//!&lt; pointer to the LED
	int				onFlag;
	double			onColor[3];
	double			offColor[3];
} TAPgtkLED;


static gboolean APgtk_cb_LEDexpose (
		GtkWidget *			da,
		GdkEventExpose *	event,
		gpointer        	data
	)
{
  cairo_t *		cr;
  TAPgtkLED	* 	pLED = (TAPgtkLED	*) data;
  double 		r;
  cr = gdk_cairo_create (da-&gt;window);
  gdk_cairo_rectangle (cr, &amp;event-&gt;area);
  cairo_clip (cr);
  if (pLED-&gt;onFlag) {
	  cairo_set_source_rgb (cr, pLED-&gt;onColor[0], pLED-&gt;onColor[1], pLED-&gt;onColor[2]);
  } else {
	  cairo_set_source_rgb (cr, pLED-&gt;offColor[0], pLED-&gt;offColor[1], pLED-&gt;offColor[2]);
  }
  //cairo_rectangle(cr, event-&gt;area.x, event-&gt;area.y, event-&gt;area.width, event-&gt;area.height);
  r = (event-&gt;area.width &gt; event-&gt;area.height) ? event-&gt;area.width : event-&gt;area.height;
  r /= 2.f;
  cairo_arc (cr,event-&gt;area.x+r, event-&gt;area.y+r,r, 0.f, 2.f * M_PI);

  cairo_fill(cr);
  cairo_destroy (cr);
  return TRUE;
}

// creates a AP button
int gtkAP_local_LEDCreate (
		TAPgtkLED * 	pLED,	//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	pLED-&gt;onFlag = 0;
	pLED-&gt;offColor[0] = 0.0;
	pLED-&gt;offColor[1] = 0.0;
	pLED-&gt;offColor[2] = 0.0;
	pLED-&gt;onColor[0] = 1.0;
	pLED-&gt;onColor[1] = 1.0;
	pLED-&gt;onColor[2] = 1.0;


	pLED-&gt;pLED = gtk_drawing_area_new ();
	if (!pLED-&gt;pLED) return -1;
	gtk_widget_set_size_request (pLED-&gt;pLED, xle, yle);

	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pLED-&gt;pLED, x, y);

	g_signal_connect (pLED-&gt;pLED, &quot;expose-event&quot;,  G_CALLBACK (APgtk_cb_LEDexpose), pLED);

	gtk_widget_show (pLED-&gt;pLED);

	return 0;
}

// destroys a button
void gtkAP_local_LEDDestroy (
		TAPgtkLED * 	pLED
	) {
	APgtk_helper_destroy(pLED-&gt;pLED);

	pLED-&gt;pLED = NULL;
	pLED-&gt;onFlag = 0;
	pLED-&gt;offColor[0] = 0.0;
	pLED-&gt;offColor[1] = 0.0;
	pLED-&gt;offColor[2] = 0.0;
	pLED-&gt;onColor[0] = 0.0;
	pLED-&gt;onColor[1] = 0.0;
	pLED-&gt;onColor[2] = 0.0;
}


// -------------------------------------------
// AP Display
// -------------------------------------------

// struct for a AP led
typedef struct SAPgtkDisplay {
	GtkWidget *		pD;				//!&lt; pointer to the display
	GtkWidget *		pF;				//!&lt; frame around the label
	int				charsPerLine;
	int				lineCount;
} TAPgtkDisplay;


// creates a AP display
int gtkAP_local_DisplayCreate (
		TAPgtkDisplay *	pD,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	pD-&gt;pD = NULL;
	pD-&gt;charsPerLine = 10;
	pD-&gt;lineCount = 4;

	pD-&gt;pD = gtk_label_new (&quot;&quot;);
	if (!pD-&gt;pD) return -1;
	pD-&gt;pF = gtk_frame_new(NULL);
	if (!pD-&gt;pF) return -2;

	//gtk_widget_set_size_request (pD-&gt;pD, xle-2, yle-2);
	gtk_widget_set_size_request (pD-&gt;pF, xle, yle);

	//gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pD-&gt;pD, x, y);
	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pD-&gt;pF, x, y);
	gtk_container_add(GTK_CONTAINER(pD-&gt;pF), pD-&gt;pD);

	//gtk_widget_modify_font(gtk_bin_get_child (GTK_BIN(pD-&gt;pD)),gAPgtkMonoSpaceFont);
	gtk_widget_modify_font(pD-&gt;pD,gAPgtkMonoSpaceFont);

	/*
	// change colors
	GdkColor color;
	gdk_color_parse (&quot;yellow&quot;, &amp;color);
	gtk_widget_modify_fg (pD-&gt;pD, GTK_STATE_NORMAL, &amp;color);
	// background only works for the main wnd!
	gdk_color_parse (&quot;green&quot;, &amp;color);
	gtk_widget_modify_bg(pP-&gt;pWnd, GTK_STATE_NORMAL, &amp;color);
	 */

	gtk_widget_show (pD-&gt;pD);
	gtk_widget_show (pD-&gt;pF);

	return 0;
}

// destroys a display
void gtkAP_local_DisplayDestroy (
		TAPgtkDisplay * 	pD
	) {
	APgtk_helper_destroy(pD-&gt;pD);

	pD-&gt;pD = NULL;
	pD-&gt;charsPerLine = 10;
	pD-&gt;lineCount = 2;
}


// destroys a button
void gtkAP_local_DisplaySetText(
		TAPgtkDisplay * 	pD,
		char *				szTxt
	) {
	const char const cLF = 0xA;
	char szdummyBuffer[pD-&gt;lineCount*pD-&gt;charsPerLine+1];
	char * pC = szdummyBuffer;
	int x = 0;
	int y = 0;

	while (*szTxt) {
		// check if we have a line break
		if (*szTxt == cLF) {
			y++;
			x = 0;
			// check if we reached the end
			if (y == pD-&gt;lineCount) {
				*pC = 0;
				goto printLines;
			}
		}

		// copy char
		*pC = *szTxt;
		szTxt++;
		pC++;
		x++;

		// check if we reached the end of the line
		if (x == pD-&gt;charsPerLine) {
			y++;
			x=0;
			// check if we reached the end
			if (y &lt; pD-&gt;lineCount) {
				*pC = cLF;
				pC++;
			} else {
				*pC = 0;
				goto printLines;
			}
		}

	}
	*pC = 0;
printLines:
	gtk_label_set_text(GTK_LABEL(pD-&gt;pD),szdummyBuffer);
}

// ===========================================
// AP gtk+ interface
// ===========================================

enum eAPgtkActionID {
	eAPgtkActionID_exit				= 1,
	eAPgtkActionID_redrawUI			= 10,
	eAPgtkActionID_setDisplayText	= 11,
	eAPgtkActionID_createPanel		= 20,
	eAPgtkActionID_deletePanel		= 21,
	eAPgtkActionID_createButton		= 30,
	eAPgtkActionID_deleteButton		= 31,
	eAPgtkActionID_createLED		= 40,
	eAPgtkActionID_deleteLED		= 41,
	eAPgtkActionID_createDisplay	= 50,
	eAPgtkActionID_deleteDisplay	= 51,

};

typedef struct SAPgtk_command {
	sem_t		ps;			//!&lt; process finsh semaphore
	GMutex *	gm;			//!&lt; guarding mutex
	int			newCmdFlag;	//!&lt; is set to indicate that there is a new command

	int 		cmd; 		//!&lt; command
	void *		pData1;
	void *		pData2;
	int 		x;
	int			y;
	int			xle;
	int			yle;


} TAPgtk_command;


TAPgtk_command			gAPgtkMsg;
GThread *				gAPgtkThread;

void APgtk_setMsg (
		int		id,
		void *	pD1,
		void *	pD2,
		int		x,
		int		y,
		int		xle,
		int		yle
) {
	g_mutex_lock(gAPgtkMsg.gm);
	// set the command
	gAPgtkMsg.cmd = id;
	gAPgtkMsg.pData1 = pD1;
	gAPgtkMsg.pData2 = pD2;
	gAPgtkMsg.x = x;
	gAPgtkMsg.y = y;
	gAPgtkMsg.xle = xle;
	gAPgtkMsg.yle = yle;
	gAPgtkMsg.newCmdFlag = 1;
	g_mutex_unlock(gAPgtkMsg.gm);

	sem_wait(&amp;gAPgtkMsg.ps);
}

gpointer APgtk_threadFunc (gpointer Args) {
	// init gtk and bind it to the thread
	if (FALSE ==  gtk_init_check(NULL, NULL)) return ((gpointer)-1);

	gAPgtkMonoSpaceFont = pango_font_description_from_string(&quot;monospace&quot;);

	// process messages &amp; user actions
	for (;;) {
		// check for message
		g_mutex_lock(gAPgtkMsg.gm);
		if (gAPgtkMsg.newCmdFlag) {
			switch (gAPgtkMsg.cmd) {
				case eAPgtkActionID_exit:
					goto exit;
					break;
				case eAPgtkActionID_redrawUI:
					gtk_widget_queue_draw (GTK_WIDGET(gAPgtkMsg.pData1));
					break;

				case eAPgtkActionID_setDisplayText:
					gtkAP_local_DisplaySetText(gAPgtkMsg.pData1,gAPgtkMsg.pData2);
					break;

				case eAPgtkActionID_createPanel:
					gtkAP_local_PanelCreate (
							gAPgtkMsg.pData1,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deletePanel:
					gtkAP_local_PanelDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createButton:
					gtkAP_local_ButtonCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteButton:
					gtkAP_local_ButtonDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createLED:
					gtkAP_local_LEDCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteLED:
					gtkAP_local_LEDDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createDisplay:
					gtkAP_local_DisplayCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteDisplay:
					gtkAP_local_DisplayDestroy(gAPgtkMsg.pData1);
					break;
			}
			gAPgtkMsg.newCmdFlag = 0;
			sem_post(&amp;gAPgtkMsg.ps);
		}
		g_mutex_unlock(gAPgtkMsg.gm);

		// message handling
		if (TRUE == gtk_events_pending ()) {
			gtk_main_iteration ();
		}

	}
	goto end;
exit:
	sem_post(&amp;gAPgtkMsg.ps);
	g_mutex_unlock(gAPgtkMsg.gm);
end:
	pango_font_description_free(gAPgtkMonoSpaceFont);
	gAPgtkMonoSpaceFont = NULL;
	return NULL;
}

int APgtk_start () {

	if (!g_thread_supported ()) g_thread_init (NULL);

	gAPgtkMsg.newCmdFlag = 0; // no cmd ready
	gAPgtkMsg.gm = g_mutex_new ();
	sem_init(&amp;gAPgtkMsg.ps,0,0);

	gAPgtkThread = g_thread_create(APgtk_threadFunc, NULL,TRUE, NULL);
	return 0;
}


void APgtk_end () {
	APgtk_setMsg(eAPgtkActionID_exit, NULL, NULL, 0, 0, 0, 0);
	g_thread_join(gAPgtkThread);
	g_mutex_free(gAPgtkMsg.gm);
	sem_destroy(&amp;gAPgtkMsg.ps);
}

// ----------------------------
// AP interface
// ----------------------------

// create a panel
int gtkAP_PanelCreate (
		TAPgtkPanel * 	pP,		//!&lt;(in/out) structure to be filled
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createPanel, pP, NULL, x, y, xle, yle);

	return(0);
}


// destroys a panel
void gtkAP_PanelDestroy (
		TAPgtkPanel * 	pP
	) {
	APgtk_setMsg (eAPgtkActionID_deletePanel, pP, NULL, 0,0,0,0);
}


// create a button
int gtkAP_ButtonCreate (
		TAPgtkButton * 	pB,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createButton, pB, pP, x, y, xle, yle);

	return(0);
}


// destroys a button
void gtkAP_ButtonDestroy (
		TAPgtkButton * 	pB
	) {
	APgtk_setMsg (eAPgtkActionID_deleteButton, pB, NULL, 0,0,0,0);
}

// create a LED
int gtkAP_LEDCreate (
		TAPgtkLED * 	pLED,	//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createLED, pLED, pP, x, y, xle, yle);

	return(0);
}


// destroys a LED
void gtkAP_LEDDestroy (
		TAPgtkLED * 	pLED
	) {
	APgtk_setMsg (eAPgtkActionID_deleteLED, pLED, NULL, 0,0,0,0);
}


// create a display
int gtkAP_DisplayCreate (
		TAPgtkDisplay * pD,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createDisplay, pD, pP, x, y, xle, yle);

	return(0);
}


// destroys a display
void gtkAP_DisplayDestroy (
		TAPgtkDisplay * 	pD
	) {
	APgtk_setMsg (eAPgtkActionID_deleteDisplay, pD, NULL, 0,0,0,0);
}

// destroys a display
void gtkAP_DisplaySetText (
		TAPgtkDisplay * 	pD,
		char *				pT
	) {
	APgtk_setMsg (eAPgtkActionID_setDisplayText, pD, pT, 0,0,0,0);
}


// ===========================================
// AP gtk general types and interface
// ===========================================

// AP gtk+ type enums
enum eAPgtkUItypes {
	eAPgtkUItype_unknown	= 0,
	eAPgtkUItype_panel		= 1,
	eAPgtkUItype_button		= 2,
	eAPgtkUItype_LED		= 3,
	eAPgtkUItype_display	= 4
};

// AP UI type
typedef struct SAPgtkUI {
	int		uuid;
	int 	x;
	int		y;
	int		xle;
	int		yle;
	int		typeID;
	union 	uAPgtkUI {
		TAPgtkPanel		panel;
		TAPgtkButton	button;
		TAPgtkDisplay	display;
		TAPgtkLED		led;
	} ui;
} TAPgtkUI;

// set the coordinates of the ui
void APgtkUI_setCoordinates (
		TAPgtkUI *	pUI,
		int 		x,
		int			y,
		int			xle,
		int			yle
	) {
	pUI-&gt;x = x;
	pUI-&gt;y = y;
	pUI-&gt;xle = xle;
	pUI-&gt;yle = yle;
}

// creates visible ui
int APgtkUI_createUI (
		TAPgtkUI *	pUI,
		TAPgtkUI *	pParentUI,
		int			uuid,
		int			typeID
	) {
	pUI-&gt;typeID = typeID;
	pUI-&gt;uuid = uuid;
	switch (typeID) {
		case eAPgtkUItype_panel:
			return gtkAP_PanelCreate(
					&amp;(pUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_button:
			return gtkAP_ButtonCreate(
					&amp;(pUI-&gt;ui.button),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_LED:
			return gtkAP_LEDCreate(
					&amp;(pUI-&gt;ui.led),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_display:
			return gtkAP_DisplayCreate(
					&amp;(pUI-&gt;ui.display),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
	}
	return -100;
}

// destroy visible ui
void APgtkUI_destroyUI (
		TAPgtkUI *	pUI
	) {
	switch (pUI-&gt;typeID) {
		case eAPgtkUItype_panel:
			gtkAP_PanelDestroy(&amp;(pUI-&gt;ui.panel));
			break;
		case eAPgtkUItype_button:
			gtkAP_ButtonDestroy(&amp;(pUI-&gt;ui.button));
			break;
		case eAPgtkUItype_LED:
			gtkAP_LEDDestroy(&amp;(pUI-&gt;ui.led));
			break;
		case eAPgtkUItype_display:
			gtkAP_DisplayDestroy(&amp;(pUI-&gt;ui.display));
			break;
	}
	pUI-&gt;typeID = eAPgtkUItype_unknown;
	pUI-&gt;uuid = 0;
}

// redraws a ui
void APgtkUI_redrawUI (
		TAPgtkUI *	pUI
	) {
	switch (pUI-&gt;typeID) {
		case eAPgtkUItype_panel:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.panel.pWnd, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_button:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.button.pB, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_LED:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.led.pLED, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_display:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.display.pD, NULL, 0,0,0,0);
			break;
	}
}


// AP UI array type
typedef struct SAPgtkUIvector {
	TAPgtkUI * 	pUI;
	int			number;
} TAPgtkUIvector;


TAPgtkUIvector * APgtkUI_createVector (
		int number,
		int uiType
	) {
	TAPgtkUIvector * 	pV;
	int					i;

	pV = malloc (sizeof(TAPgtkUIvector));
	if (!pV) return NULL;
	pV-&gt;pUI = malloc (sizeof(TAPgtkUI)*number);
	if (!pV-&gt;pUI) {
		free (pV);
		return NULL;
	}
	memset (pV-&gt;pUI,0,sizeof(TAPgtkUI)*number);

	pV-&gt;number = number;
	for (i = 0; i &lt; number; i++) {
		pV-&gt;pUI[i].typeID = uiType;
	}

	return pV;
}

void APgtkUI_destroyVector (
		TAPgtkUIvector * pUIv
	) {
	int i;
	for (i = 0; i &lt; pUIv-&gt;number; i++) {
		APgtkUI_destroyUI(&amp;(pUIv-&gt;pUI[i]));
	}
	free (pUIv-&gt;pUI);;
	free (pUIv);
}
</Code><Code idCode="163">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter xPos descr: x position in pixel
	int32_t* pxPos = &amp;( pParams[0].fp_integer);
// parameter yPos descr: y position in pixel
	int32_t* pyPos = &amp;( pParams[1].fp_integer);
// parameter xLen descr: x width
	int32_t* pxLen = &amp;( pParams[2].fp_integer);
// parameter yLen descr: y height
	int32_t* pyLen = &amp;( pParams[3].fp_integer);
// parameter uiVar descr: UI element
	TAPInterpreterVariable ** puiVar = &amp;( pParams[4].fp_pV);
};
</Code><Code idCode="164">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="165">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter b descr: button
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="166">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter d descr: display
	void ** pd = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="167">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter l descr: LED
	void ** pl = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="168">// ===============================
// variable implementation for pannel UI(var id = 100)
// ===============================

// transmit the data
void HALimpl_100_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_100_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_100_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_100_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
return NULL;
}
// fill the frame with data
void HALimpl_100_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {

}
</Code><Code idCode="169">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

// transmit the data
void HALimpl_101_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_101_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_101_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_101_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_button);
}
// fill the frame with data
void HALimpl_101_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="170">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

// transmit the data
void HALimpl_102_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_102_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_102_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_102_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_LED);
}
// fill the frame with data
void HALimpl_102_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="171">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

// transmit the data
void HALimpl_103_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_103_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_103_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_103_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_display);
}
// fill the frame with data
void HALimpl_103_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="172">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter xPos descr: x position in pixel
	int32_t xPos = pParams[0].fp_integer;
// parameter yPos descr: y position in pixel
	int32_t yPos = pParams[1].fp_integer;
// parameter xLen descr: x width
	int32_t xLen = pParams[2].fp_integer;
// parameter yLen descr: y height
	int32_t yLen = pParams[3].fp_integer;
// parameter ui descr: UI element
	TAPgtkUIvector * puiVec = (TAPgtkUIvector *) pParams[4].fp_pV;
// parameter uiIndex descr: UI element index
	int32_t uiIndex = pParams[5].fp_integer;
	
	APgtkUI_setCoordinates (
			&amp;(puiVec-&gt;pUI[uiIndex]),
			xPos,
			yPos,
			xLen,
			yLen
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="173">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[1].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[2].fp_integer);
};
</Code><Code idCode="174">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter b descr: button
	void ** pb = &amp;( pParams[1].fp_pD);
// parameter bIndex descr: button index
	int32_t* pbIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="175">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter d descr: display
	void ** pd = &amp;( pParams[1].fp_pD);
// parameter dIndex descr: display index
	int32_t* pdIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="176">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter l descr: LED
	void ** pl = &amp;( pParams[1].fp_pD);
// parameter lIndex descr: LED index
	int32_t* plIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="177">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter p descr: pannel
	TAPgtkUIvector * puiVec = (TAPgtkUIvector *) pParams[1].fp_pD;
// parameter pIndex descr: pannel index
	int32_t pIndex = pParams[2].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiVec-&gt;pUI[pIndex]),
			NULL,
			uiUUID,
			eAPgtkUItype_panel
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="178">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter b descr: button
	TAPgtkUIvector * puiB = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiB-&gt;pUI[bIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_button
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="179">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the panel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter b descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter bIndex descr: display index
	int32_t dIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiD-&gt;pUI[dIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_display
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="180">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t uiUUID = pParams[0].fp_integer;
// parameter l descr: LED
	TAPgtkUIvector * puiL = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiL-&gt;pUI[lIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_LED
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="181">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

// transmit the data
void HALimpl_100_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_100_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_100_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_100_initEnd (void * pVarData) {

}
// fill the frame with data
void HALimpl_100_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_panel);
}

// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="182">// ===============================
// function implementation for uiCheckButtonPressed(var id = 210)
// description: if the button was pressed the CF is set
// ===============================

void HALfunc_ID210_uiCheckButtonPressed(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter b descr: button
	TAPgtkUIvector * puiB = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[1].fp_integer;
// parameter p descr: panel

	if (puiB-&gt;pUI[bIndex].ui.button.pressCounter) {
		puiB-&gt;pUI[bIndex].ui.button.pressCounter--;
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="183">// ===============================
// function implementation for uiSetLED(var id = 211)
// description: set the LED state
// ===============================

void HALfunc_ID211_uiSetLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter l descr: LED
	TAPgtkUIvector * puiL = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[1].fp_integer;
// parameter onFlag descr: if the flag is not zero the LED is turned on
	int32_t  onFlag = pParams[2].fp_integer;

	puiL-&gt;pUI[lIndex].ui.led.onFlag = (!onFlag) ? 0 : 1;
	APgtkUI_redrawUI(&amp;(puiL-&gt;pUI[lIndex]));
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="184">// ===============================
// function implementation for jumpCF(var id = 51)
// description: jumps if the carry flag is set n instructions
// ===============================

void HALfunc_ID51_jumpCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (((TAPInterpreterCPU *)pIPcpu)-&gt;CF) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="185">// ===============================
// function implementation for jumpNCF(var id = 52)
// description: jumps if the carry flag is not set n instructions
// ===============================

void HALfunc_ID52_jumpNCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (!((TAPInterpreterCPU *)pIPcpu)-&gt;CF) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="186">// ===============================
// function implementation for setCF(var id = 55)
// description: sets the carry flag
// ===============================

void HALfunc_ID55_setCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter value descr: the value of the CF
	if (pParams[0].fp_integer) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="187">// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	*(pStr-&gt;szTxt) = 0;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len;

	for (i = iStart;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}
</Code><Code idCode="188">// ===============================
// variable implementation for a string(var id = 3)
// ===============================

// transmit the data
void HALimpl_3_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
	return APstringVector_create((int)numberOfElements);
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="189">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int32_t i = pParams[1].fp_integer;
// parameter length descr: length of the string
	int32_t length = pParams[2].fp_integer;

	if (APstring_resize(&amp;(pSV-&gt;pStr[i]),length)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="190">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int32_t i = pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int32_t p = pParams[2].fp_integer;

	char * pSrc =(char *) &amp;pParams[3].fp_raw;

	int32_t pe = p + (dAPInterpreterFuncMaxParams-3) * sizeof(int32_t);
	
	APstring_fill(&amp;(pSV-&gt;pStr[i]),p,pe,pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="191">// ===============================
// function implementation for uiSetDisplay(var id = 212)
// description: set the text of a display
// ===============================

void HALfunc_ID212_uiSetDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[2].fp_pD;
// parameter iString descr: index of the string at the array
	int32_t iString = pParams[3].fp_integer;

	gtkAP_DisplaySetText (
			&amp;(puiD-&gt;pUI[dIndex].ui.display),
			pSV-&gt;pStr[iString].szTxt
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="192">// ===============================
// variable implementation for a string(var id = 3)
// ===============================

// updates a variable the AP
int HALimpl_3_recvUpdate (void * pVarData, void * pMsg) {
	return -1;
}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
	return APstringVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_3_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="193">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

// updates a variable the AP
int HALimpl_100_recvUpdate (void * pVarData, void * pMsg) {
	return -1;
}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_panel);
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="194">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

// updates a variable the AP
int HALimpl_101_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_button);
}

// updates the vars at the other APs
int HALimpl_101_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}</Code><Code idCode="195">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

// updates a variable the AP
int HALimpl_102_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_LED);
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="196">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

// updates a variable the AP
int HALimpl_103_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_display);
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}</Code><Code idCode="197">// ===============================
// function implementation for assignConstInteger(var id = 20)
// description: a = values
// ===============================

void HALfunc_ID20_assignConstInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter iv descr: integer vector
	TAPgenericIntegerVector * piv = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter iStart descr: start index
	int32_t iStart = pParams[1].fp_integer;
// parameter num descr: number of values
	int32_t num = pParams[2].fp_integer;

	int32_t * pSrc =(int32_t *) &amp;pParams[3].fp_raw;

	APgenericIntegerVector_assignConst(piv, (int)iStart, (int)num, pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="198">// ===============================
// function implementation for assignInteger(var id = 21)
// description: a = b
// ===============================

void HALfunc_ID21_assignInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;

	APgenericIntegerVector_assign(pa, pb);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="199">// ===============================
// function implementation for addInteger(var id = 22)
// description: c = a + b
// ===============================

void HALfunc_ID22_addInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_add(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="200">// ===============================
// function implementation for subInteger(var id = 23)
// description: c = a - b
// ===============================

void HALfunc_ID23_subInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_sub(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="201">// ===============================
// function implementation for mulInteger(var id = 24)
// description: c = a * b
// ===============================

void HALfunc_ID24_mulInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_mul(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="202">// ===============================
// function implementation for divInteger(var id = 25)
// description: c = a / b
// ===============================

void HALfunc_ID25_divInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_div(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="203">// ===============================
// function implementation for modInteger(var id = 26)
// description: c = mod(a,b)
// ===============================

void HALfunc_ID26_modInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_mod(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="204">// ===============================
// function implementation for comparaIntegerLess(var id = 40)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID40_comparaIntegerLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="205">// ===============================
// function implementation for comparaIntegerMore(var id = 41)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID41_comparaIntegerMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="206">// ===============================
// function implementation for comparaIntegerEqual(var id = 42)
// description: a == b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID42_comparaIntegerEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="207">// ===============================
// function implementation for comparaIntegerNEqual(var id = 43)
// description: a != b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID43_comparaIntegerNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="208">// ===============================
// function implementation for comparaIntegerLessEqual(var id = 44)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID44_comparaIntegerLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="209">// ===============================
// function implementation for comparaIntegerMoreEqual(var id = 45)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID45_comparaIntegerMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="210">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================
// updates a variable the AP
int HALimpl_2_recvUpdate (void * pVarData, void * pMsgData) {
	int32_t * pD = (int32_t *) pMsgData;
	TAPgenericIntegerVector * pIV = pVarData;
	
	// at the first possion at the message is the global var index
	pD++; // skip it
	// and now we are at amount of values
	int imax = *pD;
	int i;

	if (APgenericIntegerVector_resize(pIV,imax)) {
		return -1;
	}

	pD++;

	for (i = 0; i &lt; imax; i++) {
		pIV-&gt;pVal[i] = (int32_t) *pD;
		pD++;
	}
	return 0;

}
// create a new variable
void * HALimpl_2_create (unsigned int numberOfElements) {
	return APgenericIntegerVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_2_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	TAPgenericIntegerVector * pIV = pVarData;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	int32_t dataAmount = 1 + pIV-&gt;num;
	int32_t dummy;
	int indx;
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	// send amount of elements
	dummy = (int32_t) pIV-&gt;num;
	pMD-&gt;pfkt_sendRaw(pMD,sizeof(int32_t),&amp;dummy);
	// send elements
	for (indx = 0; indx &lt; pIV-&gt;num; indx++) {
		dummy = (int32_t) pIV-&gt;pVal[indx];
		pMD-&gt;pfkt_sendRaw(pMD,sizeof(int32_t),&amp;dummy);
	}
	return 0;
}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_2_delete (void * pVarData) {
	APgenericIntegerVector_destroy(pVarData);
}</Code><Code idCode="211">// ===============================
// function implementation for comparaIntegerLess(var id = 40)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID40_comparaIntegerLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pV;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="212">// ===============================
// function implementation for comparaIntegerMore(var id = 41)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID41_comparaIntegerMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pV;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="213">// ===============================
// function implementation for comparaIntegerEqual(var id = 42)
// description: a == b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID42_comparaIntegerEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pV;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) == 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="214">// ===============================
// function implementation for comparaIntegerNEqual(var id = 43)
// description: a != b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID43_comparaIntegerNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pV;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) != 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="215">// ===============================
// function implementation for comparaIntegerLessEqual(var id = 44)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID44_comparaIntegerLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pV;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="216">// ===============================
// function implementation for comparaIntegerMoreEqual(var id = 45)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID45_comparaIntegerMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pV;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pV;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="217">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter var descr: the variable
	TAPInterpreterVariable ** pvar = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="218">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter var descr: the variable
	TAPInterpreterVariable ** pvar = &amp;( pParams[0].fp_pV);
// parameter varIndex descr: the variable index
	int* pvarIndex = &amp;( pParams[1].fp_VarIndex);
};
</Code><Code idCode="219">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,IP,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}



// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="220">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (TX_updateVariable(APInterpreterGetAPfromIP(((TAPInterpreterCPU *)pIPcpu)-&gt;IP),(uint32_t)pParams[0].fp_VarIndex)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -100;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="221">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,IP,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="222">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="223">// ===============================
// driver uuid =1
// ===============================
// ------------------------------
// drv own functions
// ------------------------------

#define dAPClientServerAdminPort (50000)
#define dAPClientInitBuffer (1024)

// struct for the drv data
typedef struct SAPTCPIPdrv {
	TAPClient 					cl;			//!&lt; tcp/ip client
	TAPMsgHeader				txHeader;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TAPTCPIPdrv;

// ------------------------------
// drv own functions
// ------------------------------

int drv_1_sendHeader (
		TAPClient * pCl,
		uint32_t * pH,
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	pH[eAPMsgHeaderPosition_msgTypeID] = msgId;
	pH[eAPMsgHeaderPosition_msgNumber] = num;
	pH[eAPMsgHeaderPosition_receiver] = recv;
	pH[eAPMsgHeaderPosition_length] = length;
	if (APclient_send(pCl,sizeof(TAPMsgHeader),(uint8_t *)pH)) return -1;
	return 0;
}

// call back function of the TCP/IP driver
int drv_1_cbAPClient (void *pvDC, uint16_t number, uint8_t * pData) {
	TAPReceiveStateMachine * pSM = pvDC;
	return pSM-&gt;state (pSM, (uint32_t *) pData, number / sizeof(uint32_t));
}

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = NULL;

	pDC = malloc(sizeof(TAPTCPIPdrv));
	if (!pDC) return -1;
	if (APclient_create(&amp;(pDC-&gt;cl),dAPClientServerAdminPort,dAPClientInitBuffer,&amp;(pDC-&gt;rxSM),drv_1_cbAPClient)) return -2;
	// init header
	pDC-&gt;txHeader[eAPMsgHeaderPosition_endian] = ((TAP *) pAP)-&gt;sysEndian;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgTypeID] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgNumber] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = pDC;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;pDC-&gt;rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		APclient_close(&amp;pDC-&gt;cl);
	}
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		free(pDC);
		pDrv-&gt;pDrvData = NULL;
	}
	return 0;
}


//send raw data
int drv_1_sendRaw (struct SAPMsgDrv *pDrv, int amount, void *pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	return APclient_send(&amp;(pDC-&gt;cl),amount,pData);
}


//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_ACK, receiver, mNum, 0);
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_NACK, receiver, mNum, 0);
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_startPrg, receiver, mNum, 0) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;globalVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;localVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;instructionNumber)
		) return -10;
	return 0;
}

//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendVariable, receiver, mNum, 3) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;varTypeID) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;num)
		) return -10;
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t)*dAPInterpreterFuncMaxParams,(uint8_t *)fbc)
		) return -10;
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_endPrg, receiver, mNum, 0);
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_stop, receiver, mNum, 0);
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_step, receiver, mNum, 0);
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_run, receiver, mNum, 0);
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;gIndex)
		) return -10;
	return 0;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_login, receiver, mNum, 0);
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_logout, receiver, mNum, 0);
}
</Code><Code idCode="224">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//send raw data
int drv_2_sendRaw (struct SAPMsgDrv *pDrv, int amount, void *pData) {
	return 0;
}
//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="225">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			// filter ack/nack msg
			if (ackMsgAllowed) {
				msgIDok = 1;
			} else {
				if (
						(*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
						(*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
					) {
					msgIDok = 1;
				}
			}
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}
		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	if (!pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code></Code_List><Compiler_List><Compiler AR="ar" ASM="as" CC="gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="" CXX="g++" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="" LINK="$SMARTLINK" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="$__RPATH" OBJSUFFIX=".o" OperatingSystem="windows" description="the gcc toolchain" idCompiler="1" name="gcc for Windows"/><Compiler AR="elfar" ASM="easm21k" CC="cc21k" CCCOM="$CC $CFLAGS $CCFLAGS $_CCCOMCOM -O0 -g -c -structs-do-not-overlap -no-multiline -double-size-32 -warn-protos -si-revision 0.1 -proc ADSP-21369 -o $TARGET $SOURCES" CCFLAGS="" CXX="cc21k" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="" LINK="$SMARTLINK" LINKCOM="$LINK -T ../libs/main.ldf -flags-link $SOURCES -o $TARGET -proc ADSP-21369 -si-revision 0.1 -flags-link" LINKFLAGS="$__RPATH" OBJSUFFIX=".o" OperatingSystem="ADSP" description="the ADSP toolchain" idCompiler="2" name="ADSP 21369"/><Compiler AR="msp430-ar" ASM="msp430-as" CC="msp430-gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="-mmcu=msp430f169" CXX="msp430-g++" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="-mmcu=msp430f169" LINK="$SMARTLINK" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="$__RPATH -mmcu=msp430f169" OBJSUFFIX=".o" OperatingSystem="windows &amp; linux" description="the msp430-gcc toolchain" idCompiler="3" name="msp430-gcc for msp430169F"/></Compiler_List><CompilerLib_List/><CompilerLibPath_List><CompilerLibPath idCompiler="1" idCompilerLibPath="1" path="D:\Promotion\python\APgen\libs"/><CompilerLibPath idCompiler="2" idCompilerLibPath="2" path="C:\Program Files\Analog Devices\VisualDSP 5.0\213xx\lib"/></CompilerLibPath_List><CompilerIncludePath_List><CompilerIncludePath idCompiler="1" idCompilerIncludePath="1" path="D:\Promotion\python\APgen\includes"/><CompilerIncludePath idCompiler="2" idCompilerIncludePath="2" path="C:\Program Files\Analog Devices\VisualDSP 5.0\213xx\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="3" path="C:\MinGW\include\gtk-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="4" path="C:\MinGW\include\atk-1.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="5" path="C:\MinGW\include\gdk-pixbuf-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="6" path="C:\MinGW\lib\gtk-2.0\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="7" path="C:\MinGW\include\pango-1.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="8" path="C:\MinGW\include\glib-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="9" path="C:\MinGW\include\glib-2.0\glib"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="10" path="C:\MinGW\lib\glib-2.0\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="11" path="C:\MinGW\include\cairo"/></CompilerIncludePath_List><ImplHALFunction_List><ImplHALFunction descr="increment / decrement instruction pointer" fid="50" idCode="56" idImplGroup="0" idImplHALFunction="9"/><ImplHALFunction descr="reads a sample form a wav file" fid="60" idCode="81" idImplGroup="3" idImplHALFunction="14"/><ImplHALFunction descr="writes a sample to a wav file" fid="61" idCode="82" idImplGroup="3" idImplHALFunction="15"/><ImplHALFunction descr="" fid="101" idCode="93" idImplGroup="1" idImplHALFunction="18"/><ImplHALFunction descr="" fid="110" idCode="94" idImplGroup="1" idImplHALFunction="19"/><ImplHALFunction descr="" fid="150" idCode="96" idImplGroup="1" idImplHALFunction="20"/><ImplHALFunction descr="" fid="100" idCode="97" idImplGroup="1" idImplHALFunction="21"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="114" idImplGroup="5" idImplHALFunction="32"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="115" idImplGroup="5" idImplHALFunction="33"/><ImplHALFunction descr="processes the IFFT" fid="133" idCode="120" idImplGroup="4" idImplHALFunction="37"/><ImplHALFunction descr="inits the fft structure as real input fft" fid="130" idCode="121" idImplGroup="4" idImplHALFunction="38"/><ImplHALFunction descr="inits the fft structure as ifft" fid="131" idCode="122" idImplGroup="4" idImplHALFunction="39"/><ImplHALFunction descr="processes the FFT" fid="132" idCode="123" idImplGroup="4" idImplHALFunction="40"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="127" idImplGroup="6" idImplHALFunction="41"/><ImplHALFunction descr="" fid="151" idCode="130" idImplGroup="1" idImplHALFunction="44"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="137" idImplGroup="6" idImplHALFunction="46"/><ImplHALFunction descr="convolutes a vector of samples with an cascade of biquad filters" fid="111" idCode="139" idImplGroup="1" idImplHALFunction="47"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="141" idImplGroup="7" idImplHALFunction="48"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="142" idImplGroup="7" idImplHALFunction="49"/><ImplHALFunction descr="sets the dimension of the UI" fid="200" idCode="172" idImplGroup="11" idImplHALFunction="59"/><ImplHALFunction descr="inits a panel" fid="201" idCode="177" idImplGroup="11" idImplHALFunction="64"/><ImplHALFunction descr="inits a button" fid="202" idCode="178" idImplGroup="11" idImplHALFunction="65"/><ImplHALFunction descr="inits a display" fid="203" idCode="179" idImplGroup="11" idImplHALFunction="66"/><ImplHALFunction descr="inits a LED" fid="204" idCode="180" idImplGroup="11" idImplHALFunction="67"/><ImplHALFunction descr="check button state" fid="210" idCode="182" idImplGroup="11" idImplHALFunction="68"/><ImplHALFunction descr="set LED state" fid="211" idCode="183" idImplGroup="11" idImplHALFunction="69"/><ImplHALFunction descr="increment / decrement instruction pointer if the CF is set" fid="51" idCode="184" idImplGroup="0" idImplHALFunction="70"/><ImplHALFunction descr="increment / decrement instruction pointer if the CF is not set" fid="52" idCode="185" idImplGroup="0" idImplHALFunction="71"/><ImplHALFunction descr="sets the CF" fid="55" idCode="186" idImplGroup="0" idImplHALFunction="72"/><ImplHALFunction descr="setup string" fid="5" idCode="189" idImplGroup="12" idImplHALFunction="73"/><ImplHALFunction descr="set string chars" fid="6" idCode="190" idImplGroup="12" idImplHALFunction="74"/><ImplHALFunction descr="set display text" fid="212" idCode="191" idImplGroup="11" idImplHALFunction="75"/><ImplHALFunction descr="a = const val" fid="20" idCode="197" idImplGroup="1" idImplHALFunction="76"/><ImplHALFunction descr="a = b" fid="21" idCode="198" idImplGroup="1" idImplHALFunction="77"/><ImplHALFunction descr="c = a + b" fid="22" idCode="199" idImplGroup="1" idImplHALFunction="78"/><ImplHALFunction descr="c = a - b" fid="23" idCode="200" idImplGroup="1" idImplHALFunction="79"/><ImplHALFunction descr="c = a * b" fid="24" idCode="201" idImplGroup="1" idImplHALFunction="80"/><ImplHALFunction descr="c = a / b" fid="25" idCode="202" idImplGroup="1" idImplHALFunction="81"/><ImplHALFunction descr="c = modulo(a ,b)" fid="26" idCode="203" idImplGroup="1" idImplHALFunction="82"/><ImplHALFunction descr="a&lt;b" fid="40" idCode="211" idImplGroup="1" idImplHALFunction="83"/><ImplHALFunction descr="a&gt;b" fid="41" idCode="212" idImplGroup="1" idImplHALFunction="84"/><ImplHALFunction descr="a==b" fid="42" idCode="213" idImplGroup="1" idImplHALFunction="85"/><ImplHALFunction descr="a&lt;&gt;b" fid="43" idCode="214" idImplGroup="1" idImplHALFunction="86"/><ImplHALFunction descr="a&lt;=b" fid="44" idCode="215" idImplGroup="1" idImplHALFunction="87"/><ImplHALFunction descr="a=&gt;b" fid="45" idCode="216" idImplGroup="1" idImplHALFunction="88"/><ImplHALFunction descr="updates a variable" fid="56" idCode="220" idImplGroup="0" idImplHALFunction="89"/></ImplHALFunction_List><ImplHALVariable_List><ImplHALVariable VariableID="1" descr="super generic rational" idCode="87" idImplGroup="1" idImplHALVariable="6"/><ImplHALVariable VariableID="10" descr="super generic biquad" idCode="88" idImplGroup="1" idImplHALVariable="7"/><ImplHALVariable VariableID="20" descr="super generic delay" idCode="90" idImplGroup="1" idImplHALVariable="8"/><ImplHALVariable VariableID="4" descr="complex number used/defined at the fftw3 libary" idCode="99" idImplGroup="4" idImplHALVariable="9"/><ImplHALVariable VariableID="30" descr="FFT / IFFT structure for performing ffts and iffts" idCode="116" idImplGroup="4" idImplHALVariable="10"/><ImplHALVariable VariableID="3" descr="string based on stdlib" idCode="192" idImplGroup="12" idImplHALVariable="17"/><ImplHALVariable VariableID="100" descr="panel type in gtk+ style" idCode="193" idImplGroup="11" idImplHALVariable="18"/><ImplHALVariable VariableID="101" descr="button type in gtk+ style" idCode="194" idImplGroup="11" idImplHALVariable="19"/><ImplHALVariable VariableID="102" descr="LED type in gtk+ style" idCode="195" idImplGroup="11" idImplHALVariable="20"/><ImplHALVariable VariableID="103" descr="display type in gtk+ style" idCode="196" idImplGroup="11" idImplHALVariable="21"/><ImplHALVariable VariableID="2" descr="super generic integer" idCode="210" idImplGroup="1" idImplHALVariable="22"/></ImplHALVariable_List><ImplMsgDriver_List><ImplMsgDriver descr="winAPdrv" idCode="223" idImplGroup="9" idImplMsgDriver="1"/></ImplMsgDriver_List><ImplAP_List><ImplAP descr="a overlapped frame based wavfile processing AP" idCode="102" idImplAP="4" idImplGroup="5"/><ImplAP descr="a wavfile processing AP" idCode="132" idImplAP="6" idImplGroup="3"/><ImplAP descr="a ADSP AP" idCode="135" idImplAP="7" idImplGroup="6"/><ImplAP descr="a block based wavfile processing AP, x.wav in, y.wav out; both @48000kHz" idCode="143" idImplAP="8" idImplGroup="7"/><ImplAP descr="a audio processor for the MSP430" idCode="147" idImplAP="9" idImplGroup="8"/><ImplAP descr="a super generic AP with multiple threads" idCode="225" idImplAP="10" idImplGroup="10"/></ImplAP_List><ImplGroup_List><ImplGroup idCode="1" idImplGroup="1" name="super generic"/><ImplGroup idCode="9" idImplGroup="2" name="boost"/><ImplGroup idCode="66" idImplGroup="3" name="libsndfile sample based"/><ImplGroup idCode="98" idImplGroup="4" name="fftw3 &amp; complex"/><ImplGroup idCode="101" idImplGroup="5" name="libsndfile overlapped frame based"/><ImplGroup idCode="124" idImplGroup="6" name="ADSP 21369 blockbased, ADC in, DAC3 &amp; DAC4 out"/><ImplGroup idCode="140" idImplGroup="7" name="libsndfile frame based"/><ImplGroup idCode="145" idImplGroup="8" name="MSP430-169STK"/><ImplGroup idCode="155" idImplGroup="9" name="windows UDP sockets useing pthreads"/><ImplGroup idCode="161" idImplGroup="10" name="pthreads and semaphores"/><ImplGroup idCode="162" idImplGroup="11" name="gtk+ for Windows"/><ImplGroup idCode="187" idImplGroup="12" name="ANSI C strings"/></ImplGroup_List><AP_List><AP descr="a audio processor witch processes wavfiles" idAP="5" idCodeStartup="134" idCompiler="1" name="wavFileAP"/><AP descr="the generic AP for ADSP devices" idAP="6" idCodeStartup="138" idCompiler="2" name="asdp21369gen"/><AP descr="framebased AP fs=48000kHz, in=x.wav, out=y.wav" idAP="7" idCodeStartup="144" idCompiler="1" name="wavFileAPframebased"/><AP descr="a AP for the MSP430-169STK" idAP="8" idCodeStartup="146" idCompiler="3" name="MSP430"/><AP descr="generic multi thread AP for testing" idAP="9" idCodeStartup="152" idCompiler="1" name="AP test"/></AP_List><FunctionList_List><FunctionList idAP="5" idFunctionList="38" idImplHALFunction="9"/><FunctionList idAP="5" idFunctionList="39" idImplHALFunction="14"/><FunctionList idAP="5" idFunctionList="40" idImplHALFunction="15"/><FunctionList idAP="5" idFunctionList="42" idImplHALFunction="18"/><FunctionList idAP="5" idFunctionList="43" idImplHALFunction="19"/><FunctionList idAP="5" idFunctionList="45" idImplHALFunction="20"/><FunctionList idAP="5" idFunctionList="46" idImplHALFunction="44"/><FunctionList idAP="6" idFunctionList="47" idImplHALFunction="9"/><FunctionList idAP="6" idFunctionList="50" idImplHALFunction="21"/><FunctionList idAP="6" idFunctionList="51" idImplHALFunction="18"/><FunctionList idAP="6" idFunctionList="54" idImplHALFunction="41"/><FunctionList idAP="6" idFunctionList="55" idImplHALFunction="46"/><FunctionList idAP="6" idFunctionList="56" idImplHALFunction="47"/><FunctionList idAP="5" idFunctionList="57" idImplHALFunction="47"/><FunctionList idAP="7" idFunctionList="58" idImplHALFunction="9"/><FunctionList idAP="7" idFunctionList="61" idImplHALFunction="47"/><FunctionList idAP="7" idFunctionList="62" idImplHALFunction="48"/><FunctionList idAP="7" idFunctionList="63" idImplHALFunction="49"/><FunctionList idAP="7" idFunctionList="64" idImplHALFunction="21"/><FunctionList idAP="7" idFunctionList="65" idImplHALFunction="18"/><FunctionList idAP="9" idFunctionList="66" idImplHALFunction="73"/><FunctionList idAP="9" idFunctionList="67" idImplHALFunction="74"/><FunctionList idAP="9" idFunctionList="68" idImplHALFunction="76"/><FunctionList idAP="9" idFunctionList="69" idImplHALFunction="9"/><FunctionList idAP="9" idFunctionList="70" idImplHALFunction="70"/><FunctionList idAP="9" idFunctionList="71" idImplHALFunction="71"/><FunctionList idAP="9" idFunctionList="72" idImplHALFunction="72"/><FunctionList idAP="9" idFunctionList="74" idImplHALFunction="59"/><FunctionList idAP="9" idFunctionList="75" idImplHALFunction="64"/><FunctionList idAP="9" idFunctionList="76" idImplHALFunction="65"/><FunctionList idAP="9" idFunctionList="77" idImplHALFunction="66"/><FunctionList idAP="9" idFunctionList="78" idImplHALFunction="67"/><FunctionList idAP="9" idFunctionList="79" idImplHALFunction="68"/><FunctionList idAP="9" idFunctionList="80" idImplHALFunction="69"/><FunctionList idAP="9" idFunctionList="81" idImplHALFunction="75"/><FunctionList idAP="9" idFunctionList="82" idImplHALFunction="89"/><FunctionList idAP="9" idFunctionList="83" idImplHALFunction="77"/><FunctionList idAP="9" idFunctionList="90" idImplHALFunction="78"/><FunctionList idAP="9" idFunctionList="91" idImplHALFunction="79"/><FunctionList idAP="9" idFunctionList="92" idImplHALFunction="80"/><FunctionList idAP="9" idFunctionList="93" idImplHALFunction="81"/><FunctionList idAP="9" idFunctionList="94" idImplHALFunction="82"/><FunctionList idAP="9" idFunctionList="95" idImplHALFunction="83"/><FunctionList idAP="9" idFunctionList="96" idImplHALFunction="84"/><FunctionList idAP="9" idFunctionList="97" idImplHALFunction="85"/><FunctionList idAP="9" idFunctionList="98" idImplHALFunction="86"/><FunctionList idAP="9" idFunctionList="99" idImplHALFunction="87"/><FunctionList idAP="9" idFunctionList="100" idImplHALFunction="88"/></FunctionList_List><VariableList_List><VariableList idAP="5" idImplHALVariable="6" idVariableList="15"/><VariableList idAP="5" idImplHALVariable="8" idVariableList="16"/><VariableList idAP="5" idImplHALVariable="7" idVariableList="17"/><VariableList idAP="6" idImplHALVariable="6" idVariableList="18"/><VariableList idAP="6" idImplHALVariable="7" idVariableList="19"/><VariableList idAP="7" idImplHALVariable="6" idVariableList="21"/><VariableList idAP="7" idImplHALVariable="7" idVariableList="22"/><VariableList idAP="9" idImplHALVariable="17" idVariableList="23"/><VariableList idAP="9" idImplHALVariable="18" idVariableList="24"/><VariableList idAP="9" idImplHALVariable="19" idVariableList="25"/><VariableList idAP="9" idImplHALVariable="20" idVariableList="26"/><VariableList idAP="9" idImplHALVariable="21" idVariableList="27"/><VariableList idAP="9" idImplHALVariable="22" idVariableList="28"/></VariableList_List><DriverList_List><DriverList idAP="9" idDriverList="1" idImplMsgDriver="1"/></DriverList_List><APList_List><APList idAP="5" idAPList="5" idImplAP="6"/><APList idAP="6" idAPList="6" idImplAP="7"/><APList idAP="7" idAPList="7" idImplAP="8"/><APList idAP="8" idAPList="8" idImplAP="9"/><APList idAP="9" idAPList="9" idImplAP="10"/></APList_List><ALASMprogramm_List><ALASMprogramm code="" idALASMprogramm="1"/><ALASMprogramm code="" idALASMprogramm="2"/><ALASMprogramm code="" idALASMprogramm="3"/></ALASMprogramm_List><pythonScript_List><pythonScript code="# the python implementation  import scipy import numpy  from scipy.io import wavfile from scipy.signal import lfilter  import floatwavefile import stjMatPython  def calcLP (fg, fs):     # n - numerator     # d - denumerator     k=numpy.tan(numpy.pi*fg/fs)     k2 = k * k     sqrtTwo = numpy.sqrt(2)     dn = (1+sqrtTwo*k+k2)          n0=k2/dn     n1=2*k2/dn     n2=k2/dn     d0=1     d1=(2*(k2-1))/dn     d2=(1-sqrtTwo*k+k2)/dn     return [[n0,n1,n2],[d0,d1,d2]]  def calcHP (fg, fs):     # n - numerator     # d - denumerator     k=numpy.tan(numpy.pi*fg/fs)     k2 = k * k     sqrtTwo = numpy.sqrt(2)     dn = (1+sqrtTwo*k+k2)          n0=1/dn     n1=-2/dn     n2=1/dn     d0=1     d1=(2*(k2-1))/dn     d2=(1-sqrtTwo*k+k2)/dn     return [[n0,n1,n2],[d0,d1,d2]]  def normFilterCoeff (n,d):     rn = numpy.divide(n,d[0])     rd = numpy.divide(d,d[0])     return rn, rd  def initCrossOver (fLp, fHp, fs): # scipy has an own bilinear transformation method to go from a sjw to z space #from scipy.signal import bilinear #LP = bilinear(b, a, fs)     # calc filter coefficents ...     n, d = calcLP(fLp, fs)     n, d = normFilterCoeff(n,d)     LP = {'n' : n, 'd' : d}     n, d = calcHP(fHp, fs)     n, d = normFilterCoeff(n,d)     HP = {'n' : n, 'd' : d}     return LP, HP  def convoluteSignalWithFilter (n, d, xA):     s1 = float(0.)     s2 = float(0.)     l = len(xA)     yA = numpy.zeros(l)     i = 0     for x in xA:         d1 = -d[2]*s2-d[1]*s1+d[0]*x         y = n[2]*s2+n[1]*s1+n[0]*d1         s2 = s1         s1 = d1         yA[i] = y         i += 1     return yA  def measureCrossOver (CO, Xsig):     LP = CO[0]     HP = CO[1]     yLP = lfilter (LP['n'],LP['d'],Xsig)     yHP = lfilter (HP['n'],HP['d'],Xsig)     #yLP = convoluteSignalWithFilter(LP['n'],LP['d'],Xsig)     #yHP = convoluteSignalWithFilter(HP['n'],HP['d'],Xsig)          return yLP,yHP   if __name__ == '__main__':     # set the sample frequency     N = int(2**16)     fs = float(44100)          xScalor = fs / N          # read data from the wave file         [rate, x] = floatwavefile.readFloatWAV('noise.wav')          #display read data      # convolute data with the crossover filter     CO = initCrossOver(1000,2000,fs)     yLP, yHP = measureCrossOver(CO,x)      wv = numpy.array(yLP,dtype=numpy.float32)          floatwavefile.writeFloatWAV('pythonLP.wav', fs, wv)      wv = numpy.array(yHP,dtype=numpy.float32)          floatwavefile.writeFloatWAV('pythonHP.wav', fs, wv)" idpythonScript="1"/><pythonScript code="# the python initiation script import scipy import numpy  from scipy.io import wavfile from scipy.signal import lfilter  import floatwavefile  # set the sample frequency N = int(2**16) fs = float(44100)      xScalor = fs / N      # create the amplitude and phase array # all fequencies have an amplitude of 1      # we have to keep in mind that we want to produce an real signal # this means that the fft specturm is mirrored at N/2      # generate random phase angle witch is uniform distributed phi = numpy.random.uniform(low=-1*numpy.pi, high=numpy.pi, size=N/2) Y = numpy.ones(N/2, dtype=complex)      # merge phase and amplitude # z = A * e^(jw) i = 0 for p in phi:     Y[i] = numpy.exp(1.j *p)     i += 1 # set the DC value to 0 Y[0] = 0 + 0.j  # ifft to gain a real signal x = numpy.fft.irfft(Y)  # dump wave file wv = numpy.array(x,dtype=numpy.float32)      floatwavefile.writeFloatWAV('noise.wav', fs, wv)" idpythonScript="2"/><pythonScript code="# the python close script import scipy import numpy  import floatwavefile import stjMatPython  import matplotlib.pyplot as plt  print ('analyse results')  N = int(2**16) fs = float(44100)  xScalor = fs / N  [rate, x] = floatwavefile.readFloatWAV('noise.wav')  [rate, yPLP] = floatwavefile.readFloatWAV('pythonLP.wav') [rate, yPHP] = floatwavefile.readFloatWAV('pythonHP.wav') [rate, yMLP] = floatwavefile.readFloatWAV('matlabLP.wav') [rate, yMHP] = floatwavefile.readFloatWAV('matlabHP.wav') [rate, yAPLP] = floatwavefile.readFloatWAV('apLP.wav') [rate, yAPHP] = floatwavefile.readFloatWAV('apHP.wav')    stjMatPython.poltBode (211,212,numpy.fft.rfft(yAPLP),N,xScalor,'red',1,0.4,'audio processor') stjMatPython.poltBode (211,212,numpy.fft.rfft(yAPHP),N,xScalor,'red',1,0.4,None) stjMatPython.poltBode (211,212,numpy.fft.rfft(yPLP),N,xScalor,'green',1,0.5,'python') stjMatPython.poltBode (211,212,numpy.fft.rfft(yPHP),N,xScalor,'green',1,0.5,None) stjMatPython.poltBode (211,212,numpy.fft.rfft(yMLP),N,xScalor,'blue',1,0.3,'matlab') stjMatPython.poltBode (211,212,numpy.fft.rfft(yMHP),N,xScalor,'blue',1,0.3,None)   lpDif = yPLP - yMLP hpDif = yPHP - yMHP  plt.show()" idpythonScript="3"/><pythonScript code="# the python implementation" idpythonScript="4"/><pythonScript code="# the python initiation script" idpythonScript="5"/><pythonScript code="# the python close script" idpythonScript="6"/><pythonScript code="# the python implementation" idpythonScript="7"/><pythonScript code="# the python initiation script" idpythonScript="8"/><pythonScript code="# the python close script" idpythonScript="9"/></pythonScript_List><MatlabProgramm_List><MatlabProgramm code="% the matlab program clear clc % const N = 2^16; fs = 44100.0; fHP = 2000; fLP = 1000;  % calc filter HP = calcHP(fs, fHP); LP = calcLP (fs, fLP);  %normize filter HP = normFilterCoeff(HP); LP = normFilterCoeff(LP);  %load noise signal x = wavread('noise.wav');  % convolute filter with the signal yHP = filter(HP(1,:),HP(2,:),x); yLP = filter(LP(1,:),LP(2,:),x);   % save results to file wavwrite (yLP,fs,32,'matlabLP.wav'); wavwrite (yHP,fs,32,'matlabHP.wav');" idMatlabProgramm="1"/><MatlabProgramm code="% the matlab program" idMatlabProgramm="2"/><MatlabProgramm code="% the matlab program" idMatlabProgramm="3"/></MatlabProgramm_List><testPattern_List><testPattern descr="test crossover filter" idALASMprogramm="1" idAP="1" idMatlabProgramm="1" idPythonExitScript="3" idPythonInitScript="2" idpythonProgramm="1" idtestPattern="1" name="cof"/><testPattern descr="embeeded world conference crossover test" idALASMprogramm="2" idAP="1" idMatlabProgramm="2" idPythonExitScript="6" idPythonInitScript="5" idpythonProgramm="4" idtestPattern="2" name="ebw"/><testPattern descr="DAFx 2012 testpattern" idALASMprogramm="3" idAP="6" idMatlabProgramm="3" idPythonExitScript="9" idPythonInitScript="8" idpythonProgramm="7" idtestPattern="3" name="DAFXx 2012"/></testPattern_List></APDB>