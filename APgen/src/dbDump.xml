<?xml version="1.0" ?><APDB><HAL_basicIOTypes_List><HAL_basicIOTypes TypeID="1" TypeName="rational" cType="float" description="a type for rational numbers" endianType="False" idHAL_IOTypesDefinition="1" sizeInBytes="4"/><HAL_basicIOTypes TypeID="2" TypeName="integer" cType="int32_t" description="a type for natural and integer numbers" endianType="True" idHAL_IOTypesDefinition="2" sizeInBytes="4"/><HAL_basicIOTypes TypeID="3" TypeName="char" cType="char" description="a type for character" endianType="False" idHAL_IOTypesDefinition="3" sizeInBytes="1"/><HAL_basicIOTypes TypeID="4" TypeName="raw" cType="uint32_t" description="4 Byte Raw Data" endianType="False" idHAL_IOTypesDefinition="4" sizeInBytes="4"/></HAL_basicIOTypes_List><HAL_VariableIOParameter_List><HAL_VariableIOParameter VariableID="1" basicTypeID="1" description="the value of the number" idHAL_VariableIOParameter="1" isArray="False" name="value"/><HAL_VariableIOParameter VariableID="2" basicTypeID="2" description="the value of the number" idHAL_VariableIOParameter="2" isArray="False" name="value"/><HAL_VariableIOParameter VariableID="3" basicTypeID="2" description="the length of the string" idHAL_VariableIOParameter="3" isArray="False" name="length"/><HAL_VariableIOParameter VariableID="3" basicTypeID="3" description="the text of the string" idHAL_VariableIOParameter="4" isArray="True" name="text"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="5" isArray="False" name="a0"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="6" isArray="False" name="a1"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="7" isArray="False" name="a2"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="denominator coefficient" idHAL_VariableIOParameter="8" isArray="False" name="b1"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="denominator coefficient" idHAL_VariableIOParameter="9" isArray="False" name="b2"/><HAL_VariableIOParameter VariableID="30" basicTypeID="2" description="number of samples" idHAL_VariableIOParameter="11" isArray="False" name="N"/><HAL_VariableIOParameter VariableID="4" basicTypeID="1" description="real part" idHAL_VariableIOParameter="12" isArray="False" name="r"/><HAL_VariableIOParameter VariableID="4" basicTypeID="2" description="imaginary part" idHAL_VariableIOParameter="13" isArray="False" name="i"/><HAL_VariableIOParameter VariableID="66" basicTypeID="1" description="the data list" idHAL_VariableIOParameter="14" isArray="True" name="dataL"/><HAL_VariableIOParameter VariableID="66" basicTypeID="1" description="koefficent" idHAL_VariableIOParameter="15" isArray="False" name="keffi"/><HAL_VariableIOParameter VariableID="66" basicTypeID="2" description="index" idHAL_VariableIOParameter="16" isArray="False" name="indx"/><HAL_VariableIOParameter VariableID="66" basicTypeID="2" description="array nummero 2" idHAL_VariableIOParameter="17" isArray="True" name="array2"/><HAL_VariableIOParameter VariableID="20" basicTypeID="1" description="the values ordered oldest to jungest" idHAL_VariableIOParameter="18" isArray="True" name="values"/></HAL_VariableIOParameter_List><HAL_FunctionsParameter_List><HAL_FunctionsParameter descr="left side number" fid="40" idHAL_FunctionsParameter="41" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="50" idHAL_FunctionsParameter="53" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="51" idHAL_FunctionsParameter="54" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="52" idHAL_FunctionsParameter="55" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="the channel" fid="60" idHAL_FunctionsParameter="56" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the result of the action" fid="60" idHAL_FunctionsParameter="57" idParameterClass="3" idParameterType="1" name="resValue"/><HAL_FunctionsParameter descr="the channel" fid="61" idHAL_FunctionsParameter="58" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the value to be written to the output" fid="61" idHAL_FunctionsParameter="59" idParameterClass="3" idParameterType="1" name="value"/><HAL_FunctionsParameter descr="a value" fid="3" idHAL_FunctionsParameter="60" idParameterClass="1" idParameterType="2" name="value"/><HAL_FunctionsParameter descr="input" fid="110" idHAL_FunctionsParameter="77" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="150" idHAL_FunctionsParameter="79" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="the delay" fid="150" idHAL_FunctionsParameter="80" idParameterClass="3" idParameterType="20" name="delay"/><HAL_FunctionsParameter descr="output" fid="150" idHAL_FunctionsParameter="81" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="biquad cascade" fid="110" idHAL_FunctionsParameter="83" idParameterClass="3" idParameterType="10" name="bqa"/><HAL_FunctionsParameter descr="output" fid="110" idHAL_FunctionsParameter="84" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="window length" fid="120" idHAL_FunctionsParameter="85" idParameterClass="1" idParameterType="2" name="wl"/><HAL_FunctionsParameter descr="set to 1 if used for periodic constructs like DFT/FFT" fid="120" idHAL_FunctionsParameter="86" idParameterClass="1" idParameterType="2" name="flag"/><HAL_FunctionsParameter descr="window coefficients (array of rational values)" fid="120" idHAL_FunctionsParameter="87" idParameterClass="2" idParameterType="1" name="wnd"/><HAL_FunctionsParameter descr="FFT length" fid="130" idHAL_FunctionsParameter="88" idParameterClass="1" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="IFFT length" fid="131" idHAL_FunctionsParameter="89" idParameterClass="1" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="the channel" fid="62" idHAL_FunctionsParameter="92" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the buffer witch receives the samples" fid="62" idHAL_FunctionsParameter="93" idParameterClass="3" idParameterType="1" name="frameBuffer"/><HAL_FunctionsParameter descr="the channel" fid="63" idHAL_FunctionsParameter="94" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the buffer which is writen to the channel" fid="63" idHAL_FunctionsParameter="95" idParameterClass="3" idParameterType="1" name="frameBuffer"/><HAL_FunctionsParameter descr="input" fid="130" idHAL_FunctionsParameter="100" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="output" fid="130" idHAL_FunctionsParameter="101" idParameterClass="3" idParameterType="4" name="y"/><HAL_FunctionsParameter descr="input" fid="131" idHAL_FunctionsParameter="102" idParameterClass="3" idParameterType="4" name="x"/><HAL_FunctionsParameter descr="output" fid="131" idHAL_FunctionsParameter="103" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="IFFT structure" fid="131" idHAL_FunctionsParameter="104" idParameterClass="2" idParameterType="30" name="ifftStruct"/><HAL_FunctionsParameter descr="FFT structure" fid="130" idHAL_FunctionsParameter="105" idParameterClass="2" idParameterType="30" name="fftStruct"/><HAL_FunctionsParameter descr="the ifft info structure" fid="133" idHAL_FunctionsParameter="107" idParameterClass="2" idParameterType="30" name="ifftStruct"/><HAL_FunctionsParameter descr="the fft structure" fid="132" idHAL_FunctionsParameter="108" idParameterClass="2" idParameterType="30" name="fftStruct"/><HAL_FunctionsParameter descr="uuid of the pannel" fid="201" idHAL_FunctionsParameter="123" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="panel" fid="201" idHAL_FunctionsParameter="124" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="uuid of the button" fid="202" idHAL_FunctionsParameter="125" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="button" fid="202" idHAL_FunctionsParameter="126" idParameterClass="3" idParameterType="101" name="b"/><HAL_FunctionsParameter descr="uuid of the display" fid="203" idHAL_FunctionsParameter="127" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="display" fid="203" idHAL_FunctionsParameter="128" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="uuid of the LED" fid="204" idHAL_FunctionsParameter="129" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="LED" fid="204" idHAL_FunctionsParameter="130" idParameterClass="3" idParameterType="102" name="l"/><HAL_FunctionsParameter descr="the string" fid="5" idHAL_FunctionsParameter="131" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="5" idHAL_FunctionsParameter="132" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="length of the string" fid="5" idHAL_FunctionsParameter="133" idParameterClass="1" idParameterType="2" name="length"/><HAL_FunctionsParameter descr="the string" fid="6" idHAL_FunctionsParameter="134" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="6" idHAL_FunctionsParameter="135" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="position at the string where to start from" fid="6" idHAL_FunctionsParameter="136" idParameterClass="1" idParameterType="2" name="p"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="137" idParameterClass="1" idParameterType="4" name="v1"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="138" idParameterClass="1" idParameterType="4" name="v2"/><HAL_FunctionsParameter descr="panel index" fid="201" idHAL_FunctionsParameter="139" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="button index" fid="202" idHAL_FunctionsParameter="140" idParameterClass="1" idParameterType="2" name="bIndex"/><HAL_FunctionsParameter descr="panel" fid="202" idHAL_FunctionsParameter="141" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="202" idHAL_FunctionsParameter="142" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="display index" fid="203" idHAL_FunctionsParameter="143" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="panel" fid="203" idHAL_FunctionsParameter="144" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="203" idHAL_FunctionsParameter="145" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="LED index" fid="204" idHAL_FunctionsParameter="146" idParameterClass="1" idParameterType="2" name="lIndex"/><HAL_FunctionsParameter descr="panel" fid="204" idHAL_FunctionsParameter="147" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="204" idHAL_FunctionsParameter="148" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="x position" fid="200" idHAL_FunctionsParameter="149" idParameterClass="1" idParameterType="2" name="x"/><HAL_FunctionsParameter descr="y position" fid="200" idHAL_FunctionsParameter="150" idParameterClass="1" idParameterType="2" name="y"/><HAL_FunctionsParameter descr="x length" fid="200" idHAL_FunctionsParameter="151" idParameterClass="1" idParameterType="2" name="xle"/><HAL_FunctionsParameter descr="y length" fid="200" idHAL_FunctionsParameter="152" idParameterClass="1" idParameterType="2" name="yle"/><HAL_FunctionsParameter descr="ui" fid="200" idHAL_FunctionsParameter="153" idParameterClass="3" idParameterType="0" name="ui"/><HAL_FunctionsParameter descr="ui index" fid="200" idHAL_FunctionsParameter="154" idParameterClass="1" idParameterType="2" name="uiIndex"/><HAL_FunctionsParameter descr="button" fid="210" idHAL_FunctionsParameter="155" idParameterClass="3" idParameterType="101" name="b"/><HAL_FunctionsParameter descr="button index" fid="210" idHAL_FunctionsParameter="156" idParameterClass="1" idParameterType="2" name="bIndex"/><HAL_FunctionsParameter descr="LED" fid="211" idHAL_FunctionsParameter="157" idParameterClass="3" idParameterType="102" name="l"/><HAL_FunctionsParameter descr="LED index" fid="211" idHAL_FunctionsParameter="158" idParameterClass="1" idParameterType="2" name="lIndex"/><HAL_FunctionsParameter descr="if the flag is not zero the LED is turned on" fid="211" idHAL_FunctionsParameter="159" idParameterClass="1" idParameterType="2" name="onFlag"/><HAL_FunctionsParameter descr="the value of the CF" fid="55" idHAL_FunctionsParameter="160" idParameterClass="1" idParameterType="2" name="value"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="161" idParameterClass="1" idParameterType="4" name="v3"/><HAL_FunctionsParameter descr="display" fid="212" idHAL_FunctionsParameter="162" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="display index" fid="212" idHAL_FunctionsParameter="163" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="the string" fid="212" idHAL_FunctionsParameter="164" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="212" idHAL_FunctionsParameter="165" idParameterClass="1" idParameterType="2" name="iString"/><HAL_FunctionsParameter descr="integer vector" fid="20" idHAL_FunctionsParameter="166" idParameterClass="3" idParameterType="2" name="iv"/><HAL_FunctionsParameter descr="start index" fid="20" idHAL_FunctionsParameter="167" idParameterClass="1" idParameterType="2" name="iStart"/><HAL_FunctionsParameter descr="amount of values used" fid="20" idHAL_FunctionsParameter="168" idParameterClass="1" idParameterType="2" name="num"/><HAL_FunctionsParameter descr="value 1" fid="20" idHAL_FunctionsParameter="169" idParameterClass="1" idParameterType="2" name="v1"/><HAL_FunctionsParameter descr="value 2" fid="20" idHAL_FunctionsParameter="170" idParameterClass="1" idParameterType="2" name="v2"/><HAL_FunctionsParameter descr="value 3" fid="20" idHAL_FunctionsParameter="171" idParameterClass="1" idParameterType="2" name="v3"/><HAL_FunctionsParameter descr="vector a" fid="21" idHAL_FunctionsParameter="172" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="21" idHAL_FunctionsParameter="173" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector a" fid="22" idHAL_FunctionsParameter="175" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="22" idHAL_FunctionsParameter="176" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="22" idHAL_FunctionsParameter="177" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="23" idHAL_FunctionsParameter="178" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector a" fid="24" idHAL_FunctionsParameter="179" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="23" idHAL_FunctionsParameter="180" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector b" fid="24" idHAL_FunctionsParameter="181" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="23" idHAL_FunctionsParameter="182" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector c" fid="24" idHAL_FunctionsParameter="183" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="25" idHAL_FunctionsParameter="184" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="25" idHAL_FunctionsParameter="185" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="25" idHAL_FunctionsParameter="186" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="26" idHAL_FunctionsParameter="187" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="26" idHAL_FunctionsParameter="188" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="26" idHAL_FunctionsParameter="189" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="index at a vector" fid="40" idHAL_FunctionsParameter="190" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="40" idHAL_FunctionsParameter="191" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="40" idHAL_FunctionsParameter="192" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="left side number" fid="41" idHAL_FunctionsParameter="193" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="42" idHAL_FunctionsParameter="194" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="43" idHAL_FunctionsParameter="195" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="44" idHAL_FunctionsParameter="196" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="45" idHAL_FunctionsParameter="197" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="41" idHAL_FunctionsParameter="198" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="42" idHAL_FunctionsParameter="199" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="43" idHAL_FunctionsParameter="200" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="44" idHAL_FunctionsParameter="201" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="45" idHAL_FunctionsParameter="202" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="41" idHAL_FunctionsParameter="203" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="42" idHAL_FunctionsParameter="204" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="43" idHAL_FunctionsParameter="205" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="44" idHAL_FunctionsParameter="206" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="45" idHAL_FunctionsParameter="207" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="41" idHAL_FunctionsParameter="208" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="42" idHAL_FunctionsParameter="209" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="43" idHAL_FunctionsParameter="210" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="44" idHAL_FunctionsParameter="211" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="45" idHAL_FunctionsParameter="212" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="the variable (internally the index of the variable)" fid="56" idHAL_FunctionsParameter="214" idParameterClass="5" idParameterType="0" name="var"/><HAL_FunctionsParameter descr="biquad cascade" fid="100" idHAL_FunctionsParameter="226" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="index at the cascade" fid="100" idHAL_FunctionsParameter="227" idParameterClass="3" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="sample frequnecy" fid="100" idHAL_FunctionsParameter="228" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="cut off frequency" fid="100" idHAL_FunctionsParameter="229" idParameterClass="3" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="biquad cascade" fid="101" idHAL_FunctionsParameter="230" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="biquad cascade" fid="102" idHAL_FunctionsParameter="231" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="biquad cascade" fid="103" idHAL_FunctionsParameter="232" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="biquad cascade" fid="104" idHAL_FunctionsParameter="233" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="index at the cascade" fid="101" idHAL_FunctionsParameter="234" idParameterClass="3" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="index at the cascade" fid="102" idHAL_FunctionsParameter="235" idParameterClass="3" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="index at the cascade" fid="103" idHAL_FunctionsParameter="236" idParameterClass="3" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="index at the cascade" fid="104" idHAL_FunctionsParameter="237" idParameterClass="3" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="sample frequnecy" fid="101" idHAL_FunctionsParameter="238" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="sample frequnecy" fid="102" idHAL_FunctionsParameter="239" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="sample frequnecy" fid="103" idHAL_FunctionsParameter="240" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="sample frequnecy" fid="104" idHAL_FunctionsParameter="241" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="cut off frequency" fid="101" idHAL_FunctionsParameter="242" idParameterClass="3" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="center frequency" fid="102" idHAL_FunctionsParameter="243" idParameterClass="3" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="cut/boost frequency" fid="103" idHAL_FunctionsParameter="244" idParameterClass="3" idParameterType="1" name="f"/><HAL_FunctionsParameter descr="cut/boost frequency" fid="104" idHAL_FunctionsParameter="245" idParameterClass="3" idParameterType="1" name="f"/><HAL_FunctionsParameter descr="quality" fid="102" idHAL_FunctionsParameter="246" idParameterClass="3" idParameterType="1" name="q"/><HAL_FunctionsParameter descr="gain (not in dB)" fid="102" idHAL_FunctionsParameter="249" idParameterClass="3" idParameterType="1" name="g"/><HAL_FunctionsParameter descr="gain (not in dB)" fid="103" idHAL_FunctionsParameter="250" idParameterClass="3" idParameterType="1" name="g"/><HAL_FunctionsParameter descr="gain (not in dB)" fid="104" idHAL_FunctionsParameter="251" idParameterClass="3" idParameterType="1" name="g"/><HAL_FunctionsParameter descr="left side number" fid="34" idHAL_FunctionsParameter="252" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="34" idHAL_FunctionsParameter="253" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="34" idHAL_FunctionsParameter="254" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="34" idHAL_FunctionsParameter="255" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="left side number" fid="35" idHAL_FunctionsParameter="256" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="36" idHAL_FunctionsParameter="257" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="37" idHAL_FunctionsParameter="258" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="38" idHAL_FunctionsParameter="259" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="39" idHAL_FunctionsParameter="260" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="35" idHAL_FunctionsParameter="261" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="36" idHAL_FunctionsParameter="262" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="37" idHAL_FunctionsParameter="263" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="38" idHAL_FunctionsParameter="264" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="39" idHAL_FunctionsParameter="265" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="35" idHAL_FunctionsParameter="266" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="36" idHAL_FunctionsParameter="267" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="37" idHAL_FunctionsParameter="268" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="38" idHAL_FunctionsParameter="269" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="39" idHAL_FunctionsParameter="270" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="35" idHAL_FunctionsParameter="271" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="36" idHAL_FunctionsParameter="272" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="37" idHAL_FunctionsParameter="273" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="38" idHAL_FunctionsParameter="274" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="39" idHAL_FunctionsParameter="275" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="rational vector" fid="27" idHAL_FunctionsParameter="276" idParameterClass="3" idParameterType="1" name="iv"/><HAL_FunctionsParameter descr="start index" fid="27" idHAL_FunctionsParameter="277" idParameterClass="1" idParameterType="2" name="iStart"/><HAL_FunctionsParameter descr="amount of values used" fid="27" idHAL_FunctionsParameter="278" idParameterClass="1" idParameterType="2" name="num"/><HAL_FunctionsParameter descr="value 1" fid="27" idHAL_FunctionsParameter="279" idParameterClass="1" idParameterType="1" name="v1"/><HAL_FunctionsParameter descr="value 2" fid="27" idHAL_FunctionsParameter="280" idParameterClass="1" idParameterType="1" name="v2"/><HAL_FunctionsParameter descr="value 3" fid="27" idHAL_FunctionsParameter="281" idParameterClass="1" idParameterType="1" name="v3"/><HAL_FunctionsParameter descr="vector a" fid="28" idHAL_FunctionsParameter="282" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector b" fid="28" idHAL_FunctionsParameter="283" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector a" fid="29" idHAL_FunctionsParameter="284" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector b" fid="29" idHAL_FunctionsParameter="285" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector c" fid="29" idHAL_FunctionsParameter="286" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector a" fid="30" idHAL_FunctionsParameter="287" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector a" fid="31" idHAL_FunctionsParameter="288" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector a" fid="32" idHAL_FunctionsParameter="289" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector a" fid="33" idHAL_FunctionsParameter="290" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector b" fid="30" idHAL_FunctionsParameter="291" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector b" fid="31" idHAL_FunctionsParameter="292" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector b" fid="32" idHAL_FunctionsParameter="293" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector b" fid="33" idHAL_FunctionsParameter="294" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector c" fid="30" idHAL_FunctionsParameter="295" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector c" fid="31" idHAL_FunctionsParameter="296" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector c" fid="32" idHAL_FunctionsParameter="297" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector c" fid="33" idHAL_FunctionsParameter="298" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="noisegate" fid="111" idHAL_FunctionsParameter="299" idParameterClass="3" idParameterType="11" name="ng"/><HAL_FunctionsParameter descr="time average value for the rms" fid="111" idHAL_FunctionsParameter="300" idParameterClass="1" idParameterType="1" name="rmsTAV"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="111" idHAL_FunctionsParameter="301" idParameterClass="1" idParameterType="1" name="AT"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="111" idHAL_FunctionsParameter="302" idParameterClass="1" idParameterType="1" name="RT"/><HAL_FunctionsParameter descr="noise cut off threshold" fid="111" idHAL_FunctionsParameter="303" idParameterClass="1" idParameterType="1" name="NT"/><HAL_FunctionsParameter descr="slope" fid="111" idHAL_FunctionsParameter="304" idParameterClass="1" idParameterType="1" name="NS"/><HAL_FunctionsParameter descr="expander" fid="112" idHAL_FunctionsParameter="305" idParameterClass="3" idParameterType="12" name="exp"/><HAL_FunctionsParameter descr="time average value for the rms" fid="112" idHAL_FunctionsParameter="306" idParameterClass="1" idParameterType="1" name="rmsTAV"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="112" idHAL_FunctionsParameter="307" idParameterClass="1" idParameterType="1" name="AT"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="112" idHAL_FunctionsParameter="308" idParameterClass="1" idParameterType="1" name="RT"/><HAL_FunctionsParameter descr="expander threshold" fid="112" idHAL_FunctionsParameter="309" idParameterClass="1" idParameterType="1" name="ET"/><HAL_FunctionsParameter descr="slope" fid="112" idHAL_FunctionsParameter="310" idParameterClass="1" idParameterType="1" name="ES"/><HAL_FunctionsParameter descr="compressor" fid="113" idHAL_FunctionsParameter="311" idParameterClass="3" idParameterType="13" name="comp"/><HAL_FunctionsParameter descr="limiter" fid="114" idHAL_FunctionsParameter="312" idParameterClass="3" idParameterType="14" name="lim"/><HAL_FunctionsParameter descr="time average value for the rms" fid="113" idHAL_FunctionsParameter="313" idParameterClass="1" idParameterType="1" name="rmsTAV"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="113" idHAL_FunctionsParameter="314" idParameterClass="1" idParameterType="1" name="AT"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="113" idHAL_FunctionsParameter="315" idParameterClass="1" idParameterType="1" name="RT"/><HAL_FunctionsParameter descr="compressor threshold" fid="113" idHAL_FunctionsParameter="316" idParameterClass="1" idParameterType="1" name="CT"/><HAL_FunctionsParameter descr="slope" fid="113" idHAL_FunctionsParameter="317" idParameterClass="1" idParameterType="1" name="CS"/><HAL_FunctionsParameter descr="attack value for the peak detection" fid="114" idHAL_FunctionsParameter="318" idParameterClass="1" idParameterType="1" name="ATpeak"/><HAL_FunctionsParameter descr="release value for the peak detection" fid="114" idHAL_FunctionsParameter="319" idParameterClass="1" idParameterType="1" name="RTpeak"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="114" idHAL_FunctionsParameter="320" idParameterClass="1" idParameterType="1" name="ATsmooth"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="114" idHAL_FunctionsParameter="321" idParameterClass="1" idParameterType="1" name="RTsmooth"/><HAL_FunctionsParameter descr="limiter threshold" fid="114" idHAL_FunctionsParameter="322" idParameterClass="1" idParameterType="1" name="LT"/><HAL_FunctionsParameter descr="slope" fid="114" idHAL_FunctionsParameter="323" idParameterClass="1" idParameterType="1" name="LS"/><HAL_FunctionsParameter descr="value 4" fid="20" idHAL_FunctionsParameter="324" idParameterClass="1" idParameterType="2" name="v4"/><HAL_FunctionsParameter descr="value 4" fid="27" idHAL_FunctionsParameter="325" idParameterClass="1" idParameterType="1" name="v4"/><HAL_FunctionsParameter descr="input" fid="115" idHAL_FunctionsParameter="326" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="noisegate" fid="115" idHAL_FunctionsParameter="327" idParameterClass="3" idParameterType="11" name="ng"/><HAL_FunctionsParameter descr="output" fid="115" idHAL_FunctionsParameter="328" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="input" fid="116" idHAL_FunctionsParameter="329" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="117" idHAL_FunctionsParameter="330" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="118" idHAL_FunctionsParameter="331" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="expander" fid="116" idHAL_FunctionsParameter="332" idParameterClass="3" idParameterType="12" name="exp"/><HAL_FunctionsParameter descr="compressor" fid="117" idHAL_FunctionsParameter="333" idParameterClass="3" idParameterType="13" name="comp"/><HAL_FunctionsParameter descr="limiter" fid="118" idHAL_FunctionsParameter="334" idParameterClass="3" idParameterType="14" name="lim"/><HAL_FunctionsParameter descr="output" fid="116" idHAL_FunctionsParameter="335" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="output" fid="117" idHAL_FunctionsParameter="336" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="output" fid="118" idHAL_FunctionsParameter="337" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="338" idParameterClass="1" idParameterType="4" name="v4"/><HAL_FunctionsParameter descr="the string at its end the other string is concated" fid="7" idHAL_FunctionsParameter="339" idParameterClass="3" idParameterType="3" name="s1"/><HAL_FunctionsParameter descr="index of the string 1" fid="7" idHAL_FunctionsParameter="340" idParameterClass="1" idParameterType="2" name="i1"/><HAL_FunctionsParameter descr="the concat string" fid="7" idHAL_FunctionsParameter="341" idParameterClass="3" idParameterType="3" name="s2"/><HAL_FunctionsParameter descr="index of the string 2" fid="7" idHAL_FunctionsParameter="342" idParameterClass="1" idParameterType="2" name="i2"/><HAL_FunctionsParameter descr="the string" fid="8" idHAL_FunctionsParameter="343" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="the string" fid="9" idHAL_FunctionsParameter="344" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="8" idHAL_FunctionsParameter="345" idParameterClass="1" idParameterType="2" name="sIndex"/><HAL_FunctionsParameter descr="index of the string at the array" fid="9" idHAL_FunctionsParameter="346" idParameterClass="1" idParameterType="2" name="sIndex"/><HAL_FunctionsParameter descr="rational vector" fid="8" idHAL_FunctionsParameter="347" idParameterClass="3" idParameterType="1" name="r"/><HAL_FunctionsParameter descr="rational vector index" fid="8" idHAL_FunctionsParameter="348" idParameterClass="1" idParameterType="2" name="rIndx"/><HAL_FunctionsParameter descr="integer vector" fid="9" idHAL_FunctionsParameter="349" idParameterClass="3" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="integer vector indx" fid="9" idHAL_FunctionsParameter="350" idParameterClass="1" idParameterType="2" name="iIndex"/><HAL_FunctionsParameter descr="the source string" fid="10" idHAL_FunctionsParameter="351" idParameterClass="3" idParameterType="3" name="s1"/><HAL_FunctionsParameter descr="index of the string 1" fid="10" idHAL_FunctionsParameter="352" idParameterClass="1" idParameterType="2" name="i1"/><HAL_FunctionsParameter descr="the destination string" fid="10" idHAL_FunctionsParameter="353" idParameterClass="3" idParameterType="3" name="s2"/><HAL_FunctionsParameter descr="index of the string 2" fid="10" idHAL_FunctionsParameter="354" idParameterClass="1" idParameterType="2" name="i2"/><HAL_FunctionsParameter descr="the delay" fid="151" idHAL_FunctionsParameter="355" idParameterClass="3" idParameterType="20" name="d"/><HAL_FunctionsParameter descr="number of samples which correspond to the delay time (Tdelay = N * Ta)" fid="151" idHAL_FunctionsParameter="356" idParameterClass="3" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="the index at the vector of N" fid="151" idHAL_FunctionsParameter="357" idParameterClass="3" idParameterType="2" name="Nindex"/><HAL_FunctionsParameter descr="if not zero the function waits for a new sample frame" fid="62" idHAL_FunctionsParameter="359" idParameterClass="1" idParameterType="2" name="waitForNewFrame"/><HAL_FunctionsParameter descr="biquad cascade" fid="105" idHAL_FunctionsParameter="360" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="index at the cascade" fid="105" idHAL_FunctionsParameter="361" idParameterClass="3" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="a0 coefficient" fid="105" idHAL_FunctionsParameter="362" idParameterClass="3" idParameterType="1" name="a0"/><HAL_FunctionsParameter descr="a1 coefficient" fid="105" idHAL_FunctionsParameter="363" idParameterClass="3" idParameterType="1" name="a1"/><HAL_FunctionsParameter descr="a2 coefficient" fid="105" idHAL_FunctionsParameter="364" idParameterClass="3" idParameterType="1" name="a2"/><HAL_FunctionsParameter descr="b1 coefficient" fid="105" idHAL_FunctionsParameter="365" idParameterClass="3" idParameterType="1" name="b1"/><HAL_FunctionsParameter descr="b2 coefficient" fid="105" idHAL_FunctionsParameter="366" idParameterClass="3" idParameterType="1" name="b2"/><HAL_FunctionsParameter descr="display" fid="213" idHAL_FunctionsParameter="367" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="display index" fid="213" idHAL_FunctionsParameter="368" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="amount of characters per line" fid="213" idHAL_FunctionsParameter="369" idParameterClass="1" idParameterType="2" name="charsPerLine"/><HAL_FunctionsParameter descr="amout of characters-lines" fid="213" idHAL_FunctionsParameter="370" idParameterClass="1" idParameterType="2" name="lines"/></HAL_FunctionsParameter_List><HAL_MessageParameter_List><HAL_MessageParameter basicTypeID="2" descr="number of the global variables" idHAL_MessageParameter="1" isArray="False" msgID="10" name="globalVariableNumber" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="number of the local variables" idHAL_MessageParameter="2" isArray="False" msgID="10" name="localVariableNumber" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="number of the instructions" idHAL_MessageParameter="3" isArray="False" msgID="10" name="instructionNumber" positionIndex="2"/><HAL_MessageParameter basicTypeID="2" descr="the index of the variable" idHAL_MessageParameter="9" isArray="False" msgID="11" name="index" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="type id of the variable" idHAL_MessageParameter="10" isArray="False" msgID="11" name="varTypeID" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="number of variables" idHAL_MessageParameter="11" isArray="False" msgID="11" name="num" positionIndex="2"/><HAL_MessageParameter basicTypeID="2" descr="index of the function call" idHAL_MessageParameter="12" isArray="False" msgID="12" name="index" positionIndex="0"/><HAL_MessageParameter basicTypeID="4" descr="function byte code" idHAL_MessageParameter="13" isArray="True" msgID="12" name="fbc" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="global variable index" idHAL_MessageParameter="14" isArray="False" msgID="23" name="gIndex" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="amount of data elements" idHAL_MessageParameter="15" isArray="False" msgID="23" name="dataElements" positionIndex="1"/></HAL_MessageParameter_List><HAL_VariableDefinition_List><HAL_VariableDefinition VariableID="1" description="a rational number" idHAL_VariableDefinition="1" varName="rational"/><HAL_VariableDefinition VariableID="2" description="a integer number" idHAL_VariableDefinition="2" varName="integer"/><HAL_VariableDefinition VariableID="3" description="a string" idHAL_VariableDefinition="3" varName="string"/><HAL_VariableDefinition VariableID="10" description="a biquad filter" idHAL_VariableDefinition="4" varName="biquad"/><HAL_VariableDefinition VariableID="20" description="a delay" idHAL_VariableDefinition="5" varName="delay"/><HAL_VariableDefinition VariableID="30" description="FFT or IFFT sturcture" idHAL_VariableDefinition="6" varName="FFT"/><HAL_VariableDefinition VariableID="4" description="a complex number" idHAL_VariableDefinition="7" varName="complex"/><HAL_VariableDefinition VariableID="101" description="button UI" idHAL_VariableDefinition="8" varName="button"/><HAL_VariableDefinition VariableID="100" description="panel UI" idHAL_VariableDefinition="9" varName="panel"/><HAL_VariableDefinition VariableID="102" description="led UI" idHAL_VariableDefinition="10" varName="led"/><HAL_VariableDefinition VariableID="103" description="display UI" idHAL_VariableDefinition="11" varName="display"/><HAL_VariableDefinition VariableID="11" description="a noisegate" idHAL_VariableDefinition="12" varName="noisegate"/><HAL_VariableDefinition VariableID="12" description="a expander" idHAL_VariableDefinition="13" varName="expander"/><HAL_VariableDefinition VariableID="13" description="a compressor" idHAL_VariableDefinition="14" varName="compressor"/><HAL_VariableDefinition VariableID="14" description="a limiter" idHAL_VariableDefinition="15" varName="limiter"/><HAL_VariableDefinition VariableID="66" description="six six six" idHAL_VariableDefinition="16" varName="sixxx"/></HAL_VariableDefinition_List><HAL_Function_List><HAL_Function descr="a &lt; b ? CF = 1 : CF = 0" fid="40" idHAL_Function="17" name="compareIntegerLess"/><HAL_Function descr="a &gt; b ? CF = 1 : CF = 0" fid="41" idHAL_Function="18" name="compareIntegerMore"/><HAL_Function descr="a == b ? CF = 1 : CF = 0" fid="42" idHAL_Function="19" name="compareIntegerEqual"/><HAL_Function descr="a != b ? CF = 1 : CF = 0" fid="43" idHAL_Function="20" name="compareIntegerNEqual"/><HAL_Function descr="a &lt;= b ? CF = 1 : CF = 0" fid="44" idHAL_Function="21" name="compareIntegerLessEqual"/><HAL_Function descr="a &gt;= b ? CF = 1 : CF = 0" fid="45" idHAL_Function="22" name="compareIntegerMoreEqual"/><HAL_Function descr="jumps n instructions" fid="50" idHAL_Function="23" name="jump"/><HAL_Function descr="jumps if the carry flag is set n instructions" fid="51" idHAL_Function="24" name="jumpCF"/><HAL_Function descr="jumps if the carry flag is not set n instructions" fid="52" idHAL_Function="25" name="jumpNCF"/><HAL_Function descr="reading a sample from an input" fid="60" idHAL_Function="26" name="readSample"/><HAL_Function descr="writes a sample to a output" fid="61" idHAL_Function="27" name="writeSample"/><HAL_Function descr="generate a test signal, witch can be used to meassure performance" fid="3" idHAL_Function="28" name="genTestSignal"/><HAL_Function descr="inits a biquad filter as an high pass filter" fid="100" idHAL_Function="29" name="initBiquadAsHP"/><HAL_Function descr="inits a biquad filter as a low pass filter" fid="101" idHAL_Function="32" name="initBiquadAsLP"/><HAL_Function descr="convolute biquad with an input and generate an output" fid="110" idHAL_Function="33" name="convoluteBiquad"/><HAL_Function descr="stream a vector of samples in and a vector of exactly the same size out " fid="150" idHAL_Function="34" name="calcDelay"/><HAL_Function descr="inits an array as an &quot;von Hann&quot; window" fid="120" idHAL_Function="36" name="initHannWindow"/><HAL_Function descr="init FFT structure as real input FFT" fid="130" idHAL_Function="37" name="initRFFT"/><HAL_Function descr="init inverse FFT structure" fid="131" idHAL_Function="38" name="initIFFT"/><HAL_Function descr="reading a frames of sample from an input" fid="62" idHAL_Function="39" name="readSampleFrame"/><HAL_Function descr="writes a frame of samples to a output" fid="63" idHAL_Function="40" name="writeSampleFrame"/><HAL_Function descr="processes the IFFT" fid="133" idHAL_Function="43" name="processIFFT"/><HAL_Function descr="processes the real input FFT" fid="132" idHAL_Function="44" name="processRFFT"/><HAL_Function descr="inits a panel" fid="201" idHAL_Function="49" name="uiInitPanel"/><HAL_Function descr="inits a button" fid="202" idHAL_Function="50" name="uiInitButton"/><HAL_Function descr="inits a display" fid="203" idHAL_Function="51" name="uiInitDisplay"/><HAL_Function descr="inits a LED" fid="204" idHAL_Function="52" name="uiInitLED"/><HAL_Function descr="resets the size of a string" fid="5" idHAL_Function="53" name="setStringSize"/><HAL_Function descr="set the string" fid="6" idHAL_Function="54" name="setStringValues"/><HAL_Function descr="sets the dimension of a UI" fid="200" idHAL_Function="55" name="uiSetDim"/><HAL_Function descr="if the button was pressed the CF is set" fid="210" idHAL_Function="56" name="uiCheckButtonPressed"/><HAL_Function descr="set the LED state" fid="211" idHAL_Function="57" name="uiSetLED"/><HAL_Function descr="sets the carry flag" fid="55" idHAL_Function="58" name="setCF"/><HAL_Function descr="set the text of a display" fid="212" idHAL_Function="59" name="uiSetDisplay"/><HAL_Function descr="a = values" fid="20" idHAL_Function="60" name="assignConstInteger"/><HAL_Function descr="c = a + b" fid="22" idHAL_Function="61" name="addInteger"/><HAL_Function descr="c = a - b" fid="23" idHAL_Function="62" name="subInteger"/><HAL_Function descr="c = a * b" fid="24" idHAL_Function="63" name="mulInteger"/><HAL_Function descr="c = a / b" fid="25" idHAL_Function="64" name="divInteger"/><HAL_Function descr="a = b" fid="21" idHAL_Function="65" name="assignInteger"/><HAL_Function descr="c = mod(a,b)" fid="26" idHAL_Function="66" name="modInteger"/><HAL_Function descr="updates a global variable" fid="56" idHAL_Function="67" name="update"/><HAL_Function descr="inits a biquad filter as peak filter" fid="102" idHAL_Function="68" name="initBiquadAsPeakFilter"/><HAL_Function descr="inits a biquad filter as low ferquency shelving filter" fid="103" idHAL_Function="71" name="initBiquadAsLowFreqShelvFilter"/><HAL_Function descr="inits a biquad filter as high ferquency shelving filter" fid="104" idHAL_Function="72" name="initBiquadAsHighFreqShelvFilter"/><HAL_Function descr="a = values" fid="27" idHAL_Function="73" name="assignConstRational"/><HAL_Function descr="a = b" fid="28" idHAL_Function="74" name="assignRational"/><HAL_Function descr="c = a + b" fid="29" idHAL_Function="75" name="addRational"/><HAL_Function descr="c = a - b" fid="30" idHAL_Function="76" name="subRational"/><HAL_Function descr="c = a * b" fid="31" idHAL_Function="77" name="mulRational"/><HAL_Function descr="c = a / b" fid="32" idHAL_Function="78" name="divRational"/><HAL_Function descr="c = mod(a,b)" fid="33" idHAL_Function="79" name="modRational"/><HAL_Function descr="a &lt; b ? CF = 1 : CF = 0" fid="34" idHAL_Function="80" name="compareRationalLess"/><HAL_Function descr="a &gt; b ? CF = 1 : CF = 0" fid="35" idHAL_Function="81" name="compareRationalMore"/><HAL_Function descr="a == b ? CF = 1 : CF = 0" fid="36" idHAL_Function="82" name="compareRationalEqual"/><HAL_Function descr="a != b ? CF = 1 : CF = 0" fid="37" idHAL_Function="83" name="compareRationalNEqual"/><HAL_Function descr="a &lt;= b ? CF = 1 : CF = 0" fid="38" idHAL_Function="84" name="compareRationalLessEqual"/><HAL_Function descr="a &gt;= b ? CF = 1 : CF = 0" fid="39" idHAL_Function="85" name="compareRationalMoreEqual"/><HAL_Function descr="initialize a noisegate" fid="111" idHAL_Function="86" name="initNoisegate"/><HAL_Function descr="initialize a expander" fid="112" idHAL_Function="87" name="initExpander"/><HAL_Function descr="initialize a compressor" fid="113" idHAL_Function="88" name="initCompressor"/><HAL_Function descr="initialize a limiter" fid="114" idHAL_Function="89" name="initLimiter"/><HAL_Function descr="sends a stream of samples through a noisegate (y = noisegate(x))" fid="115" idHAL_Function="90" name="calcNoisegate"/><HAL_Function descr="sends a stream of samples through a expander (y = expander(x))" fid="116" idHAL_Function="91" name="calcExpander"/><HAL_Function descr="sends a stream of samples through a compressor (y = compressor(x))" fid="117" idHAL_Function="92" name="calcCompressor"/><HAL_Function descr="sends a stream of samples through a limiter (y = limiter(x))" fid="118" idHAL_Function="93" name="calcLimiter"/><HAL_Function descr="concat two strings" fid="7" idHAL_Function="94" name="concatStrings"/><HAL_Function descr="converts a rational to a string" fid="8" idHAL_Function="95" name="rationalToString"/><HAL_Function descr="converts an integer to a string" fid="9" idHAL_Function="96" name="integerToString"/><HAL_Function descr="assigns a string to an other" fid="10" idHAL_Function="97" name="assignString"/><HAL_Function descr="inits the delay" fid="151" idHAL_Function="98" name="initDelay"/><HAL_Function descr="inits a biquad of h(z) = y(z)/x(z) = (a0*z0 + a1*z-1+ a2*z-2) / (1*z0 + b1*z-1+ b2*z-2)" fid="105" idHAL_Function="99" name="initBiquad"/><HAL_Function descr="sets the dimension of the text display" fid="213" idHAL_Function="100" name="uiSetDisplayTextDim"/></HAL_Function_List><HAL_MessageType_List><HAL_MessageType descr="acknowledge" idHAL_MessageType="1" msgID="1" name="ACK"/><HAL_MessageType descr="not acknowledge" idHAL_MessageType="2" msgID="2" name="NACK"/><HAL_MessageType descr="start sending a program" idHAL_MessageType="3" msgID="10" name="startPrg"/><HAL_MessageType descr="sends a variable" idHAL_MessageType="4" msgID="11" name="sendVariable"/><HAL_MessageType descr="sends an instruction" idHAL_MessageType="5" msgID="12" name="sendInstruction"/><HAL_MessageType descr="sings that the program transmission has completed" idHAL_MessageType="6" msgID="13" name="endPrg"/><HAL_MessageType descr="stops the AP" idHAL_MessageType="7" msgID="20" name="stop"/><HAL_MessageType descr="the AP executes one instruction" idHAL_MessageType="8" msgID="21" name="step"/><HAL_MessageType descr="the AP runs the program" idHAL_MessageType="9" msgID="22" name="run"/><HAL_MessageType descr="a variable going to be updated" idHAL_MessageType="10" msgID="23" name="updateVariable"/><HAL_MessageType descr="a AP is going to be logged in to the system" idHAL_MessageType="11" msgID="30" name="login"/><HAL_MessageType descr="a AP is going to be logged out of the system" idHAL_MessageType="12" msgID="31" name="logout"/></HAL_MessageType_List><HAL_MessageProcess_List><HAL_MessageProcess descr="log in the AP to the system" idHAL_MessageProcess="1" isRX="False" msgProcID="10" name="login">TX_login [handle=none]() {
	declare	recv	Node;
	declare	mNum	mNum;

	recv = ALL;
	loopAll drivers[driver] {
		mNum = getNewMsgNum();
		driver&gt;&gt;send(login(recv,mNum));
	}
return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handle login calls" idHAL_MessageProcess="2" isRX="True" msgProcID="30" name="login">RX_login [handle=login]() {
	declare	sender	Node;
	declare	driver	Driver;
	declare	mNum	mNum;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();

	if (!addNode(sender, driver)) {
		return driver&gt;&gt;send(login(sender,mNum));
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="runs the audio-processor" idHAL_MessageProcess="3" isRX="False" msgProcID="20" name="run">TX_run [handle=none](Node dest) {
	declare	driver	Driver;
	declare	sender	Node;
	declare	mNum	mNum;

	sender = getSelfSenderID();
	if (dest != ALL) {
		mNum = getNewMsgNum();
		driver = getDriver(dest);
		driver&gt;&gt;send(run(sender,mNum));
		return waitACK(mNum);
	}

	loopAll drivers[drv] {
		mNum = getNewMsgNum();
		drv&gt;&gt;send(run(sender,mNum));
		if (waitACK(mNum)) {
			return -1;
		}
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handles the run command" idHAL_MessageProcess="4" isRX="True" msgProcID="22" name="run">RX_run [handle=run]() {
	declare	sender			Node;
	declare	driver			Driver;
	declare	mNum			mNum;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();

	if (!runAP()) {
		return driver&gt;&gt;send(ACK(sender,mNum));
	} else {
		return driver&gt;&gt;send(NACK(sender,mNum));
	}
}
</HAL_MessageProcess><HAL_MessageProcess descr="log the AP out of the system" idHAL_MessageProcess="5" isRX="False" msgProcID="0" name="logout">TX_logout [handle=none]() {
	declare	recv	Node;
	declare	mNum	mNum;

	recv = ALL;
	loopAll drivers[driver] {
		mNum = getNewMsgNum();
		driver&gt;&gt;send(logout(recv,mNum));
	}
return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handle login calls" idHAL_MessageProcess="6" isRX="True" msgProcID="31" name="logout">RX_logout [handle=logout]() {
	declare	sender	Node;
	
	sender = getSender();

	removeNode(sender);
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="updates a global variable at diffrent systems" idHAL_MessageProcess="9" isRX="False" msgProcID="0" name="updateVariable">TX_updateVariable [handle=none](VarIndex vi) {
	declare	mNum	mNum;
	declare	apV		Variable;

	apV = getVariableByIndex(vi);

	loopAll nodes[node] {
		if (getNodeIDfromNode(node) != getSelfSenderID()) {
			mNum = getNewMsgNum();
			apV&gt;&gt;call(sendUpdate(getVariableData(apV),getDriverFromNode(node),ALL,mNum,vi));
			if (waitACK(mNum)) {
				return -1;
			}
		}
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="updates a global variable at diffrent systems" idHAL_MessageProcess="10" isRX="True" msgProcID="23" name="updateVariable">RX_updateVariable [handle=updateVariable]() {
	declare	sender			Node;
	declare	driver			Driver;
	declare	mNum			mNum;
	declare	apV				Variable;
	declare	gIndex			int;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();
	gIndex = getMsgDataToInt(0);

	apV = getVariableByIndex(gIndex);
	if (!apV) {
		return -1;
	}

	apV&gt;&gt;call(recvUpdate(getVariableData(apV),getMsgDataRef()));

	return driver&gt;&gt;send(ACK(sender,mNum));
}</HAL_MessageProcess></HAL_MessageProcess_List><Includes_List><Includes idIncludes="8" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="9" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="10" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="12" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="13" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="14" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="15" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="16" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="17" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="18" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="19" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="23" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="24" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="25" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="26" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="27" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="28" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="29" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="30" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="31" includefile="-1" lib="string.h" syslib=""/><Includes idIncludes="32" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="33" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="34" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="35" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="36" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="37" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="42" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="43" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="44" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="45" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="46" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="47" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="48" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="49" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="50" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="51" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="52" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="53" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="54" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="55" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="56" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="57" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="58" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="59" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="60" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="61" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="62" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="63" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="64" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="65" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="66" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="67" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="68" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="69" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="70" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="71" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="72" includefile="AP" lib="" syslib="0"/><Includes idIncludes="73" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="74" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="75" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="77" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="78" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="79" includefile="sndfile.h" lib="sndfile-1" syslib="0"/><Includes idIncludes="84" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="85" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="86" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="87" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="88" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="89" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="90" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="91" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="92" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="93" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="95" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="96" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="98" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="99" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="105" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="116" includefile="fftw3.h" lib="libfftw3f-3" syslib="0"/><Includes idIncludes="117" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="120" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="129" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="132" includefile="sndfile.h" lib="sndfile-1" syslib="0"/><Includes idIncludes="133" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="134" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="135" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="136" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="140" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="141" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="142" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="143" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="148" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="149" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="150" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="151" includefile="sru21369.h" lib="" syslib="1"/><Includes idIncludes="152" includefile="cdef21369.h" lib="" syslib="1"/><Includes idIncludes="153" includefile="def21369.h" lib="" syslib="1"/><Includes idIncludes="154" includefile="signal.h" lib="" syslib="1"/><Includes idIncludes="155" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="156" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="160" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="161" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="162" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="163" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="164" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="166" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="167" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="169" includefile="sndfile.h" lib="sndfile-1" syslib="1"/><Includes idIncludes="170" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="171" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="172" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="173" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="174" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="177" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="178" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="179" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="180" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="185" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="188" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="189" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="190" includefile="winsock2.h" lib="ws2_32" syslib="1"/><Includes idIncludes="191" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="192" includefile="ws2tcpip.h" lib="" syslib="1"/><Includes idIncludes="193" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="195" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="196" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="197" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="198" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="199" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="200" includefile="winsock2.h" lib="ws2_32" syslib="1"/><Includes idIncludes="201" includefile="ws2tcpip.h" lib="" syslib="1"/><Includes idIncludes="203" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="204" includefile="semaphore.h" lib="" syslib="1"/><Includes idIncludes="205" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="206" includefile="gtk/gtk.h" lib="gtk-win32-2.0" syslib="1"/><Includes idIncludes="207" includefile="glib.h" lib="glib-2.0" syslib="1"/><Includes idIncludes="209" includefile="glib-object.h" lib="gobject-2.0" syslib="1"/><Includes idIncludes="210" includefile="cairo.h" lib="cairo" syslib="1"/><Includes idIncludes="211" includefile="pango/pango.h" lib="pango-1.0" syslib="1"/><Includes idIncludes="212" includefile="semaphore.h" lib="pthread" syslib="1"/><Includes idIncludes="213" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="219" includefile="gdk/gdk.h" lib="gdk-win32-2.0" syslib="1"/><Includes idIncludes="224" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="225" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="230" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="231" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="232" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="233" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="235" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="236" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="237" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="238" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="239" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="240" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="242" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="243" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="244" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="245" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="246" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="247" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="248" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="249" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="250" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="251" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="252" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="253" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="254" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="255" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="256" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="257" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="258" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="265" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="266" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="267" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="268" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="269" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="270" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="271" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="272" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="273" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="274" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="275" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="276" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="277" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="278" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="279" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="280" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="281" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="282" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="283" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="284" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="285" includefile="string.h" lib="" syslib="0"/><Includes idIncludes="286" includefile="sru21369.h" lib="" syslib="1"/><Includes idIncludes="287" includefile="cdef21369.h" lib="" syslib="1"/><Includes idIncludes="288" includefile="def21369.h" lib="" syslib="1"/><Includes idIncludes="289" includefile="signal.h" lib="" syslib="1"/><Includes idIncludes="290" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="291" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="292" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="293" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="294" includefile="msp430x16x.h" lib="" syslib="1"/><Includes idIncludes="295" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="296" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="297" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="298" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="299" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="300" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="301" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="302" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="303" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="304" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="305" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="306" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="307" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="308" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="309" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="310" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="311" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="312" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="313" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="314" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="315" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="316" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="317" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="318" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="319" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="320" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="321" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="322" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="323" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="324" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="325" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="326" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="327" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="328" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="329" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="330" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="331" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="332" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="333" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="334" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="335" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="336" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="337" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="338" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="339" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="340" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="341" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="342" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="343" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="344" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="345" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="346" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="347" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="348" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="349" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="350" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="351" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="353" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="354" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="355" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="356" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="357" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="358" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="359" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="360" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="361" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="362" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="363" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="365" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="366" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="367" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="368" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="369" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="370" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="371" includefile="portaudio.h" lib="portaudio" syslib="1"/><Includes idIncludes="372" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="373" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="374" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="375" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="376" includefile="semaphore.h" lib="" syslib="1"/><Includes idIncludes="377" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="378" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="379" includefile="unistd.h" lib="" syslib="1"/><Includes idIncludes="380" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="381" includefile="errno.h" lib="" syslib="1"/><Includes idIncludes="382" includefile="time.h" lib="" syslib="1"/><Includes idIncludes="383" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="384" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="385" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="386" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="387" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="388" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="389" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="390" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="391" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="392" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="393" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="394" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="395" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="396" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="397" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="398" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="399" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="400" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="401" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="402" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="403" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="404" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="405" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="406" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="407" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="408" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="409" includefile="semaphore.h" lib="" syslib="1"/><Includes idIncludes="410" includefile="errno.h" lib="" syslib="1"/><Includes idIncludes="411" includefile="ctype.h" lib="" syslib="1"/><Includes idIncludes="412" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="413" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="414" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="415" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="416" includefile="AP.h" lib="" syslib="0"/></Includes_List><IncludeList_List><IncludeList idCode="10" idIncludes="8"/><IncludeList idCode="11" idIncludes="9"/><IncludeList idCode="12" idIncludes="10"/><IncludeList idCode="14" idIncludes="12"/><IncludeList idCode="15" idIncludes="13"/><IncludeList idCode="16" idIncludes="14"/><IncludeList idCode="17" idIncludes="15"/><IncludeList idCode="18" idIncludes="16"/><IncludeList idCode="20" idIncludes="17"/><IncludeList idCode="21" idIncludes="18"/><IncludeList idCode="22" idIncludes="19"/><IncludeList idCode="26" idIncludes="23"/><IncludeList idCode="27" idIncludes="24"/><IncludeList idCode="28" idIncludes="25"/><IncludeList idCode="29" idIncludes="26"/><IncludeList idCode="30" idIncludes="27"/><IncludeList idCode="31" idIncludes="28"/><IncludeList idCode="32" idIncludes="29"/><IncludeList idCode="33" idIncludes="30"/><IncludeList idCode="33" idIncludes="31"/><IncludeList idCode="34" idIncludes="32"/><IncludeList idCode="34" idIncludes="33"/><IncludeList idCode="35" idIncludes="34"/><IncludeList idCode="35" idIncludes="35"/><IncludeList idCode="36" idIncludes="36"/><IncludeList idCode="36" idIncludes="37"/><IncludeList idCode="41" idIncludes="42"/><IncludeList idCode="41" idIncludes="43"/><IncludeList idCode="42" idIncludes="44"/><IncludeList idCode="42" idIncludes="45"/><IncludeList idCode="43" idIncludes="46"/><IncludeList idCode="43" idIncludes="47"/><IncludeList idCode="44" idIncludes="48"/><IncludeList idCode="44" idIncludes="49"/><IncludeList idCode="45" idIncludes="50"/><IncludeList idCode="45" idIncludes="51"/><IncludeList idCode="46" idIncludes="52"/><IncludeList idCode="46" idIncludes="53"/><IncludeList idCode="47" idIncludes="54"/><IncludeList idCode="47" idIncludes="55"/><IncludeList idCode="48" idIncludes="56"/><IncludeList idCode="48" idIncludes="57"/><IncludeList idCode="49" idIncludes="58"/><IncludeList idCode="49" idIncludes="59"/><IncludeList idCode="50" idIncludes="60"/><IncludeList idCode="50" idIncludes="61"/><IncludeList idCode="51" idIncludes="62"/><IncludeList idCode="51" idIncludes="63"/><IncludeList idCode="52" idIncludes="64"/><IncludeList idCode="53" idIncludes="65"/><IncludeList idCode="54" idIncludes="66"/><IncludeList idCode="54" idIncludes="67"/><IncludeList idCode="55" idIncludes="68"/><IncludeList idCode="55" idIncludes="69"/><IncludeList idCode="56" idIncludes="70"/><IncludeList idCode="58" idIncludes="71"/><IncludeList idCode="59" idIncludes="72"/><IncludeList idCode="60" idIncludes="73"/><IncludeList idCode="61" idIncludes="74"/><IncludeList idCode="62" idIncludes="75"/><IncludeList idCode="64" idIncludes="77"/><IncludeList idCode="65" idIncludes="78"/><IncludeList idCode="66" idIncludes="79"/><IncludeList idCode="71" idIncludes="84"/><IncludeList idCode="72" idIncludes="85"/><IncludeList idCode="73" idIncludes="86"/><IncludeList idCode="74" idIncludes="87"/><IncludeList idCode="75" idIncludes="88"/><IncludeList idCode="76" idIncludes="89"/><IncludeList idCode="77" idIncludes="90"/><IncludeList idCode="78" idIncludes="91"/><IncludeList idCode="79" idIncludes="92"/><IncludeList idCode="80" idIncludes="93"/><IncludeList idCode="81" idIncludes="95"/><IncludeList idCode="82" idIncludes="96"/><IncludeList idCode="84" idIncludes="98"/><IncludeList idCode="85" idIncludes="99"/><IncludeList idCode="91" idIncludes="105"/><IncludeList idCode="98" idIncludes="116"/><IncludeList idCode="99" idIncludes="117"/><IncludeList idCode="102" idIncludes="120"/><IncludeList idCode="111" idIncludes="129"/><IncludeList idCode="101" idIncludes="132"/><IncludeList idCode="101" idIncludes="133"/><IncludeList idCode="114" idIncludes="134"/><IncludeList idCode="115" idIncludes="135"/><IncludeList idCode="116" idIncludes="136"/><IncludeList idCode="120" idIncludes="140"/><IncludeList idCode="121" idIncludes="141"/><IncludeList idCode="122" idIncludes="142"/><IncludeList idCode="123" idIncludes="143"/><IncludeList idCode="125" idIncludes="148"/><IncludeList idCode="126" idIncludes="149"/><IncludeList idCode="125" idIncludes="150"/><IncludeList idCode="124" idIncludes="151"/><IncludeList idCode="124" idIncludes="152"/><IncludeList idCode="124" idIncludes="153"/><IncludeList idCode="124" idIncludes="154"/><IncludeList idCode="124" idIncludes="155"/><IncludeList idCode="127" idIncludes="156"/><IncludeList idCode="131" idIncludes="160"/><IncludeList idCode="132" idIncludes="161"/><IncludeList idCode="133" idIncludes="162"/><IncludeList idCode="134" idIncludes="163"/><IncludeList idCode="135" idIncludes="164"/><IncludeList idCode="137" idIncludes="166"/><IncludeList idCode="138" idIncludes="167"/><IncludeList idCode="140" idIncludes="169"/><IncludeList idCode="140" idIncludes="170"/><IncludeList idCode="141" idIncludes="171"/><IncludeList idCode="142" idIncludes="172"/><IncludeList idCode="143" idIncludes="173"/><IncludeList idCode="144" idIncludes="174"/><IncludeList idCode="145" idIncludes="177"/><IncludeList idCode="146" idIncludes="178"/><IncludeList idCode="147" idIncludes="179"/><IncludeList idCode="145" idIncludes="180"/><IncludeList idCode="152" idIncludes="185"/><IncludeList idCode="154" idIncludes="188"/><IncludeList idCode="155" idIncludes="189"/><IncludeList idCode="155" idIncludes="190"/><IncludeList idCode="155" idIncludes="191"/><IncludeList idCode="155" idIncludes="192"/><IncludeList idCode="155" idIncludes="193"/><IncludeList idCode="157" idIncludes="195"/><IncludeList idCode="158" idIncludes="196"/><IncludeList idCode="159" idIncludes="197"/><IncludeList idCode="155" idIncludes="198"/><IncludeList idCode="160" idIncludes="199"/><IncludeList idCode="152" idIncludes="200"/><IncludeList idCode="152" idIncludes="201"/><IncludeList idCode="161" idIncludes="203"/><IncludeList idCode="161" idIncludes="204"/><IncludeList idCode="152" idIncludes="205"/><IncludeList idCode="162" idIncludes="206"/><IncludeList idCode="162" idIncludes="207"/><IncludeList idCode="162" idIncludes="209"/><IncludeList idCode="162" idIncludes="210"/><IncludeList idCode="162" idIncludes="211"/><IncludeList idCode="162" idIncludes="212"/><IncludeList idCode="162" idIncludes="213"/><IncludeList idCode="162" idIncludes="219"/><IncludeList idCode="162" idIncludes="224"/><IncludeList idCode="172" idIncludes="225"/><IncludeList idCode="177" idIncludes="230"/><IncludeList idCode="178" idIncludes="231"/><IncludeList idCode="179" idIncludes="232"/><IncludeList idCode="180" idIncludes="233"/><IncludeList idCode="182" idIncludes="235"/><IncludeList idCode="183" idIncludes="236"/><IncludeList idCode="184" idIncludes="237"/><IncludeList idCode="185" idIncludes="238"/><IncludeList idCode="186" idIncludes="239"/><IncludeList idCode="187" idIncludes="240"/><IncludeList idCode="189" idIncludes="242"/><IncludeList idCode="190" idIncludes="243"/><IncludeList idCode="191" idIncludes="244"/><IncludeList idCode="192" idIncludes="245"/><IncludeList idCode="193" idIncludes="246"/><IncludeList idCode="194" idIncludes="247"/><IncludeList idCode="195" idIncludes="248"/><IncludeList idCode="196" idIncludes="249"/><IncludeList idCode="1" idIncludes="250"/><IncludeList idCode="1" idIncludes="251"/><IncludeList idCode="197" idIncludes="252"/><IncludeList idCode="198" idIncludes="253"/><IncludeList idCode="199" idIncludes="254"/><IncludeList idCode="200" idIncludes="255"/><IncludeList idCode="201" idIncludes="256"/><IncludeList idCode="202" idIncludes="257"/><IncludeList idCode="203" idIncludes="258"/><IncludeList idCode="210" idIncludes="265"/><IncludeList idCode="211" idIncludes="266"/><IncludeList idCode="212" idIncludes="267"/><IncludeList idCode="213" idIncludes="268"/><IncludeList idCode="214" idIncludes="269"/><IncludeList idCode="215" idIncludes="270"/><IncludeList idCode="216" idIncludes="271"/><IncludeList idCode="219" idIncludes="272"/><IncludeList idCode="220" idIncludes="273"/><IncludeList idCode="221" idIncludes="274"/><IncludeList idCode="222" idIncludes="275"/><IncludeList idCode="223" idIncludes="276"/><IncludeList idCode="1" idIncludes="277"/><IncludeList idCode="224" idIncludes="278"/><IncludeList idCode="225" idIncludes="279"/><IncludeList idCode="226" idIncludes="280"/><IncludeList idCode="227" idIncludes="281"/><IncludeList idCode="228" idIncludes="282"/><IncludeList idCode="229" idIncludes="283"/><IncludeList idCode="230" idIncludes="284"/><IncludeList idCode="230" idIncludes="285"/><IncludeList idCode="231" idIncludes="286"/><IncludeList idCode="231" idIncludes="287"/><IncludeList idCode="231" idIncludes="288"/><IncludeList idCode="231" idIncludes="289"/><IncludeList idCode="231" idIncludes="290"/><IncludeList idCode="231" idIncludes="291"/><IncludeList idCode="232" idIncludes="292"/><IncludeList idCode="233" idIncludes="293"/><IncludeList idCode="145" idIncludes="294"/><IncludeList idCode="234" idIncludes="295"/><IncludeList idCode="235" idIncludes="296"/><IncludeList idCode="236" idIncludes="297"/><IncludeList idCode="237" idIncludes="298"/><IncludeList idCode="238" idIncludes="299"/><IncludeList idCode="239" idIncludes="300"/><IncludeList idCode="240" idIncludes="301"/><IncludeList idCode="241" idIncludes="302"/><IncludeList idCode="242" idIncludes="303"/><IncludeList idCode="243" idIncludes="304"/><IncludeList idCode="244" idIncludes="305"/><IncludeList idCode="245" idIncludes="306"/><IncludeList idCode="246" idIncludes="307"/><IncludeList idCode="247" idIncludes="308"/><IncludeList idCode="248" idIncludes="309"/><IncludeList idCode="249" idIncludes="310"/><IncludeList idCode="251" idIncludes="311"/><IncludeList idCode="250" idIncludes="312"/><IncludeList idCode="250" idIncludes="313"/><IncludeList idCode="252" idIncludes="314"/><IncludeList idCode="253" idIncludes="315"/><IncludeList idCode="254" idIncludes="316"/><IncludeList idCode="255" idIncludes="317"/><IncludeList idCode="256" idIncludes="318"/><IncludeList idCode="257" idIncludes="319"/><IncludeList idCode="258" idIncludes="320"/><IncludeList idCode="259" idIncludes="321"/><IncludeList idCode="260" idIncludes="322"/><IncludeList idCode="261" idIncludes="323"/><IncludeList idCode="262" idIncludes="324"/><IncludeList idCode="263" idIncludes="325"/><IncludeList idCode="264" idIncludes="326"/><IncludeList idCode="265" idIncludes="327"/><IncludeList idCode="266" idIncludes="328"/><IncludeList idCode="267" idIncludes="329"/><IncludeList idCode="268" idIncludes="330"/><IncludeList idCode="269" idIncludes="331"/><IncludeList idCode="270" idIncludes="332"/><IncludeList idCode="271" idIncludes="333"/><IncludeList idCode="272" idIncludes="334"/><IncludeList idCode="273" idIncludes="335"/><IncludeList idCode="274" idIncludes="336"/><IncludeList idCode="275" idIncludes="337"/><IncludeList idCode="276" idIncludes="338"/><IncludeList idCode="277" idIncludes="339"/><IncludeList idCode="278" idIncludes="340"/><IncludeList idCode="279" idIncludes="341"/><IncludeList idCode="280" idIncludes="342"/><IncludeList idCode="281" idIncludes="343"/><IncludeList idCode="282" idIncludes="344"/><IncludeList idCode="283" idIncludes="345"/><IncludeList idCode="284" idIncludes="346"/><IncludeList idCode="285" idIncludes="347"/><IncludeList idCode="286" idIncludes="348"/><IncludeList idCode="287" idIncludes="349"/><IncludeList idCode="288" idIncludes="350"/><IncludeList idCode="187" idIncludes="351"/><IncludeList idCode="295" idIncludes="353"/><IncludeList idCode="296" idIncludes="354"/><IncludeList idCode="297" idIncludes="355"/><IncludeList idCode="298" idIncludes="356"/><IncludeList idCode="304" idIncludes="357"/><IncludeList idCode="302" idIncludes="358"/><IncludeList idCode="307" idIncludes="359"/><IncludeList idCode="308" idIncludes="360"/><IncludeList idCode="312" idIncludes="361"/><IncludeList idCode="313" idIncludes="362"/><IncludeList idCode="314" idIncludes="363"/><IncludeList idCode="318" idIncludes="365"/><IncludeList idCode="319" idIncludes="366"/><IncludeList idCode="320" idIncludes="367"/><IncludeList idCode="321" idIncludes="368"/><IncludeList idCode="322" idIncludes="369"/><IncludeList idCode="323" idIncludes="370"/><IncludeList idCode="323" idIncludes="371"/><IncludeList idCode="324" idIncludes="372"/><IncludeList idCode="325" idIncludes="373"/><IncludeList idCode="326" idIncludes="374"/><IncludeList idCode="327" idIncludes="375"/><IncludeList idCode="326" idIncludes="376"/><IncludeList idCode="328" idIncludes="377"/><IncludeList idCode="328" idIncludes="378"/><IncludeList idCode="328" idIncludes="379"/><IncludeList idCode="328" idIncludes="380"/><IncludeList idCode="328" idIncludes="381"/><IncludeList idCode="328" idIncludes="382"/><IncludeList idCode="329" idIncludes="383"/><IncludeList idCode="330" idIncludes="384"/><IncludeList idCode="331" idIncludes="385"/><IncludeList idCode="332" idIncludes="386"/><IncludeList idCode="333" idIncludes="387"/><IncludeList idCode="334" idIncludes="388"/><IncludeList idCode="335" idIncludes="389"/><IncludeList idCode="336" idIncludes="390"/><IncludeList idCode="337" idIncludes="391"/><IncludeList idCode="338" idIncludes="392"/><IncludeList idCode="339" idIncludes="393"/><IncludeList idCode="340" idIncludes="394"/><IncludeList idCode="341" idIncludes="395"/><IncludeList idCode="342" idIncludes="396"/><IncludeList idCode="328" idIncludes="397"/><IncludeList idCode="343" idIncludes="398"/><IncludeList idCode="344" idIncludes="399"/><IncludeList idCode="345" idIncludes="400"/><IncludeList idCode="346" idIncludes="401"/><IncludeList idCode="323" idIncludes="402"/><IncludeList idCode="351" idIncludes="403"/><IncludeList idCode="352" idIncludes="404"/><IncludeList idCode="353" idIncludes="405"/><IncludeList idCode="354" idIncludes="406"/><IncludeList idCode="355" idIncludes="407"/><IncludeList idCode="355" idIncludes="408"/><IncludeList idCode="355" idIncludes="409"/><IncludeList idCode="355" idIncludes="410"/><IncludeList idCode="355" idIncludes="411"/><IncludeList idCode="356" idIncludes="412"/><IncludeList idCode="358" idIncludes="413"/><IncludeList idCode="359" idIncludes="414"/><IncludeList idCode="360" idIncludes="415"/><IncludeList idCode="361" idIncludes="416"/></IncludeList_List><Code_List><Code idCode="1">// ==============================================
// generic vector interface for integer and
// rational types based on the std. C lib
// ==============================================

// ----------------------------------------------
// generic integer type
// ----------------------------------------------

// transforms the integer to a 'unique form'
inline uint32_t APgenericInteger_ToUniform (uint32_t v) {
	uint32_t u;
	u = v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= (v &amp; 0xFF);
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= (v &amp; 0xFF);
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= (v &amp; 0xFF);
	return u;
}

// inverse transformation of the unique integer to the 'local form'
inline uint32_t APgenericInteger_FromUniform (uint32_t v) {
	uint32_t u;
	u = v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= v &amp; 0xFF;
	return u;
}



// type for a generic vector based int type
typedef struct SAPgenericIntegerVector {
	int32_t *	pVal;
	int			num;
} TAPgenericIntegerVector;

// create int vector
TAPgenericIntegerVector * APgenericIntegerVector_create (int num) {
	int i;
	// alloc memory
	TAPgenericIntegerVector * pI = malloc (sizeof(TAPgenericIntegerVector));
	if (!pI) return NULL;
	pI-&gt;pVal = malloc (sizeof(int32_t)*num);
	if (!pI-&gt;pVal) {
		free (pI);
		return NULL;
	}
	pI-&gt;num = num;
	// set memory
	for (i = 0; i&lt; num; i++) {
		pI-&gt;pVal[i] = 0;
	}
	return pI;
}

// destroy int vector
void APgenericIntegerVector_destroy (TAPgenericIntegerVector * pV) {
	if (pV) {
		free(pV-&gt;pVal);
		free(pV);
	}
}

// resize int vector
int APgenericIntegerVector_resize (TAPgenericIntegerVector * pV, int newNum) {
	int i;

	if (pV-&gt;num == newNum) return 0;
	free (pV-&gt;pVal);
	pV-&gt;pVal = malloc (sizeof(int32_t)*newNum);
	if (!pV-&gt;pVal) return -1;
	pV-&gt;num = newNum;
	// set memory
	for (i = 0; i&lt; newNum; i++) {
		pV-&gt;pVal[i] = 0;
	}
	return 0;
}

// assign a = values
int APgenericIntegerVector_assignConst (TAPgenericIntegerVector * pa, int iStart, int num, int32_t * pVals) {
	int i = iStart;
	int imax = i + num;
	int32_t * pD = pa-&gt;pVal + iStart;
	if (imax &gt; pa-&gt;num) imax = pa-&gt;num;

	for (; i &lt; imax; i++) {
		*pD = *pVals;
		pD++;
		pVals++;
	}
	return 0;
}

// assign a = b
int APgenericIntegerVector_assign (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb) {
	int imax = pa-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		for (i = 0; i &lt; imax; i++) {
			pa-&gt;pVal[i] = pb-&gt;pVal[i];
		}
	} else {
		for (i = 0; i &lt; imax; i++) {
			pa-&gt;pVal[i] = pb-&gt;pVal[0];
		}
	}
	return 0;
}


// add c = a + b
int APgenericIntegerVector_add (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;

	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise add
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha + b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] + pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta + a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[0];
			}
			return 0;
		}

	}
	return -1;
}

// sub c = a - b
int APgenericIntegerVector_sub (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise sub
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha - b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] - pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = a[i] - beta
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[0];
			}
			return 0;
		}

	}
	return -1;
}

// mul c = a * b
int APgenericIntegerVector_mul (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise mul
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha * b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] * pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta * a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[0];
			}
			return 0;
		}

	}
	return -1;
}

// div c = a * b
int APgenericIntegerVector_div (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;

	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise div
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha / b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] / pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta / a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[0];
			}
			return 0;
		}
	}
	return -1;
}

// modulo c = a mod b
int APgenericIntegerVector_mod (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise mod
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] % pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha % b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] % pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta % a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] % pb-&gt;pVal[0];
			}
			return 0;
		}
	}
	return -1;
}

// cmp Element cmp(a[i],b[j]):
//		res = -1: a &lt; b
//		res = 1 : a &gt; b
//		res = 0: a = b
int APgenericIntegerVector_cmpEle (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, int ia, int ib) {
	int zwv = pa-&gt;pVal[ia] - pb-&gt;pVal[ib];
	if (!zwv) return 0;
	if (zwv &lt; 0) return -1;
	return 1;
}


// ----------------------------------------------
// generic rational type
// ----------------------------------------------

// type for a generic vector based float type
typedef struct SAPgenericRationalVector {
	float *		pVal;
	int			num;
} TAPgenericRationalVector;

// create float vector
TAPgenericRationalVector * APgenericRationalVector_create (int num) {
	int i;
	// alloc memory
	TAPgenericRationalVector * pR = malloc (sizeof(TAPgenericRationalVector));
	if (!pR) return NULL;
	pR-&gt;pVal = malloc (sizeof(float)*num);
	if (!pR-&gt;pVal) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = num;
	// set memory
	for (i = 0; i&lt; num; i++) {
		pR-&gt;pVal[i] = 0.f;
	}
	return pR;
}

// destroy float vector
void APgenericRationalVector_destroy (TAPgenericRationalVector * pV) {
	if (pV) {
		free(pV-&gt;pVal);
		free(pV);
	}
}

// resize float vector
int APgenericRationalVector_resize (TAPgenericRationalVector * pV, int newNum) {
	int i;

	if (pV-&gt;num == newNum) return 0;
	free (pV-&gt;pVal);
	pV-&gt;pVal = malloc (sizeof(float)*newNum);
	if (!pV-&gt;pVal) return -1;
	pV-&gt;num = newNum;
	// set memory
	for (i = 0; i&lt; newNum; i++) {
		pV-&gt;pVal[i] = 0.f;
	}
	return 0;
}

// assign a = values
int APgenericRationalVector_assignConst (TAPgenericRationalVector * pa, int iStart, int num, float * pVals) {
	int i = iStart;
	int imax = i + num;
	float * pD = pa-&gt;pVal + iStart;
	if (imax &gt; pa-&gt;num) imax = pa-&gt;num;

	for (; i &lt; imax; i++) {
		*pD = *pVals;
		pD++;
		pVals++;
	}
	return 0;
}

// assign a = b
int APgenericRationalVector_assign (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb) {
	int imax = pa-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		for (i = 0; i &lt; imax; i++) {
			pa-&gt;pVal[i] = pb-&gt;pVal[i];
		}
	} else {
		for (i = 0; i &lt; imax; i++) {
			pa-&gt;pVal[i] = pb-&gt;pVal[0];
		}
	}
	return 0;
}


// add c = a + b
int APgenericRationalVector_add (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise add
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha + b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] + pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta + a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[0];
			}
			return 0;
		}

	}
	return -1;
}

// sub c = a - b
int APgenericRationalVector_sub (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise sub
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha - b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] - pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta - a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[0];
			}
			return 0;
		}
	}
	return -1;

}

// mul c = a * b
int APgenericRationalVector_mul (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise mul
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha * b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] * pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta * a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[0];
			}
			return 0;
		}
	}
	return -1;
}

// div c = a * b
int APgenericRationalVector_div (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise div
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[i];
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha / b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[0] / pb-&gt;pVal[i];
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta / a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[0];
			}
			return 0;
		}
	}
	return -1;
}

// modulo c = a mod b
int APgenericRationalVector_mod (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	// check if vectors have the same size
	if (pb-&gt;num == imax) {
		// yes do elementwise mod
		for (i = 0; i &lt; imax; i++) {
			pc-&gt;pVal[i] = fmodf(pa-&gt;pVal[i],pb-&gt;pVal[i]);
		}
		return 0;
	} else {
		// no -&gt; special case c[i] = alpha % b[i]
		if (pa-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = fmodf(pa-&gt;pVal[0],pb-&gt;pVal[i]);
			}
			return 0;
		}
		// no -&gt; special case c[i] = beta % a[i]
		if (pb-&gt;num == 1) {
			for (i = 0; i &lt; imax; i++) {
				pc-&gt;pVal[i] = fmodf(pa-&gt;pVal[i],pb-&gt;pVal[0]);
			}
			return 0;
		}

	}
	return -1;
}

// cmp Element cmp(a[i],b[j]):
//		res = -1: a &lt; b
//		res = 1 : a &gt; b
//		res = 0: a = b
int APgenericRationalVector_cmpEle (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, int ia, int ib) {
	float zwv = pa-&gt;pVal[ia] - pb-&gt;pVal[ib];
	if (zwv == 0.f) return 0;
	if (zwv &lt; 0.f) return -1;
	return 1;
}
</Code><Code idCode="2">// ===============================
// function implementation for assignRational(var id = 10)
// description: a = b
// ===============================

void HALfunc_ID10_assignRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: the source
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="3">// ===============================
// function implementation for addRational(var id = 11)
// description: c = a + b
// ===============================

void HALfunc_ID11_addRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="4">// ===============================
// function implementation for subRational(var id = 12)
// description: c = a - b
// ===============================

void HALfunc_ID12_subRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="5">// ===============================
// function implementation for mulRational(var id = 13)
// description: c = a * b
// ===============================

void HALfunc_ID13_mulRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="6">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// transmit the data
void HALimpl_1_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_1_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_1_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_1_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_1_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="7">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// transmit the data
void HALimpl_2_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_2_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_2_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_2_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="8">// ===============================
// variable implementation for a integer number(var id = 3)
// ===============================

// transmit the data
void HALimpl_3_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_3_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_3_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="9"></Code><Code idCode="10">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_1 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_1 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_1 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_1(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_1(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_1(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_1(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_1(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="11">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_2 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_2 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_2 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_2(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_2(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_2(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_2(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_2(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="12">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// create a mmu
TAPMMU AP_MMU_create (size_t poolSize) {

}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {

}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t amountInBytes) {

}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {

}
</Code><Code idCode="13">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// create a mmu
TAPMMU AP_MMU_create (size_t poolSize) {

}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {

}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t amountInBytes) {

}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {

}

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {
	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}

</Code><Code idCode="14">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="15">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="16">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="17">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="18">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="19"></Code><Code idCode="20">// ===============================
// AP uuid = 1
// ===============================



@

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	@
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	@
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

	@	
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
@
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
@MMUUnLock
	return pM;
error:
@MMUUnLock
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;
@
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
@MMUUnLock
}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="21">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="22">// ===============================
// AP uuid = 1
// ===============================




// the mutex type
typedef void * TAPMutex;

// create an AP mutex
TAPMutex APMutexCreate () {
	return NULL;
}

// delete mutex
void APMutexDelete (TAPMutex mtx) {

}

inline void APMutexLock (TAPMutex mtx) {

}

inline void APMutexUnlock (TAPMutex mtx) {

}



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
		TAPMutex mtx;
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
		pMMU-&gt;mtx = APMutexCreate();
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		APMutexDelete(pMMU-&gt;mtx);	
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return pM;
error:
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	APMutexUnlock(pMMU-&gt;MMUmutext);
}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="23">// ===============================
// variable implementation for a integer number(var id = 3)
// ===============================

// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len - iStart;

	for (i = 0;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}

// transmit the data
void HALimpl_3_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_3_create () {
return NULL;
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_3_delete (void * pVar) {

}
</Code><Code idCode="24">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================
// stdint.h
// transmit the data
void HALimpl_2_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVar, int * pframeSize) {
	return sizeof(int32_t);
}
// end init process
void HALimpl_2_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_2_create () {
	int * pI = malloc(sizeof(int32_t));
	*pI = 0;
	return pI;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVar) {
	return pVar;
}
// delete the variable
void HALimpl_2_delete (void * pVar) {
	free ((int32_t *)pVar);
}
</Code><Code idCode="25">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// transmit the data
void HALimpl_1_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_1_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_1_create () {
	float * pF = (float *) malloc (sizeof(float));
	if (pF) *pF = 0.0f;
	return pF;
}
// fill the frame with data
void HALimpl_1_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="26">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="27">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="28">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="29">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="30">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free pIP;	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="31">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free pIP;	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="32">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="33">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="34">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="35">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int32_t index, int32_t varTypeID)
{

}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP, int32_t i, int32_t * pRawInstr)
{

}


</Code><Code idCode="36">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int32_t index, int32_t varTypeID)
{

}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP, int32_t i, int32_t * pRawInstr)
{

}


</Code><Code idCode="37">// ===============================
// function implementation for assignRational(var id = 10)
// description: a = b
// ===============================

void HALfunc_ID10_assignRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: the source
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="38">// ===============================
// function implementation for addRational(var id = 11)
// description: c = a + b
// ===============================

void HALfunc_ID11_addRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="39">// ===============================
// function implementation for subRational(var id = 12)
// description: c = a - b
// ===============================

void HALfunc_ID12_subRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="40">// ===============================
// function implementation for mulRational(var id = 13)
// description: c = a * b
// ===============================

void HALfunc_ID13_mulRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="41">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="42">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pIP-&gt;sysEndian = eAP_littleEndian;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="43">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="44">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="45">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP&gt;sysEndian) {
		APendianConversation32Bit(-&gt;amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="46">// ===============================
// AP uuid = 1
// ===============================




// the mutex type
typedef void * TAPMutex;

// create an AP mutex
TAPMutex APMutexCreate () {
	return NULL;
}

// delete mutex
void APMutexDelete (TAPMutex mtx) {

}

inline void APMutexLock (TAPMutex mtx) {

}

inline void APMutexUnlock (TAPMutex mtx) {

}



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	TAPMutex		mtx;
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
		pMMU-&gt;mtx = APMutexCreate();
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		APMutexDelete(pMMU-&gt;mtx);	
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return pM;
error:
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	APMutexLock(pMMU-&gt;MMUmutext);
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	APMutexUnlock(pMMU-&gt;MMUmutext);
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="47">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="48">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (TAP * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = pAP-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="49">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			void *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = pAP-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="50">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem pMS = (TAPrealMsgSystem) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pSM-&gt;pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pSM-&gt;pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem *						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="51">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem *						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="52">// ===============================
// driver uuid =3
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_3 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_3 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_3 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_3(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_3(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_3(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_3(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_3(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="53">// ===============================
// driver uuid =4
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_4 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_4 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_4 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_4(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_4(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_4(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_4(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_4(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="54">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="55">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="56">// ===============================
// function implementation for jump(var id = 50)
// description: jumps n instructions
// ===============================

void HALfunc_ID50_jump(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter number descr: amount of instructions to jump
//	int32_t* pnumber = &amp;( pParams[0].fp_integer);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
};
</Code><Code idCode="57"></Code><Code idCode="58">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}

	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (pMsgIDandFunctAsso-&gt;msgID == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="59">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (pMsgIDandFunctAsso-&gt;msgID == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="60">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="61">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="62">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="63">// ===============================
// variable implementation for a biqaud filter(var id = 10)
// ===============================

typedef struct SAPBiquadDF2 {
	float	k;
	float	a1;
	float	a2;
	float	b1;
	float	b2;
	float	s1;
	float	s2;
} TAPBiquadDF2;

// transmit the data
void HALimpl_10_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_10_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_10_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_10_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_10_create () {
	TAPBiquadDF2 * pBQ = malloc(sizeof(TAPBiquadDF2));
	if (!pBQ) return NULL;
	pBQ-&gt;k =0.0;
	pBQ-&gt;a1 =0.0;
	pBQ-&gt;a2 =0.0;
	pBQ-&gt;b1 =0.0;
	pBQ-&gt;b2 =0.0;
	pBQ-&gt;s1 = 0.0;
	pBQ-&gt;s2 = 0.0;
	return pBQ;
}
// fill the frame with data
void HALimpl_10_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="64">// ===============================
// startup code for the audio processor abc
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="65">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="66">// ==============================
// descr: some helpers for the lib-snd-file group
// author: Stefan Jaritz
//
// the lib is the &quot;libsndfile-1&quot;
// ==============================

typedef struct SStjWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input
	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)
	unsigned int	sampleAmountCacheSize;	//!&lt; amount of samples cached before writing or/ at reading
} TStjWAVOpenInfo;

typedef struct SStjWAVFile {
	unsigned int	channel;			//!&lt; the channel
	SNDFILE *		pSndF;				//!&lt; the file
	unsigned int	isInput;			//!&lt; if &lt;&gt; 0 the channel is an input channel
	unsigned int	channelsAmount; 	//!&lt; the amount of channels
	unsigned int	sampleAmount;		//!&lt; the amount of samples at the cache
	unsigned int	maxSampleAmount;	//!&lt; the maximum sample amount
	unsigned int	dataOffset;			//!&lt; the offset of the channel at the sample cache
	float *			pCache;				//!&lt; the sample cache
	float *			pD;					//!&lt; pointer to the data
} TStjWAVFile;


typedef struct SStjWAVmodule {
	TStjWAVFile *	pChannels;
	unsigned int	number;
} TStjWAVmodule;

// fill the wav sample cache
int WAVmoduleFillCache (TStjWAVFile * pWF) {
	sf_count_t amount = (sf_count_t) pWF-&gt;maxSampleAmount;
	// read a data frame(s)
	amount = sf_readf_float (pWF-&gt;pSndF,pWF-&gt;pCache, amount);
	if (amount &lt; 1) return -1;
	// reset data pointers and indexes
	pWF-&gt;pD = pWF-&gt;pCache;
	pWF-&gt;sampleAmount = (unsigned int) amount;
	return 0;
}

// flushes the wav sample cache to disk
int WAVmoduleFlushCache (TStjWAVFile * pWF) {
	if (!pWF-&gt;sampleAmount) return 0;
	sf_count_t amount = (sf_count_t) pWF-&gt;sampleAmount;
	if (amount != sf_write_float (pWF-&gt;pSndF,pWF-&gt;pCache , amount)) return -1;
	pWF-&gt;pD = pWF-&gt;pCache;
	pWF-&gt;sampleAmount = 0;
	return 0;
}


//! close the set of wav files
void WAVmoduleExit (TStjWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		// if it is an output flush the samples to disk
		if (!pWF-&gt;isInput) {
			WAVmoduleFlushCache(pWF);
		}
		sf_close(pWF-&gt;pSndF);
		if (pWF-&gt;pCache) {
			free (pWF-&gt;pCache);
		}
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int WAVmoduleInit (
		int 				number,		//!&lt;(in) amount of files
		TStjWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjWAVmodule *		pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjWAVFile) * number);
	pModul-&gt;number = number;

	int 			i;
	SF_INFO 		info;
	TStjWAVFile * 	pWF = pModul-&gt;pChannels;
	size_t			cacheSize;

	for (i = 0;i &lt; number;i++) {
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info) ;
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info) ;
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;
		pWF-&gt;channelsAmount = (unsigned int) info.channels;
		pWF-&gt;dataOffset = (unsigned int) pWAVFiles[i].fileChannelNumber;
		pWF-&gt;maxSampleAmount = (unsigned int) pWAVFiles[i].sampleAmountCacheSize;
		cacheSize =  pWF-&gt;channelsAmount * pWF-&gt;maxSampleAmount * sizeof(float);
		pWF-&gt;pCache = malloc (cacheSize);
		if (!pWF-&gt;pCache) goto error;
		memset (pWF-&gt;pCache,0,cacheSize);
		pWF-&gt;sampleAmount = 0;
		// now fill the cache with data
		if (pWF-&gt;isInput) {
			if (WAVmoduleFillCache(pWF)) goto error;
		} else {
			pWF-&gt;pD = pWF-&gt;pCache;
		}
		pWF++;
	}
	return 0;
error:
	WAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjWAVFile * WAVmoduleFindChannel (
		TStjWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
		) {
	TStjWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int WAVmoduleGetInput (
		TStjWAVmodule *	pM,			//!&lt;(in) the module
		int				channel,	//!&lt;(in) the channel
		float *			pSample		//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjWAVFile * pWF = WAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}
	// if the cache is empty then fill it
	if (!pWF-&gt;sampleAmount) {
		if (WAVmoduleFillCache(pWF)) return -3;
	}
	// copy sample
	*pSample = pWF-&gt;pD[pWF-&gt;dataOffset];
	pWF-&gt;pD += pWF-&gt;channelsAmount;
	// now there is one sample less at the buffer
	pWF-&gt;sampleAmount--;
	return 0;
}

//! writes a sample to an output
int WAVmoduleSetOutput (
		TStjWAVmodule *	pM,			//!&lt;(in) the module
		int				channel,	//!&lt;(in) the channel
		float 			sample		//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjWAVFile * pWF = WAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// if the cache is full then flush it
	if (pWF-&gt;sampleAmount == pWF-&gt;maxSampleAmount) {
		if (WAVmoduleFlushCache(pWF)) return -3;
	}
	// now store the value
	pWF-&gt;pD[pWF-&gt;dataOffset] = sample;
	pWF-&gt;pD += pWF-&gt;channelsAmount;
	pWF-&gt;sampleAmount++;
	return 0;
}</Code><Code idCode="67">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter resValue descr: the result of the action
	float ** presValue = &amp;( pParams[1].fp_pD);

	WAVmoduleGetInput ();
};
</Code><Code idCode="68">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="69">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	void ** pchannel = &amp;( pParams[0].fp_pD);
// parameter resValue descr: the result of the action
	void ** presValue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="70">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	void ** pchannel = &amp;( pParams[0].fp_pD);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="71">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="72">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="73">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="74">// ===============================
// startup code for the audio processor
// ===============================
/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc (sizeof(int32_t)*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	int res = loadALCfromFile (&quot;../APgen/ALASM/bypass.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="75">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}



typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="76">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="77">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsgMsgSystem (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="78">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="79">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="80">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="81">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// int32_t* pchannel =  pParams[0].fp_integer;
// parameter resValue descr: the result of the action
	// int32_t* pSample =  pParams[1].fp_pD;
	
	// foreward declaration of the global variable
	extern TStjWAVmodule gWAVModule;

	if (WAVmoduleGetInput(&amp;gWAVModule,pParams[0].fp_integer,((TAPvarRational *)pParams[1].fp_pD)-&gt;pR)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="82">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
//	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
//	void ** pvalue = &amp;( pParams[1].fp_pD);

	// foreward declaration of the global variable
	extern TStjWAVmodule gWAVModule;
	if (WAVmoduleSetOutput(&amp;gWAVModule,pParams[0].fp_integer,*((TAPvarRational *)pParams[1].fp_pD)-&gt;pR)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="83">// ===============================
// function implementation for assignConstInteger(var id = 25)
// description: a = const b
// ===============================

void HALfunc_ID25_assignConstInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
//	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: constant integer
//	int32_t* pb = &amp;( pParams[1].fp_integer);
	*((int32_t*) pParams[0].fp_pD) = pParams[1].fp_integer;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="84">// ===============================
// AP uuid = 2
// ===============================

#define WAVsampleCache (20000000)

// the wav modul global var
TStjWAVmodule gWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	// init wav module
	TStjWAVOpenInfo wavIOs[] = {
			{1,&quot;input.wav&quot;,1,44100,0,WAVsampleCache},
			{2,&quot;bypass.wav&quot;,0,44100,0,WAVsampleCache},
			{3,&quot;subbass.wav&quot;,0,44100,0,WAVsampleCache},
			{4,&quot;lowerVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{5,&quot;upperVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{6,&quot;harmonics.wav&quot;,0,44100,0,WAVsampleCache},
	};

	if (WAVmoduleInit (sizeof(wavIOs) / sizeof(TStjWAVOpenInfo),wavIOs,&amp;gWAVModule)) {
		return -2;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close wav module
	WAVmoduleExit(&amp;gWAVModule);

	// close the AP
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="85">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="86">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// the internal integer type
typedef struct SAPvarInteger {
	unsigned int		num;
	int * 			pI;
}  TAPvarInteger;

// transmit the data
void HALimpl_2_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	*pframeSize = pI-&gt;num * sizeof(int32_t);
	return 1;
}
// end init process
void HALimpl_2_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_2_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarInteger * pI;
	pI = malloc(sizeof(TAPvarInteger));
	if (!pI) return NULL;

	pI-&gt;pI = malloc(sizeof(int32_t)*numberOfElements);
	if (!(pI-&gt;pI)) {
		free (pI);
		return NULL;
	}
	pI-&gt;num = numberOfElements;

	memset (pI-&gt;pI,0,sizeof(int32_t)*numberOfElements);
	return pI;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVarData) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	return pI-&gt;pI;
}
// delete the variable
void HALimpl_2_delete (void * pVarData) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	if (pI) {
		if (pI-&gt;pI) free (pI-&gt;pI);
		free (pI);
	}
}</Code><Code idCode="87">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// the internal rational type
typedef struct SAPvarRational {
	unsigned int		num;
	float * 			pR;
}  TAPvarRational;


// transmit the data
void HALimpl_1_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	*pframeSize = pR-&gt;num * sizeof(float);
	return 1;
}
// end init process
void HALimpl_1_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarRational * pR;
	pR = malloc(sizeof(TAPvarRational));
	if (!pR) return NULL;

	pR-&gt;pR = malloc(sizeof(float)*numberOfElements);
	if (!(pR-&gt;pR)) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = numberOfElements;

	memset (pR-&gt;pR,0,sizeof(float)*numberOfElements);
	return pR;

}
// fill the frame with data
void HALimpl_1_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	return pR;
}

// delete the variable
void HALimpl_1_delete (void * pVarData) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	if (pR) {
		if (pR-&gt;pR) free (pR-&gt;pR);
		free (pR);
	}
}</Code><Code idCode="88">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

typedef struct SAPBiquadDF2 {
	float	k;	// gain
	float	n1;	// nominator
	float	n2;
	float	d1; // denominator
	float	d2;
	float	s1; // delays
	float	s2;
} TAPBiquadDF2;

typedef struct SAPvarBiquad {
	unsigned int		num;
	TAPBiquadDF2 *	pB;	
} TAPvarBiquad;


// transmit the data
void HALimpl_10_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_10_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_10_frameGetNumber (void * pVarData, int * pframeSize) {
	return 0;
}
// end init process
void HALimpl_10_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_10_create (unsigned int numberOfElements) {
	TAPvarBiquad * pB = malloc (sizeof(TAPvarBiquad));
	if (!pB) return NULL;
	pB-&gt;pB = malloc(sizeof(TAPBiquadDF2)*numberOfElements);
	if (!pB-&gt;pB) {
		free (pB);
		return NULL;
	}
	pB-&gt;num = numberOfElements;
	int i;
	for (i = 0; i &lt; numberOfElements; i++) {
		pB-&gt;pB[i].k = 0.0;
		pB-&gt;pB[i].n1 = 0.0;
		pB-&gt;pB[i].n2 = 0.0;
		pB-&gt;pB[i].d1 = 0.0;
		pB-&gt;pB[i].d2 = 0.0;
		pB-&gt;pB[i].s1 = 0.0;
		pB-&gt;pB[i].s2 = 0.0;
	}
	return pB;
}
// fill the frame with data
void HALimpl_10_frameFill (void * pVarData, int frameNumber, void * pFrame) {
}

// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	TAPvarBiquad * pB = (TAPvarBiquad *) pVarData;
	return pB;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	TAPvarBiquad * pB = (TAPvarBiquad *) pVarData;
	if (pB) {
		if (pB-&gt;pB) {
			free (pB-&gt;pB);
		}
		free (pB);
	}
}
</Code><Code idCode="89">// ===============================
// variable implementation for a delay(var id = 20)
// ===============================

// map delay functions to the rational functions
#define HALimpl_20_init HALimpl_1_init


// transmit the data
void  (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_20_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_20_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_20_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_20_create (unsigned int numberOfElements) {
return NULL;
}
// fill the frame with data
void HALimpl_20_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_20_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_20_delete (void * pVarData) {

}</Code><Code idCode="90">// ===============================
// variable implementation for a delay(var id = 20)
// ===============================

// map delay to the rational datatype

#define HALimpl_20_recvUpdate HALimpl_1_recvUpdate
#define HALimpl_20_create HALimpl_1_create
#define HALimpl_20_sendUpdate HALimpl_1_sendUpdate
#define HALimpl_20_decodeData HALimpl_1_decodeData
#define HALimpl_20_delete HALimpl_1_delete
</Code><Code idCode="91">// ===============================
// AP uuid = 3
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="92">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
};
</Code><Code idCode="93">// ===============================
// function implementation for initBiquadAsLP(var id = 101)
// description: inits a biquad filter as a low pass filter
// ===============================

void HALfunc_ID101_initBiquadAsLP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter i descr: index at the biquad array
	int32_t i = pParams[0].fp_integer;
	// parameter fs descr: sample frequency
	float fs = pParams[1].fp_rational;
	// parameter fc descr: cut off frequency
	float fc = pParams[2].fp_rational;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[3].fp_pV-&gt;pData;

	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=k2/dn;
	float n1=2*k2/dn;
	float n2=k2/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;
		
	pBQA-&gt;pB[i].n1 = n1 / n0;
	pBQA-&gt;pB[i].n2 = n2 / n0;
	pBQA-&gt;pB[i].d1 = d1 / d0;
	pBQA-&gt;pB[i].d2 = d2 / d0;
	pBQA-&gt;pB[i].k = n0 / d0;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="94">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================

void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float * px = (float *) pParams[0].fp_pD;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	float x = *px;
	float y;
	int i;
	float d1;
	TAPBiquadDF2 * pF = pBQA-&gt;pB;

	for (i = 0; i &lt; pBQA-&gt;num; i++) {
		// filter
		d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + x);
		y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
		y *= pF-&gt;k;

		pF-&gt;s2 = pF-&gt;s1;
		pF-&gt;s1 = d1;
		// output is input for the next filter
		x = y;
		pF++;
	}

	// save result to the output
	*py = y;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};</Code><Code idCode="95">// ===============================
// function implementation for shiftDelay(var id = 150)
// description: shifts the content of the delay
// ===============================

void HALfunc_ID150_shiftDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float * px = (float *) pParams[0].fp_pD;
	// parameter delay descr: the delay
	TAPvarRational * pDelay = (TAPvarRational *) pParams[1].fp_pD;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// save oldest value
	int imax = pDelay-&gt;num-1;

	*py = pDelay-&gt;pR[imax];

	// shift value (we copy only num -1 values with the offset of 1)
	memcpy (pDelay-&gt;pR+1,pDelay-&gt;pR,imax);

	// save the input
	*pDelay-&gt;pR = *px;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="96">// ===============================
// function implementation for shiftDelay(var id = 150)
// description: shifts the content of the delay
// ===============================

void HALfunc_ID150_shiftDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float x = *((float *) pParams[0].fp_pD);
	// parameter delay descr: the delay
	TAPvarRational * pDelay = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// save oldest value
	int imax = pDelay-&gt;num-1;

	*py = pDelay-&gt;pR[imax];

	// shift value (we copy only num -1 values with the offset of 1)
	memcpy (pDelay-&gt;pR+1,pDelay-&gt;pR,imax*sizeof(float));

	// save the input
	*pDelay-&gt;pR = x;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="97">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter i descr: index at the biquad array
	int32_t i = pParams[0].fp_integer;
	// parameter fs descr: sample frequency
	float fs = pParams[1].fp_rational;
	// parameter fc descr: cut off frequency
	float fc = pParams[2].fp_rational;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[3].fp_pV-&gt;pData;

	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=1/dn;
	float n1=-2/dn;
	float n2=1/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;

	pBQA-&gt;pB[i].n1 = n1 / n0;
	pBQA-&gt;pB[i].n2 = n2 / n0;
	pBQA-&gt;pB[i].d1 = d1 / d0;
	pBQA-&gt;pB[i].d2 = d2 / d0;
	pBQA-&gt;pB[i].k = n0 / d0;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="98">//  ==================================
// fftw3 libis used for complex and fft &amp; ifft functions
//  ==================================</Code><Code idCode="99">// ===============================
// variable implementation for a complex number(var id = 4)
// ===============================

// the type for the complex data struct
typedef struct SAPvarComplex {
	fftwf_complex *	pC;
	int				num;
} TAPvarComplex;

// transmit the data
void HALimpl_4_init (void * pVarData, int frameNumber, void * pData) {

}

// start the init process
void HALimpl_4_initStart (void * pVarData, int frameNumber, int bigEndian) {

}

// get the frame Number and size
int HALimpl_4_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	*pframeSize = pC-&gt;num * sizeof(fftwf_complex);
	return 1;
}

// end init process
void HALimpl_4_initEnd (void * pVarData) {

}

// create a new variable
void * HALimpl_4_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarComplex * pC;
	pC = malloc(sizeof(TAPvarComplex));
	if (!pC) return NULL;

	pC-&gt;pC = fftwf_malloc(sizeof(fftwf_complex)*numberOfElements);
	if (!(pC-&gt;pC)) {
		free (pC);
		return NULL;
	}
	pC-&gt;num = numberOfElements;

	memset (pC-&gt;pC,0,sizeof(fftwf_complex)*numberOfElements);
	return pC;
}

// fill the frame with data
void HALimpl_4_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}

// decode data for the HAL functions
void * HALimpl_4_decodeData (void * pVarData) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	return pC-&gt;pC;
}

// delete the variable
void HALimpl_4_delete (void * pVarData) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	if (pC) {
		if (pC-&gt;pC) fftwf_free(pC-&gt;pC);
		free (pC);
	}
}</Code><Code idCode="100">// ===============================
// variable implementation for FFT or IFFT sturcture(var id = 30)
// ===============================

// transmit the data
void HALimpl_30_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_30_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_30_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_30_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_30_create (unsigned int numberOfElements) {
	return NULL;
}
// fill the frame with data
void HALimpl_30_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_30_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_30_delete (void * pVarData) {
	if (pVarData) {
		fftwf_destroy_plan(pVarData);
	}
}
</Code><Code idCode="101">// ============================================================
// descr: some helpers for the lib-snd-file group
// author: Stefan Jaritz
//
// the lib is the &quot;libsndfile-1&quot;
// ============================================================

// defines

typedef struct SStjFrameOverlappedWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input

	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)

	unsigned int	frameSize;				//!&lt; number of samples per frame
	unsigned int	overlappingNumber;		//!&lt; the number of samples kept in the frame at reading/writing
} TStjFrameOverlappedWAVOpenInfo;

typedef struct SStjFrameOverlappedWAVFile {
	unsigned int	channel;				//!&lt; the channel
	SNDFILE *		pSndF;					//!&lt; the file
	unsigned int	isInput;				//!&lt; if 0 the channel is an input channel

	float *			pRB;					//!&lt; the ring buffer storing/writing the samples
	unsigned int	rbFrameSize;			//!&lt; the size of the frames at the ring buffer
	unsigned int	FrameSize;				//!&lt; amount of samples at the frame
	unsigned int	nMax;					//!&lt; number of elements at the ring buffer
	unsigned int	n;						//!&lt; actual element (for inputs)/ the offset (output)
} TStjFrameOverlappedWAVFile;

typedef struct SStjFrameOverlappedWAVmodule {
	TStjFrameOverlappedWAVFile *	pChannels;
	unsigned int		number;
} TStjFrameOverlappedWAVmodule;

//! close the set of wav files
void FrameOverlappedWAVmoduleExit (TStjFrameOverlappedWAVmodule * pM);

//! initis a set of wav files for writing / reading
int FrameOverlappedWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameOverlappedWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameOverlappedWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	);

//! looking for the right channel
TStjFrameOverlappedWAVFile * FrameOverlappedWAVmoduleFindChannel (
		TStjFrameOverlappedWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
	);

//! reads a sample from a channel
int FrameOverlappedWAVmoduleGetInput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(out) pointer to the sample buffer witch is filled
	);

//! writes a sample to an output
int FrameOverlappedWAVmoduleSetOutput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(in) pointer to the sample buffer witch is filled
	);

// functions

//! close the set of wav files
void FrameOverlappedWAVmoduleExit (TStjFrameOverlappedWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjFrameOverlappedWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		sf_close(pWF-&gt;pSndF);
		free (pWF-&gt;pRB);
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int FrameOverlappedWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameOverlappedWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameOverlappedWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjFrameOverlappedWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjFrameOverlappedWAVFile) * number);
	pModul-&gt;number = number;

	int 				i;
	SF_INFO 			info;
	TStjFrameOverlappedWAVFile * 	pWF = pModul-&gt;pChannels;

	for (i = 0;i &lt; number;i++) {
		// open sndfile interface
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info) ;
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info) ;
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;

		// prepare buffers
		pWF-&gt;FrameSize = pWAVFiles[i].frameSize;
		if (pWAVFiles[i].frameSize % pWAVFiles[i].overlappingNumber) {
			goto error;
		}
		pWF-&gt;nMax = pWAVFiles[i].frameSize / pWAVFiles[i].overlappingNumber;
		pWF-&gt;rbFrameSize = pWAVFiles[i].overlappingNumber;
		// if it's an input we need a memory for the old frames witch are read before
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pRB = malloc(sizeof(float)*pWAVFiles[i].frameSize);
			if (!pWF-&gt;pRB){
				goto error;
			}
			memset(pWF-&gt;pRB,0,sizeof(float)*pWAVFiles[i].frameSize);
			pWF-&gt;n = 0;
		} else {
			pWF-&gt;pRB = NULL;
			// the n is used as offset
			pWF-&gt;n = pWAVFiles[i].frameSize - pWAVFiles[i].overlappingNumber;
		}
		pWF++;
	}
	return 0;
error:
	FrameOverlappedWAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjFrameOverlappedWAVFile * FrameOverlappedWAVmoduleFindChannel (
		TStjFrameOverlappedWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
		) {
	TStjFrameOverlappedWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int FrameOverlappedWAVmoduleGetInput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjFrameOverlappedWAVFile * pWF = FrameOverlappedWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}

	// check the offset at the ringbuffer
	if (pWF-&gt;n &gt;= pWF-&gt;nMax) pWF-&gt;n = 0;

	int offset;
	int idx = pWF-&gt;rbFrameSize * pWF-&gt;n;
	// fill the buffer

	sf_count_t am = sf_readf_float (pWF-&gt;pSndF,&amp;pWF-&gt;pRB[idx], (sf_count_t) pWF-&gt;rbFrameSize);

	if (am == 0) return -3;
	if (am != (sf_count_t) pWF-&gt;rbFrameSize) {
		offset = (sf_count_t) am;
		// calc the missing samples
		am = (sf_count_t) pWF-&gt;rbFrameSize - am;
		// set the buffer to 0
		memset(&amp;pWF-&gt;pRB[idx+offset],0,sizeof(float)*am);
	}
	// build the frame
	// on pos n is the newest frame
	// n+1 is oldest frame
	int nStart = pWF-&gt;n + 1;
	int amount;

	// copy all frames left from the newest block till the wrapping
	amount = pWF-&gt;nMax - nStart;
	if (amount) {
		memcpy(pFrame,&amp;pWF-&gt;pRB[nStart*pWF-&gt;rbFrameSize],sizeof(float)*amount*pWF-&gt;rbFrameSize);
	}
	nStart = amount;
	// wrap and copy the rest of it
	amount = pWF-&gt;nMax - amount;
	memcpy(&amp;pFrame[nStart*pWF-&gt;rbFrameSize],pWF-&gt;pRB,sizeof(float)*amount*pWF-&gt;rbFrameSize);
	// remember that we received a frame(with wrapping)
	pWF-&gt;n++;
	return 0;
}

//! writes a sample to an output
int FrameOverlappedWAVmoduleSetOutput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjFrameOverlappedWAVFile * pWF = FrameOverlappedWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// the last samples at the frame are new
	if (pWF-&gt;rbFrameSize != sf_write_float (pWF-&gt;pSndF,&amp;pFrame[pWF-&gt;n] , pWF-&gt;rbFrameSize)) return -3;

	return 0;
}

// ====================================================================
</Code><Code idCode="102">// ===============================
// AP uuid = 4
// ===============================

// the global var for the Frame WAV modul
TStjFrameWAVmodule gFrameWAVModule;


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// setup the wav modul

	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;input.wav&quot;,1,44100,1,1024,256},
			{2,&quot;output.wav&quot;,0,44100,1,1024,256}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	// closes the wav frame modul
	FrameWAVmoduleExit(&amp;gFrameWAVModule);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="103">// ===============================
// function implementation for initFFT(var id = 130)
// description: init FFT structure
// ===============================

void HALfunc_ID130_initFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  *(pParams[0].fp_integer);
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="104">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  *(pParams[0].fp_integer);
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="105">// ===============================
// function implementation for processFFT(var id = 132)
// description: processes the FFT
// ===============================

void HALfunc_ID132_processFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter fftStruct descr: the fft info structure
	TAPInterpreterVariable ** pfftStruct = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="106">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter ifftStruct descr: the ifft info structure
	TAPInterpreterVariable ** pifftStruct = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="107">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  pParams[0].fp_integer;
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarComplex * py = (TAPvarComplex *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_r2c_1d(N, px-&gt;pR, py-&gt;pC, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="108">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan * pP = pParams[0].fp_pD;
	fftwf_execute(*pP);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="109">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  pParams[0].fp_integer;
	// parameter x descr: input
	TAPvarComplex * px = (TAPvarComplex *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_c2r_1d(N, px-&gt;pC, py-&gt;pR, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="110">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan * pP = pParams[0].fp_pD;
	fftwf_execute(*pP);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="111">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;framebasedBypass.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) return EXIT_FAILURE;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);

	free (varL);
	free (instrL);

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);


#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="112">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer witch receives the samples
	TAPInterpreterVariable ** pframeBuffer = &amp;( pParams[1].fp_pV);

	extern TStjFrameWAVmodule gFrameWAVModule;
};


// parameter channel descr: the channel
	// int32_t* pchannel =  pParams[0].fp_integer;
// parameter resValue descr: the result of the action
	// int32_t* pSample =  pParams[1].fp_pD;
	
	// foreward declaration of the global variable


	if (WAVmoduleGetInput(&amp;gWAVModule,pParams[0].fp_integer,pParams[1].fp_pD)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;</Code><Code idCode="113">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	TAPInterpreterVariable ** pframeBuffer = &amp;( pParams[1].fp_pV);
};
</Code><Code idCode="114">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer witch receives the samples 
	float * pFrame = (float *) pParams[1].fp_pD;
	// parameter waitForNewFrame descr: if not zero the function waits for a new sample frame
	int waitForNewFrame = (int)pParams[2].fp_integer;


	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleGetInput(&amp;gFrameWAVModule,channel,pFrame)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="115">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer which is writen to the channel
error rational vartype
	float * pFrame = (float *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleSetOutput(&amp;gFrameWAVModule,channel,pFrame)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
}</Code><Code idCode="116">// ===============================
// variable implementation for FFT or IFFT sturcture(var id = 30)
// ===============================

// transmit the data
void HALimpl_30_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_30_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_30_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_30_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_30_create (unsigned int numberOfElements) {
	return NULL;
}
// fill the frame with data
void HALimpl_30_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_30_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_30_delete (void * pVarData) {
	if (pVarData) {
		fftwf_destroy_plan(pVarData);
	}
}
</Code><Code idCode="117">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	float * px = (float *) pParams[1].fp_pD;
	
	// parameter y descr: output
	fftwf_complex * py = (fftwf_complex *) pParams[2].fp_pD;
	
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	fftwf_plan P = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);
	*pP = P;

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="118">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	fftwf_complex * px = (fftwf_complex *) pParams[1].fp_pD;
	
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;
	
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	fftwf_plan P = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);
	*pP = P;

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};</Code><Code idCode="119">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan P = (fftwf_plan)pParams[0].fp_pD;
	fftwf_execute(P);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="120">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter fftStruct descr: the fft structure
	fftwf_execute(pParams[0].fp_pV-&gt;pData);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
}</Code><Code idCode="121">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	float * px = (float *) pParams[1].fp_pD;
	
	// parameter y descr: output
	fftwf_complex * py = (fftwf_complex *) pParams[2].fp_pD;

	// parameter fftStruct descr: FFT structure
	TAPInterpreterVariable * pFFTVar = pParams[3].fp_pV;

	if (pFFTVar-&gt;pData) fftwf_destroy_plan(pFFTVar-&gt;pData);
	pFFTVar-&gt;pData = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};


	
</Code><Code idCode="122">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;

	// parameter x descr: input
	fftwf_complex * px = (fftwf_complex *) pParams[1].fp_pD;

	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// parameter fftStruct descr: FFT structure
	TAPInterpreterVariable * pFFTVar = pParams[3].fp_pV;

	if (pFFTVar-&gt;pData) fftwf_destroy_plan(pFFTVar-&gt;pData);
	pFFTVar-&gt;pData = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="123">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter fftStruct descr: the fft structure
	fftwf_execute(pParams[0].fp_pV-&gt;pData);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="124">// The following definition allows the SRU macro to check for errors. Once the routings have
// been verified, this definition can be removed to save some program memory space.
// The preprocessor will issue a warning stating this when using the SRU macro without this
// definition
#define SRUDEBUG  // Check SRU Routings for errors.
#include &lt;SRU.h&gt;

// 256 per channel
#define NUM_SAMPLES (512)

#define DAC4

// =======================================================
// AD 1835 defines
// =======================================================

//
//  AD1835.h
//
//  Configuration values for the AD1835A codec
//

#define DACCTRL1   	(0x0000)  // DAC control register 1    (R/W)
#define DACCTRL2   	(0x1000)  // DAC control register 2    (R/W)
#define DACVOL_L1   (0x2000)  // DAC volume - left 1       (R/W)
#define DACVOL_R1   (0x3000)  // DAC volume - right 1      (R/W)
#define DACVOL_L2   (0x4000)  // DAC volume - left 2       (R/W)
#define DACVOL_R2   (0x5000)  // DAC volume - right 2      (R/W)
#define DACVOL_L3   (0x6000)  // DAC volume - left 3       (R/W)
#define DACVOL_R3   (0x7000)  // DAC volume - right 3      (R/W)
#define DACVOL_L4   (0x8000)  // DAC volume - left 4       (R/W)
#define DACVOL_R4   (0x9000)  // DAC volume - right 4      (R/W)
#define ADCPEAKL   	(0xA000)  // ADC left peak              (R)
#define ADCPEAKR   	(0xB000)  // ADC right peak             (R)
#define ADCCTRL1   	(0xC000)  // ADC control 1             (R/W)
#define ADCCTRL2   	(0xD000)  // ADC control 2             (R/W)
#define ADCCTRL3   	(0xE000)  // ADC control 3             (R/W)

#define RD         	(0x0800)
#define WR         	(0x0000)  // Write to register


// DAC control register 1
#define DEEMPH44_1 	(0x0100)  // Deemphasis filter for 44.1 KHz
#define DEEMPH32   	(0x0200)  // Deemphasis filter for 32.0 KHz
#define DEEMPH48   	(0x0300)  // Deemphasis filter for 48.0 KHz

#define DACI2S     	(0x0000)  // DAC receives I2S format
#define DACRJ      	(0x0020)  // DAC receives I2S format
#define DACDSP     	(0x0040)  // DAC receives I2S format
#define DACLJ      	(0x0060)  // DAC receives I2S format
#define DACPACK256 	(0x0080)  // DAC receives I2S format

#define DAC24BIT   	(0x0000)  // 24-bit output word length
#define DAC20BIT   	(0x0008)  // 20-bit output word length
#define DAC16BIT   	(0x0010)  // 16-bit output word length

#define DACPOWERDN 	(0x0004)  // DAC into power-down mode

#define DACFS48    	(0x0000)  // Sample rate = 48 KHz (x8)
#define DACFS96    	(0x0001)  // Sample rate = 96 KHz (x4)
#define DACFS192   	(0x0002)  // Sample rate = 192 KHz (x2)


// DAC control register 2

#define DACREPLICATE  (0x0100)  // Replicate output of DAC 1/2 on 3/4, 5/6 &amp; 7/8
#define DACMUTE_R4    (0x0080)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L4    (0x0040)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R3    (0x0020)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L3    (0x0010)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R2    (0x0008)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L2    (0x0004)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R1    (0x0002)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L1    (0x0001)  // Mute DAC output channel (clear to un-mute)


//-------------------------------------------------------------------------------
//DAC Volume Control - 10-bit granularity (1024 levels)
#define DACVOL_MIN      (0x000)
#define DACVOL_LOW      (0X100)
#define DACVOL_MED      (0X200)
#define DACVOL_HI       (0X300)
#define DACVOL_MAX      (0x3FF)
#define DACVOL_MASK     (0x3FF)  // Volume in dB is in 10 LSBs
                                 //   3FF = 0 dBFS = 1023/1023
                                 //   3FE = -0.01 dBFS = 1022/1023
                                 //      ...
                                 //   002 = -50.7 dBFS = 3/1023
                                 //   001 = -54.2 dBFS = 2/1023

//-------------------------------------------------------------------------------
//  ADC Control 1

#define ADCHPF     (0x0100)  // High pass filter (AC-coupled)
#define ADCPOWERDN (0x0080)  // DAC into power-down mode
#define ADCFS48    (0x0000)  // Sample rate = 48 KHz
#define ADCFS96    (0x0040)  // Sample rate = 96 KHz

//-------------------------------------------------------------------------------
//  ADC Control 2

#define AUXSLAVE   (0x0000)  // Aux input is in slave mode
#define AUXMASTER  (0x0200)  // Aux input is in master mode

#define ADCI2S     (0x0000)  // ADC transmits in I2S format
#define ADCRJ      (0x0040)  // ADC transmits in right-justified format
#define ADCDSP     (0x0080)  // ADC transmits in DSP (TDM) format
#define ADCLJ      (0x00C0)  // ADC transmits in left-justified format
#define ADCPACK256 (0x0100)  // ADC transmits in packed 256 format
#define ADCAUX256  (0x0180)  // ADC transmits in packed 128 format

#define ADC24BIT   (0x0000)  // 24-bit output word length
#define ADC20BIT   (0x0010)  // 20-bit output word length
#define ADC16BIT   (0x0020)  // 16-bit output word length

#define ADCMUTER   (0x0002)  // Mute right channel from ADC
#define ADCMUTEL   (0x0001)  // Mute right channel from ADC

//-------------------------------------------------------------------------------
//  ADC Control 3

#define IMCLKx2    (0x0000)  // Internal MCLK = external MCLK x 2
#define IMCLKx1    (0x0040)  // Internal MCLK = external MCLK
#define IMCLKx23   (0x0080)  // Internal MCLK = external MCLK x 2/3

#define PEAKRDEN   (0x0020)  // Enable reads of peak ADC levels
#define PEAKLEVELMASK  (0x003F)  // Six significant bit of level
									// 000000 = 0dBFS, -1dB/LSB


// =======================================================
// talk through interface
// =======================================================

// Function prototypes for this talkthrough code

extern void InitPLL_SDRAM(void);
extern void processBlock(unsigned int *);

extern void InitSRU(void);
extern void Init1835viaSPI(void);

extern void InitSPORT(void);
extern void TalkThroughISR(int);
extern void ClearSPORT(void);

extern void SetupSPI1835 (void) ;
extern void DisableSPI1835 (void) ;
extern void Configure1835Register (int i) ;
extern unsigned int Get1835Register (int i) ;

extern void SetupIRQ01 (void) ;
extern void Irq0ISR (int i) ;
extern void Irq1ISR (int i) ;

typedef void (* TFkt_ADSPuartCB) (unsigned int value);

extern void initUART(TFkt_ADSPuartCB cbRXFunction);
extern void UARTisr(int i);
extern void sendUARTuint32Values(unsigned int *pD, int amount);

extern void Delay (int i) ;

// =======================================================
// init AD1835
// =======================================================
/* Setup the SPI pramaters here in a buffer first */
unsigned int Config1835Param [] = {
            WR | DACCTRL1 | DACI2S | DAC24BIT | DACFS48,
            WR | DACCTRL2 ,//| DACMUTE_R4 | DACMUTE_L4,
            WR | DACVOL_L1 | DACVOL_MAX,
            WR | DACVOL_R1 | DACVOL_MAX,
            WR | DACVOL_L2 | DACVOL_MAX,
            WR | DACVOL_R2 | DACVOL_MAX,
            WR | DACVOL_L3 | DACVOL_MAX,
            WR | DACVOL_R3 | DACVOL_MAX,
            WR | DACVOL_L4 | DACVOL_MAX,
            WR | DACVOL_R4 | DACVOL_MAX,
            WR | ADCCTRL1 | ADCFS48,
            WR | ADCCTRL2 | ADCI2S | ADC24BIT,
            WR | ADCCTRL3 | IMCLKx2
        } ;

volatile int spiFlag ;

//Set up the SPI port to access the AD1835
void SetupSPI1835 ()
{
    /* First configure the SPI Control registers */
    /* First clear a few registers     */
    *pSPICTL = (TXFLSH | RXFLSH) ;
    *pSPIFLG = 0;
    *pSPICTL = 0;

    /* Setup the baud rate to 500 KHz */
    *pSPIBAUD = 100;

    /* Setup the SPI Flag register to FLAG3 : 0xF708*/
    *pSPIFLG = 0xF708;

    /* Now setup the SPI Control register : 0x5281*/
    *pSPICTL = (SPIEN | SPIMS | MSBF | WL16 | TIMOD1) ;

}

//Disable the SPI Port
void DisableSPI1835 ()
{
    *pSPICTL = (TXFLSH | RXFLSH);
}

//Send a word to the AD1835 via SPI
void Configure1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI to indicate that it has finished.
    while (1)
    {
        if (*pSPISTAT &amp; SPIF)
            break ;
    }
    Delay (100) ;
}

//Receive a register setting from the AD1835
unsigned int Get1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI port to indicate that it has finished
    while (1)
    {
        if (SPIF &amp; *pSPISTAT)
            break ;
    }
    Delay (100) ;
    return *pRXSPI ;
//  return i ;
}

//Set up all AD1835 registers via SPI
void Init1835viaSPI()
{
    int configSize = sizeof (Config1835Param) / sizeof (int) ;
    int i ;

    SetupSPI1835 () ;

    for (i = 0; i &lt; configSize; ++i)
    {
        Configure1835Register (Config1835Param[i]) ;
    }

    DisableSPI1835 () ;

}

//Delay loop
void Delay (int i)
{
    for (;i&gt;0;--i)
        asm (&quot;nop;&quot;) ;
}

// =======================================================
// PLL for SDRAM init
// =======================================================
void InitPLL_SDRAM(){

int i, pmctlsetting;

//Change this value to optimize the performance for quazi-sequential accesses (step &gt; 1)
#define SDMODIFY 1

    pmctlsetting= *pPMCTL;
    pmctlsetting &amp;= ~(0xFF); //Clear

    // CLKIN= 24.576 MHz, Multiplier= 27, Divisor= 1, INDIV=1, CCLK_SDCLK_RATIO= 2.
    // Core clock = (24.576 MHz * 27) /2 = 331.776 MHz
    pmctlsetting= SDCKR2|PLLM27|INDIV|DIVEN;
    *pPMCTL= pmctlsetting;
    pmctlsetting|= PLLBP;
    *pPMCTL= pmctlsetting;

    //Wait for around 4096 cycles for the pll to lock.
    for (i=0; i&lt;4096; i++)
          asm(&quot;nop;&quot;);

    *pPMCTL ^= PLLBP;       //Clear Bypass Mode
    *pPMCTL |= (CLKOUTEN);  //and start clkout


    // Programming SDRAM control registers and enabling SDRAM read optimization
    // CCLK_SDCLK_RATIO= 2.5
    // RDIV = ((f SDCLK X t REF )/NRA) - (tRAS + tRP )
    // (166*(10^6)*64*(10^-3)/4096) - (7+3) = 2583

    *pSDRRC= (0xA17)|(SDMODIFY&lt;&lt;17)|SDROPT;

    //===================================================================
    //
    // Configure SDRAM Control Register (SDCTL) for PART MT48LC4M32B2
    //
    //  SDCL3  : SDRAM CAS Latency= 3 cycles
    //  DSDCLK1: Disable SDRAM Clock 1
    //  SDPSS  : Start SDRAM Power up Sequence
    //  SDCAW8 : SDRAM Bank Column Address Width= 8 bits
    //  SDRAW12: SDRAM Row Address Width= 12 bits
    //  SDTRAS7: SDRAM tRAS Specification. Active Command delay = 7 cycles
    //  SDTRP3 : SDRAM tRP Specification. Precharge delay = 3 cycles.
    //  SDTWR2 : SDRAM tWR Specification. tWR = 2 cycles.
    //  SDTRCD3: SDRAM tRCD Specification. tRCD = 3 cycles.
    //
    //--------------------------------------------------------------------

    *pSDCTL= SDCL3|DSDCLK1|SDPSS|SDCAW8|SDRAW12|SDTRAS7|SDTRP3|SDTWR2|SDTRCD3;

    // Note that MS2 &amp; MS3 pin multiplexed with flag2 &amp; flag3.
    // MSEN bit must be enabled to access SDRAM, but LED7 cannot be driven with sdram
    *pSYSCTL |=MSEN;

    // Mapping Bank 2 to SDRAM
    // Make sure that jumper is set appropriately so that MS2 is connected to
    // chip select of 16-bit SDRAM device
    *pEPCTL |=B2SD;
    *pEPCTL &amp;= ~(B0SD|B1SD|B3SD);

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL0) Bank 0 for the ISSI IS61LV5128
    //
    //  WS2 : Wait States = 2 cycles
    //  HC1  : Bus Hold Cycle (at end of write access)= 1 cycle.
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //SRAM Settings
    *pAMICTL0 = WS2|HC1|AMIEN|BW8;

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL) Bank 1 for the AMD AM29LV08
    //
    //  WS23 : Wait States= 23 cycles
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //Flash Settings
    *pAMICTL1 = WS23|AMIEN|BW8;
}

// =======================================================
// serial Port
// =======================================================
/*
   Here is the mapping between the SPORTS and the DACS
   ADC -&gt; DSP  : SPORT0A : I2S
   DSP -&gt; DAC1 : SPORT1A : I2S
   DSP -&gt; DAC2 : SPORT1B : I2S
   DSP -&gt; DAC3 : SPORT2A : I2S
   DSP -&gt; DAC4 : SPORT2B : I2S
*/

unsigned int PCI = 0x00080000 ;
unsigned int OFFSET = 0x00080000 ;

// TCB blocks for Chaining
//Each block will be used for:
//      Filling from the ADC
//      Processing filled data
//      Sending to DAC
//
//Each one is doing only one of these steps for each SPORT interrupt.

//For this example the startup state is
// Start to 1st interrupt: gBlock_A is filled first, gBlock_C is sent
// 1st int to 2nd int: gBlock_C filled, gBlock_A processed, gBlock_B sent
// 2nd int to 3rd int: gBlock_B filled, gBlock_C processed, gBlock_A sent
// 3rd int to 4th int: gBlock_A filled, gBlock_B processed, gBlock_C sent
unsigned int gBlock_A[NUM_SAMPLES] ;
unsigned int gBlock_B[NUM_SAMPLES] ;
unsigned int gBlock_C[NUM_SAMPLES] ;

//Set up the TCBs to rotate automatically
int TCB_gBlock_A[4] = { 0, sizeof(gBlock_A), 1, 0};;
int TCB_gBlock_B[4] = { 0, sizeof(gBlock_B), 1, 0};
int TCB_gBlock_C[4] = { 0, sizeof(gBlock_C), 1, 0};

void InitSPORT()
{
    //Proceed from Block A to Block C
    TCB_gBlock_A[0] = (int) TCB_gBlock_C + 3 - OFFSET + PCI ;
    TCB_gBlock_A[3] = (unsigned int) gBlock_A - OFFSET ;

    //Proceed from Block B to Block A
    TCB_gBlock_B[0] = (int) TCB_gBlock_A + 3 - OFFSET + PCI ;
    TCB_gBlock_B[3] = (unsigned int) gBlock_B - OFFSET ;

    //Proceed from Block C to Block B
    TCB_gBlock_C[0] = (int) TCB_gBlock_B + 3 - OFFSET + PCI ;
    TCB_gBlock_C[3] = (unsigned int) gBlock_C - OFFSET ;

    //Clear the Mutlichannel control registers
    *pSPMCTL0 = 0;
    *pSPMCTL1 = 0;
    *pSPMCTL2 = 0;
    *pSPCTL0 = 0 ;
    *pSPCTL1 = 0 ;
    *pSPCTL2 = 0 ;

    //============================================================
    //
    // Configure SPORT 0 for input from ADC
    //
    //------------------------------------------------------------


    *pSPCTL0 = (OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A);

    // Enabling Chaining
    // Block A will be filled first
    *pCPSP0A = (unsigned int) TCB_gBlock_A - OFFSET + 3 ;

    //============================================================
    //
    // Configure SPORTs 1 &amp; 2 for output to DACs 1-4
    //
    //------------------------------------------------------------

    #ifdef DAC1
    *pSPCTL1 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC1
    *pCPSP1A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC2
    *pSPCTL1 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC2
    *pCPSP1B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC3
    *pSPCTL2 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC3
    *pCPSP2A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC4
    *pSPCTL2 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC4
    *pCPSP2B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif
}


// =======================================================
// init SRU
// =======================================================

void InitSRU(){

//-----------------------------------------------------------------------------
//
//  MCLK: The output of the 12.288 MHz xtal is either directly connected to the
//        codec, but also connected to DAI_P06, or just to DAI_P17. This is
//        determined by switch SW3 For this example we route the MCLK into
//        DAI_P17 and supply the clock to the ADC via DAI_P06  by routing the
//        signal through the SRU.

//  Tie the pin buffer input LOW.
    SRU(LOW,DAI_PB17_I);

//  Tie the pin buffer enable input LOW
    SRU(LOW,PBEN17_I);

//-----------------------------------------------------------------------------
//
//  Connect the ADC: The codec drives a BCLK output to DAI pin 7, a LRCLK
//          (a.k.a. frame sync) to DAI pin 8 and data to DAI pin 5.
//
//          Connect the ADC to SPORT0, using data input A
//
//          All three lines are always inputs to the SHARC so tie the pin
//          buffer inputs and pin buffer enable inputs all low.


//------------------------------------------------------------------------
//  Connect the ADC to SPORT0, using data input A

    //  Clock in on pin 7
    SRU(DAI_PB07_O,SPORT0_CLK_I);

    //  Frame sync in on pin 8
    SRU(DAI_PB08_O,SPORT0_FS_I);

    //  Data in on pin 5
    SRU(DAI_PB05_O,SPORT0_DA_I);

//------------------------------------------------------------------------
//    Tie the pin buffer inputs LOW for DAI pins 5, 7 and 8.  Even though
//    these pins are inputs to the SHARC, tying unused pin buffer inputs
//    LOW is &quot;good coding style&quot; to eliminate the possibility of
//    termination artifacts internal to the IC.  Note that signal
//    integrity is degraded only with a few specific SRU combinations.
//    In practice, this occurs VERY rarely, and these connections are
//    typically unnecessary.


    SRU(LOW,DAI_PB05_I);
    SRU(LOW,DAI_PB07_I);
    SRU(LOW,DAI_PB08_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs LOW for DAI pins 5, 6, 7 and 8 so
//  that they are always input pins.

    SRU(LOW,PBEN05_I);
    SRU(LOW,PBEN07_I);
    SRU(LOW,PBEN08_I);

//-----------------------------------------------------------------------------
//
//  Connect the DACs: The codec accepts a BCLK input from DAI pin 13 and
//          a LRCLK (a.k.a. frame sync) from DAI pin 14 and has four
//          serial data outputs to DAI pins 12, 11, 10 and 9
//
//          Connect DAC1 to SPORT1, using data output A
//          Connect DAC2 to SPORT1, using data output B
//          Connect DAC3 to SPORT2, using data output A
//          Connect DAC4 to SPORT2, using data output B
//
//          Connect the clock and frame sync inputs to SPORT1 and SPORT2
//          should come from the ADC on DAI pins 7 and 8, respectively
//
//          Connect the ADC BCLK and LRCLK back out to the DAC on DAI
//          pins 13 and 14, respectively.
//
//          All six DAC connections are always outputs from the SHARC
//          so tie the pin buffer enable inputs all high.
//

//------------------------------------------------------------------------
//  Connect the pin buffers to the SPORT data lines and ADC BCLK &amp; LRCLK

    SRU(SPORT2_DB_O,DAI_PB09_I);
    SRU(SPORT2_DA_O,DAI_PB10_I);
    SRU(SPORT1_DB_O,DAI_PB11_I);
    SRU(SPORT1_DA_O,DAI_PB12_I);

//------------------------------------------------------------------------
//  Connect the clock and frame sync input from the ADC directly
//    to the output pins driving the DACs.

    SRU(DAI_PB07_O,DAI_PB13_I);
    SRU(DAI_PB08_O,DAI_PB14_I);
    SRU(DAI_PB17_O,DAI_PB06_I);

//------------------------------------------------------------------------
//  Connect the SPORT clocks and frame syncs to the clock and
//  frame sync from the SPDIF receiver

    SRU(DAI_PB07_O,SPORT1_CLK_I);
    SRU(DAI_PB07_O,SPORT2_CLK_I);
    SRU(DAI_PB08_O,SPORT1_FS_I);
    SRU(DAI_PB08_O,SPORT2_FS_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs HIGH to make DAI pins 9-14 outputs.
    SRU(HIGH,PBEN06_I);
    SRU(HIGH,PBEN09_I);
    SRU(HIGH,PBEN10_I);
    SRU(HIGH,PBEN11_I);
    SRU(HIGH,PBEN12_I);
    SRU(HIGH,PBEN13_I);
    SRU(HIGH,PBEN14_I);
//--------------------------------------------------------------------------
// Route SPI signals to AD1835.

    SRU(SPI_MOSI_O,DPI_PB01_I)      //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I)     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I)      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG3_O, DPI_PB04_I)     //Connect SPI FLAG3 to DPI PB4.
//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peipherals to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG3_PBEN_O, DPI_PBEN04_I);

//-----------------------------------------------------------------------------
// UART config
    SRU2(UART0_TX_O,DPI_PB09_I); // UART transmit signal is connected to DPI pin 9
    SRU2(HIGH,DPI_PBEN09_I);
    SRU2(DPI_PB10_O,UART0_RX_I); // connect the pin buffer output signal to the UART0 receive
    SRU2(LOW,DPI_PB10_I);
    SRU2(LOW,DPI_PBEN10_I);      // disables DPI pin10 as input
}

// =======================================================
// IRQ's
// =======================================================
void SetupIRQ01 ()
{
    //Enable the pins as IRQ0 and IRQ1
    *pSYSCTL|= IRQ0EN | IRQ1EN;
    asm (&quot;#include &lt;def21369.h&gt;&quot;) ;
    //Set the IRQ pins to be edge sensitive
    asm (&quot;bit set mode2 IRQ0E;&quot;) ;
    asm (&quot;bit set mode2 IRQ1E;&quot;) ;
}

void Irq0ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ0 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol -= 0x3F ;
    rightDAC4Vol -= 0x3F ;

    if (leftDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

void Irq1ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ1 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol += 0x3F ;
    rightDAC4Vol += 0x3F ;

    if (leftDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

// =======================================================
// UART
// =======================================================

// type for the low level receive
typedef struct SADSPuartRecv {
	unsigned int 	val;	//!&lt; the value
	int				i;		//!&lt; the index
	TFkt_ADSPuartCB cb;		//!&lt; the callback function when we received 4 bytes of data
} TADSPuartRecv;

TADSPuartRecv gUARTrx;


// init ADSP uart
//          Bits per Second  -&gt; 19200
//          Data Bits        -&gt; 8
//          Parity           -&gt; odd
//          Stop Bits        -&gt; 2
//          Flow Control     -&gt; None
void initUART(TFkt_ADSPuartCB cbRXFunction) {
	// Sets the Baud rate for UART0
	*pUART0LCR = UARTDLAB;  //enables access to Divisor register to set baud rate
//	*pUART0DLL = 0x1c;      //0x21c = 540 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
//    *pUART0DLH = 0x02;

	*pUART0DLL = 0x38;      //1080 = 0x438 for divisor value and gives a baud rate of 9600 for core clock 331.776MHz
	*pUART0DLH = 0x04;



    // Configures UART0 LCR
//    *pUART0LCR = UARTWLS8| 				// word length 8
//                 UARTPEN| 				// parity enable ODD parity
//                 UARTSTB ; 				// Two stop bits
	*pUART0LCR = UARTWLS8;	// 8Bit 1StopBit NoParity

    //enables UART0 in receive mode
    *pUART0RXCTL = UARTEN;
    //enables UART0 in core driven mode
    *pUART0TXCTL = UARTEN;

    // set rx callback function and the state machine
    gUARTrx.val = 0;
    gUARTrx.i = 3;
    gUARTrx.cb = cbRXFunction;
}

// UART isr
void UARTisr(int i) {
	unsigned int v;
	v = *pUART0RBR;
	// shift register
	gUARTrx.val &lt;&lt;= 8;
	gUARTrx.val |= v;
	if (gUARTrx.i) {
		gUARTrx.i--;
	} else {
		gUARTrx.cb(gUARTrx.val);
		gUARTrx.i = 3;
		gUARTrx.val = 0;
	}
}

// UART send
// the system encoding of int values is big endian
// the uart send stream put this out as little endian
// value: 32 - 0 Bit 44 33 22 11
// @ADSP: 11 22 33 44
// send: 44 33 22 11 = little endian
void sendUARTuint32Value(unsigned int v) {
	// 44
	// wait till the transmitter is ready
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
	// mask all other bytes out and send the lowest byte
	*pUART0THR = v &amp; 0xFF;
	v &gt;&gt;= 8;

	// 33
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
	*pUART0THR = v &amp; 0xFF;
	v &gt;&gt;= 8;

	// 22
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
	*pUART0THR = v &amp; 0xFF;
	v &gt;&gt;= 8;

	// 11
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
	*pUART0THR = v &amp; 0xFF;

	// wait till the transmitter is ready
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
}

void sendUARTFloatVector (float * pD, int amount) {
	uint32_t * pS = (uint32_t *) pD;
	while (amount) {
		sendUARTuint32Value(*pS);
		pS++;
		amount--;
	}
}

void sendUARTraw4ByteVector (uint32_t * pD, int amount) {
	while (amount) {
		sendUARTuint32Value(*pD);
		pD++;
		amount--;
	}
}


void sendUARTintVectorBigEndian (int32_t * pD, int amount) {
	uint32_t * pS = (uint32_t *) pD;
	unsigned int v;
	while (amount) {
		// rotate bytes
		v = (*pS &amp; 0x000000FF) &lt;&lt; 24;
		v |= (*pS &amp; 0x0000FF00) &lt;&lt; 8;
		v |= (*pS &amp; 0x00FF0000) &gt;&gt; 8;
		v |= (*pS &amp; 0xFF000000) &gt;&gt; 24;
		// send value
		sendUARTuint32Value(v);
		pS++;
		amount--;
	}
}

void sendUARTuintVectorBigEndian (uint32_t * pD, int amount) {
	uint32_t * pS = (uint32_t *) pD;
	unsigned int v;
	while (amount) {
		// rotate bytes
		v = (*pS &amp; 0x000000FF) &lt;&lt; 24;
		v |= (*pS &amp; 0x0000FF00) &lt;&lt; 8;
		v |= (*pS &amp; 0x00FF0000) &gt;&gt; 8;
		v |= (*pS &amp; 0xFF000000) &gt;&gt; 24;

		// send value
		sendUARTuint32Value(v);
		pS++;
		amount--;
	}
}

// =======================================================
// SPORT IRQs
// =======================================================

    //Pointer to the blocks

unsigned int *gpProcessBuffer[3] = {gBlock_A,gBlock_C,gBlock_B};

// Counter to choose which buffer to process
volatile int gProcessBufferCounter=2;
// Semaphore to indicate to main that a block is ready for processing
volatile int gProcessBufferReady=0;

void TalkThroughISR(int sig_int)
{
    //Increment the block pointer
    gProcessBufferCounter++;
    gProcessBufferCounter %= 3;

    gProcessBufferReady = 1;
}

// =======================================================
// LED func
// =======================================================

void LEDSRUinit () {
	// Init LED Ports
	SRU(LOW,DPI_PB06_I);				// Connect GND to DPI_PB06 input (LED1)
	SRU(LOW,DPI_PB07_I);	    		// Connect GND to DPI_PB07 input (LED2)
	SRU(LOW,DPI_PB08_I);	    		// Connect GND to DPI_PB08 input (LED3)
	SRU(LOW,DPI_PB13_I);	    		// Connect GND to DPI_PB13 input (LED4)
	SRU(LOW,DPI_PB14_I);	    		// Connect GND to DPI_PB14 input (LED5)
	SRU(LOW,DAI_PB15_I);		  		// Connect GND to DAI_PB15 input (LED6)
	SRU(LOW,DAI_PB16_I);  				// Connect GND to DAI_PB16 input (LED7)

	//Enabling the Buffer using the following sequence: High -&gt; Output, Low -&gt; Input

	SRU(HIGH,DPI_PBEN06_I);				// LED 1
	SRU(HIGH,DPI_PBEN07_I);				// LED 2
	SRU(HIGH,DPI_PBEN08_I);				// LED 3
	SRU(HIGH,DPI_PBEN13_I);				// LED 4
	SRU(HIGH,DPI_PBEN14_I);				// LED 5
	SRU(HIGH,PBEN15_I);					// LED 6
	SRU(HIGH,PBEN16_I);					// LED 7
}

#define set_LED_1 SRU(HIGH,DPI_PB06_I)
#define set_LED_2 SRU(HIGH,DPI_PB07_I)
#define set_LED_3 SRU(HIGH,DPI_PB08_I)
#define set_LED_4 SRU(HIGH,DPI_PB13_I)
#define set_LED_5 SRU(HIGH,DPI_PB14_I)
#define set_LED_6 SRU(HIGH,DPI_PB15_I)
#define set_LED_7 SRU(HIGH,DPI_PB16_I)

#define clear_LED_1 SRU(LOW,DPI_PB06_I)
#define clear_LED_2 SRU(LOW,DPI_PB07_I)
#define clear_LED_3 SRU(LOW,DPI_PB08_I)
#define clear_LED_4 SRU(LOW,DPI_PB13_I)
#define clear_LED_5 SRU(LOW,DPI_PB14_I)
#define clear_LED_6 SRU(LOW,DPI_PB15_I)
#define clear_LED_7 SRU(LOW,DPI_PB16_I)

// =======================================================
// init HW
// =======================================================

void initHW(TFkt_ADSPuartCB cbRXFunction) {

	// uart stuff
	*pPICR2 &amp;= ~(0x3E0); //Sets the UART0 receive interrupt to P13

	*pPICR2 |= (0x13&lt;&lt;5);


    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

	*pUART0LCR=0;
    *pUART0IER   = UARTRBFIE;    // enables UART0 receive interrupt
	interrupt(SIG_P13,UARTisr);


    // init LEDs
    LEDSRUinit();

    // init UART
    initUART (cbRXFunction);
}

void startHW() {
    // Finally setup the sport to receive / transmit the data
    InitSPORT();
}


// =======================================================
// processing
// =======================================================


#ifndef INT24_MAX
	#define INT24_MIN (-16777215-1)
	#define INT24_MAX (16777215)
#endif

#define dAD1835_ChannelAmount (2)
#define dAD1835_leftChannelOffset (1)
#define dAD1835_rightChannelOffset (0)

#define dAD1835_ChannelFlag_left ('l')
#define dAD1835_ChannelFlag_right ('r')

// the adsp codec channel type
typedef struct SCodecChannel {
	unsigned int 	size;			//!&lt; size of the channel
	char			channelFlag;	//!&lt; l=left r=right channel
} TCodecChannel;

// the codec channel list
typedef struct SCodecChannelList {
	TCodecChannel *		pCC;
	int					number;
} TCodecChannelList;

// find the channel struct by a given channel
inline TCodecChannel * ADSP_getChannel (int channel) {
	extern TCodecChannelList gADSPcodecChannels;
	if ((channel &lt; 0) || (channel &gt;= gADSPcodecChannels.number)) return NULL;
	return &amp;gADSPcodecChannels.pCC[channel];
}

// wait for the sample frame
inline void ADSP_waitForSamples () {
	if (!gProcessBufferReady) {
		set_LED_1;
		while (!gProcessBufferReady) {

		};
		gProcessBufferReady = 0;
		clear_LED_1;
	}
}

// ADSP ADC 24Bit value format
// 011...11		+FS
// 0......0		0
// 111...11		-FS
//
// reads some samples from the input channel
void ADSP_readSamplesFromChannel (TCodecChannel * pIC, float * pBuffer, unsigned int amount, int waitForNewFrame) {
	// wait for new samples
	if (waitForNewFrame)	ADSP_waitForSamples ();

	// after that get the pointer to the buffer
	int * pBinSRC  = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pIC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}

//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBuffer = ((float) ((int)(*pBinSRC)&lt;&lt;8)) * (1.0/2147483648.0);
		pBuffer++;
		pBinSRC += dAD1835_ChannelAmount;
	}
}


// writes some samples to the output channel
void ADSP_writesSamplesToChannel (TCodecChannel * pOC, float * pBuffer, unsigned int amount) {
	int * pBinSRC = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	float tv;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pOC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}
//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBinSRC = ((int)(2147483648.0 * pBuffer[i]))&gt;&gt;8;
		pBinSRC += dAD1835_ChannelAmount;
	}
}

TCodecChannel gADSPcodecChannel []= {
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left},	// ADC left input
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left}	// DAC4 &amp; DAC3 left output
};

TCodecChannelList gADSPcodecChannels = {
		gADSPcodecChannel,
		sizeof(gADSPcodecChannel) / sizeof(TCodecChannel)
};
</Code><Code idCode="125">// ===============================
// AP uuid = 5
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="126">void main(void)
{

    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

    // Finally setup the sport to receive / transmit the data
    InitSPORT();

    // Be in infinite loop and do nothing until done.
/*    for(;;)
    {
     while(blockReady)
          processBlock(src_pointer[int_cntr]);
    }
*/
	#define dfBufferL (256)
    float fBuffer[dfBufferL];

    TCodecChannel iC = {0,NUM_SAMPLES};
    TCodecChannel oC = {0,NUM_SAMPLES};

    for (;;) {
    	readSamplesFromChannel(&amp;iC,fBuffer,dfBufferL);
    	writesSamplesFromChannel(&amp;oC,fBuffer,dfBufferL);
    	clear_LED(1);
    }
}
</Code><Code idCode="127">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPgenericRationalVector * pRV = (TAPgenericRationalVector *) pParams[1].fp_pD;
// parameter waitForNewFrame descr: if not zero the function waits for a new sample frame
	int waitForNewFrame = (int)pParams[2].fp_integer;

	TCodecChannel * pC;
	
	// the channels at the AP starts with 1; at the ADSP with 0
	pC = ADSP_getChannel((int)pParams[0].fp_integer-1);
	if (!pC) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}

	ADSP_readSamplesFromChannel(pC,pRV-&gt;pVal,pRV-&gt;num, waitForNewFrame);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="128">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="129">// ===============================
// function implementation for convoluteVectorBiquad(var id = 111)
// description: convolute biquad with a vector of inputs and generate an output vector
// ===============================

void HALfunc_ID111_convoluteVectorBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPInterpreterVariable ** px = &amp;( pParams[0].fp_pV);
// parameter bqa descr: biquad array
	TAPInterpreterVariable ** pbqa = &amp;( pParams[1].fp_pV);
// parameter y descr: output
	TAPInterpreterVariable ** py = &amp;( pParams[2].fp_pV);
};
</Code><Code idCode="130">// ===============================
// function implementation for shiftVectorDelay(var id = 151)
// description: shifts a vector into a delay and the content of the delay to a vector
// ===============================

void HALfunc_ID151_shiftVectorDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPInterpreterVariable ** px = &amp;( pParams[0].fp_pV);
// parameter delay descr: the delay
	TAPInterpreterVariable ** pdelay = &amp;( pParams[1].fp_pV);
// parameter y descr: output
	TAPInterpreterVariable ** py = &amp;( pParams[2].fp_pV);
};
</Code><Code idCode="131">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="132">// ===============================
// AP uuid = 6
// ===============================

#define WAVsampleCache (65536)

// the wav modul global var
TStjWAVmodule gWAVModule;


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system

	// init wav module
	TStjWAVOpenInfo wavIOs[] = {
			{1,&quot;input.wav&quot;,1,44100,0,WAVsampleCache},
			{2,&quot;bypass.wav&quot;,0,44100,0,WAVsampleCache},
			{3,&quot;subbass.wav&quot;,0,44100,0,WAVsampleCache},
			{4,&quot;lowerVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{5,&quot;upperVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{6,&quot;harmonics.wav&quot;,0,44100,0,WAVsampleCache},
	};

	if (WAVmoduleInit (sizeof(wavIOs) / sizeof(TStjWAVOpenInfo),wavIOs,&amp;gWAVModule)) {
		return -2;
	}

	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close wav module
	WAVmoduleExit(&amp;gWAVModule);

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="133">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="134">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

#ifndef dAPuseExternalAPCode
// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif

#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

#ifndef dAPuseExternalAPCode
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#else
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifndef dAPuseExternalAPCode
	free (varL);
	free (instrL);
#endif

#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="135">// ===============================
// AP uuid = 7
// ===============================
// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	initHW(drv_2_cbAPClient);

	startHW();

	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// reset the interpreter
void APInterpreterReset (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;
}


int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	APInterpreterReset(IP);

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;state, msgEndian);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;index, msgEndian);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID, msgEndian);
		APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;index, msgEndian);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;fid, msgEndian);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}


// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i], msgEndian);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}


// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}</Code><Code idCode="136">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter resValue descr: the result of the action
	void ** presValue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="137">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPgenericRationalVector * pRV = (TAPgenericRationalVector *) pParams[1].fp_pD;

	TCodecChannel * pC;

	// the channels at the AP starts with 1; at the ADSP with 0
	pC = ADSP_getChannel((int)pParams[0].fp_integer-1);
	if (!pC) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}

	ADSP_writesSamplesToChannel(pC,pRV-&gt;pVal,pRV-&gt;num);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="138">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;DAP26.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

int main()
{
	int rc;

	rc = APinit(&amp;AP,21369,NULL,0,50,eAP_bigEndian);

	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,gAPendianFlag,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="139">// ===============================
// function implementation for convoluteVectorBiquad(var id = 111)
// description: convolute biquad with a vector of inputs and generate an output vector
// ===============================

void HALfunc_ID111_convoluteVectorBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPvarRational * pxA = (TAPvarRational *) pParams[0].fp_pD;
// parameter bqa descr: biquad array
	TAPvarBiquad * pbqa = (TAPvarBiquad *) pParams[1].fp_pD;
// parameter y descr: output
	TAPvarRational * pyA = (TAPvarRational *) pParams[2].fp_pD;

	float * px;
	float * py;
	int i, j, imax, jmax;
	float d1, y;
	TAPBiquadDF2 * pF;

	py = pyA-&gt;pR;
	px = pxA-&gt;pR;
	imax = pxA-&gt;num;
	jmax = pbqa-&gt;num;

	for (i = 0; i &lt; imax; i++) {
		y = *px;
		pF = pbqa-&gt;pB;
		for (j = 0; j &lt; jmax; j++) {
			// filter
			d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + y); // y = x
			y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
			y *= pF-&gt;k;

			pF-&gt;s2 = pF-&gt;s1;
			pF-&gt;s1 = d1;
			// output is input for the next filter
			pF++;
		}

		// save result to the output
		*py = y;
		px++;
		py++;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="140">// ############################################
// block based processing without overlapped operations
// ############################################

#define dStjFrameWAVinitialFrameAmount (1024)

typedef struct SStjFrameWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input

	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)
} TStjFrameWAVOpenInfo;

typedef struct SStjFrameWAVFile {
	unsigned int	channel;				//!&lt; the channel
	SNDFILE *		pSndF;					//!&lt; the file
	unsigned int	isInput;				//!&lt; if 0 the channel is an input channel


	float *			pFrameBuffer;			//!&lt; the buffer witch is filled with the frames
	int				fileChannels;			//!&lt; the amount of sample channels at the file
	int				activeChannel;			//!&lt; the channel used to read
	int				frameAmount;			//!&lt; amount of frame
} TStjFrameWAVFile;

typedef struct SStjFrameWAVmodule {
	TStjFrameWAVFile *	pChannels;
	unsigned int		number;
} TStjFrameWAVmodule;

//! close the set of wav files
void FrameWAVmoduleExit (TStjFrameWAVmodule * pM);

//! initis a set of wav files for writing / reading
int FrameWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	);

//! looking for the right channel
TStjFrameWAVFile * FrameWAVmoduleFindChannel (
		TStjFrameWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
	);

//! reads a sample from a channel
int FrameWAVmoduleGetInput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be read
		float *					pFrame			//!&lt;(out) pointer to the sample buffer witch is filled
	);

//! writes a sample to an output
int FrameWAVmoduleSetOutput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be write
		float *					pFrame			//!&lt;(in) pointer to the sample buffer witch is filled
	);

//! close the set of wav files
void FrameWAVmoduleExit (TStjFrameWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjFrameWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		sf_close(pWF-&gt;pSndF);
		if (pWF-&gt;pFrameBuffer) free (pWF-&gt;pFrameBuffer);
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int FrameWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjFrameWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjFrameWAVFile) * number);
	pModul-&gt;number = number;

	int 				i;
	SF_INFO 			info;
	TStjFrameWAVFile * 	pWF = pModul-&gt;pChannels;

	for (i = 0;i &lt; number;i++) {
		// open sndfile interface
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info);
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info);
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;


		if (pWAVFiles[i].isInput) {
			pWF-&gt;pFrameBuffer = malloc (sizeof(float)*info.channels*dStjFrameWAVinitialFrameAmount);
			if (!pWF-&gt;pFrameBuffer) {
				goto error;
			}
			pWF-&gt;frameAmount = dStjFrameWAVinitialFrameAmount;
		}

		// the file channel starts at 1 - here we start at 0
		pWF-&gt;activeChannel = pWAVFiles[i].fileChannelNumber - 1;
		pWF-&gt;fileChannels = (int) info.channels;

		pWF++;
	}
	return 0;
error:
	FrameWAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjFrameWAVFile * FrameWAVmoduleFindChannel (
		TStjFrameWAVmodule *	pM,		//!&lt; the module
		int						channel	//!&lt; channel to search for
		) {
	TStjFrameWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int FrameWAVmoduleGetInput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be read
		float *					pFrame			//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjFrameWAVFile * pWF = FrameWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}

	// check the temp buffer size
	if (pWF-&gt;frameAmount &lt; sampleNumber) {
		pWF-&gt;pFrameBuffer = realloc(pWF-&gt;pFrameBuffer,sizeof(float)*pWF-&gt;fileChannels*sampleNumber);
		if (!pWF-&gt;pFrameBuffer) {
			return -3;
		}
		pWF-&gt;frameAmount = sampleNumber;
	}

	// fill the buffer
	int am = (int) sf_readf_float (pWF-&gt;pSndF,pWF-&gt;pFrameBuffer, sampleNumber);

	if (am &lt;= 0) {
		return -4;
	}

	// copy buffer
	int i;
	float * pD = pFrame;
	float * pS = pWF-&gt;pFrameBuffer;
	// add the offset so we start at the right pos at the frame
	pS += pWF-&gt;activeChannel;
	for (i = 0; i &lt; am; i++) {
		*pD = *pS;
		pD++;
		pS+= pWF-&gt;fileChannels;
	}
	// and fill the rest with 0.
	for (;i &lt; sampleNumber; i++) {
		*pD = 0.0f;
		pD++;
	}
	return 0;
}

//! writes a sample to an output
int FrameWAVmoduleSetOutput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be write
		float *					pFrame			//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjFrameWAVFile * pWF = FrameWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// the last samples at the frame are new
	if (sampleNumber != sf_write_float (pWF-&gt;pSndF,pFrame, sampleNumber)) return -3;
	return 0;
}
</Code><Code idCode="141">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer witch receives the samples
	TAPgenericRationalVector * pRA = (TAPgenericRationalVector *) pParams[1].fp_pD;
// parameter waitForNewFrame descr: if not zero the function waits for a new sample frame
	int waitForNewFrame = (int)pParams[2].fp_integer;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleGetInput(&amp;gFrameWAVModule,(int)channel,pRA-&gt;num,pRA-&gt;pVal)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="142">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	TAPgenericRationalVector * pRA = (TAPgenericRationalVector *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleSetOutput(&amp;gFrameWAVModule,(int)channel,pRA-&gt;num,pRA-&gt;pVal)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="143">// ===============================
// AP uuid = 8
// ===============================

// the global var for the Frame WAV modul
TStjFrameWAVmodule gFrameWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;x.wav&quot;,1,48000,1},
			{2,&quot;y.wav&quot;,0,48000,1}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	// closes the wav frame modul
	FrameWAVmoduleExit(&amp;gFrameWAVModule);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="144">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="145">// ======================================================
// MSP 430 API
// ======================================================

#define   dMSP430_LED1_ON         P3OUT &amp;= ~BIT6
#define   dMSP430_LED1_OFF        P3OUT |= BIT6
#define   dMSP430_LED2_ON         P3OUT &amp;= ~BIT7
#define   dMSP430_LED2_OFF        P3OUT |= BIT7
#define   dMSP430_B1              BIT5&amp;P1IN         //B1 - P1.5
#define   dMSP430_B2              BIT6&amp;P1IN         //B2 - P1.6
#define   dMSP430_B3              BIT7&amp;P1IN         //B3 - P1.7
#define   dMSP430_E_HIGH          P4OUT |= BIT1
#define   dMSP430_E_LOW           P4OUT &amp;= ~BIT1
#define   dMSP430_RS_HIGH         P4OUT |= BIT3
#define   dMSP430_RS_LOW          P4OUT &amp;= ~BIT3
#define   dMSP430_LCD_Data        P4OUT
#define   dMSP430_LCD_LIGHT_ON    P4OUT |= BIT0
#define   dMSP430_LCD_LIGHT_OFF   P4OUT &amp;= ~BIT0

#define   dMSP430_INPUT           0
#define   dMSP430_OUTPUT          0xff
#define   dMSP430_ON              1
#define   dMSP430_OFF             0
#define   dMSP430_BUF_SIZE        25

#define   dMSP430__100us     	7                 //7 cycles *12 + 20 = 104 / 104*1us = 104us

//NAND FLASH
#define   dMSP430_MAX_BLOCK_NUMB		1024

#define   dMSP430_TRANS_LDY 		50
#define   dMSP430_WRITE_DLY		400
#define   dMSP430_ERASE_DLY		4000

#define   dMSP430_OUT_PORT		P5OUT
#define   dMSP430_IN_PORT		        P5IN
#define   dMSP430_IO_DIR			P5DIR

#define   dMSP430__CE_ON			P2OUT &amp;= ~BIT0
#define   dMSP430__CE_OFF			P2OUT |= BIT0
#define   dMSP430__RE_ON			P2OUT &amp;= ~BIT1
#define   dMSP430__RE_OFF			P2OUT |= BIT1
#define   dMSP430__WE_ON			P2OUT &amp;= ~BIT2
#define   dMSP430__WE_OFF			P2OUT |= BIT2

#define   dMSP430_ALE_ON			P2OUT |= BIT3
#define   dMSP430_ALE_OFF			P2OUT &amp;= ~BIT3
#define   dMSP430_CLE_ON			P2OUT |= BIT4
#define   dMSP430_CLE_OFF			P2OUT &amp;= ~BIT4

#define   dMSP430_R_B				P2IN &amp; BIT7
#define   dMSP430_DALLAS			P2IN &amp; BIT5

#define   dMSP430_READ_SPARE			0x50
#define   dMSP430_READ_0				0x00
#define   dMSP430_READ_1				0x01
#define   dMSP430_READ_STATUS			0x70

#define   dMSP430_WRITE_PAGE			0x80
#define   dMSP430_WRITE_AKN			0x10

#define   dMSP430_ERASE_BLOCK			0x60
#define   dMSP430_ERASE_AKN			0xD0

#define   dMSP430_DEV_ID				0x90

#define   dMSP430_SAMSUNG_ID			0xECE6


// ========================================
// helper
// ========================================

// delay cpu cycles
void msp430_Delay (unsigned int cycles)
{
	unsigned char k;
	for (k=0 ; k != cycles; k++);	//20+a*12 cycles (for 1MHz)
}

// delay a given time
void msp430_DelayN100us(unsigned char n)
{
	unsigned char j;
	for (j=0; j!=n; ++j) msp430_Delay (dMSP430__100us);
}

// ========================================
// LCD
// ========================================

enum eMSP430_LCDcommands {
	eMSP430_LCDcom_clear		= 0x01,
	eMSP430_LCDcom_returnHome	= 0x02,
	eMSP430_LCDcom_entryMode	= 0x04,
	eMSP430_LCDcom_display		= 0x08,
	eMSP430_LCDcom_cursorDisplay= 0x10,
	eMSP430_LCDcom_function		= 0x20,
	eMSP430_LCDcom_setCGram		= 0x40,
	eMSP430_LCDcom_setDDram		= 0x80
};


void msp430_LCD_E()
{
	dMSP430_E_HIGH;		    //toggle E for LCD
	_NOP();
	_NOP();
	dMSP430_E_LOW;
}

// sends a char to the display
void msp430_LCD_sendChar (unsigned char d)
{
	unsigned char temp;

	msp430_DelayN100us(5);                 //.5ms
	temp = d &amp; 0xf0;		//get upper nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;
	dMSP430_RS_HIGH;        	        //set LCD to data mode
	msp430_LCD_E();                           //toggle E for LCD
	temp = d &amp; 0x0f;
	temp = temp &lt;&lt; 4;               //get down nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;
	dMSP430_RS_HIGH;   	                //set LCD to data mode
	msp430_LCD_E();                           //toggle E for LCD
}

// sends a command to the LCD controller
void msp430_LCD_sendCmd (unsigned char e)
{
	unsigned char temp;

	msp430_DelayN100us(10);                //10ms
	temp = e &amp; 0xf0;		//get upper nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;               //send CMD to LCD
	dMSP430_RS_LOW;     	                //set LCD to CMD mode
	msp430_LCD_E();                           //toggle E for LCD
	temp = e &amp; 0x0f;
	temp = temp &lt;&lt; 4;               //get down nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;
	dMSP430_RS_LOW;            	        //set LCD to CMD mode
	msp430_LCD_E();                           //toggle E for LCD
}

// cmd clear
inline void msp430_LCD_cmdClear () {
	msp430_LCD_sendCmd(eMSP430_LCDcom_clear);
}

// cmd cur. home
inline void msp430_LCD_cmdCurHome () {
	msp430_LCD_sendCmd(eMSP430_LCDcom_returnHome);
}

// cmd entry mode (if cursor is shifted)
inline void msp430_LCD_cmdEntry (
		unsigned char incrFlag,		//!&lt; if 1 increment cursor, else decrement
		unsigned char enable		//!&lt; if set incr/decr is enabled
		) {
	unsigned char cmd;

	cmd = eMSP430_LCDcom_entryMode;
	if (incrFlag) cmd |= 0x2;
	if (enable) cmd |= 0x1;
	msp430_LCD_sendCmd(cmd);
}

// cmd set display on, show cursor, flash cursor
inline void msp430_LCD_cmdDisplay (
		unsigned char displayOn,	//!&lt; if 1 display is turned on
		unsigned char cursorOn,		//!&lt; if 1 the cursor is set on
		unsigned char cursorFlashOn	//!&lt; if 1 the cursor flashes
		) {
	unsigned char cmd;

	cmd = eMSP430_LCDcom_display;
	if (displayOn) cmd |= 0x4;
	if (cursorOn) cmd |= 0x2;
	if (cursorFlashOn) cmd |= 0x1;
	msp430_LCD_sendCmd(cmd);
}

// cmd shift cursor
inline void msp430_LCD_cmdShiftCursor (
		unsigned char leftFlag,	//!&lt; if 1 cursor is shift left
		unsigned char num		//!&lt; number of shifts
		) {
	unsigned char cmd,n;

	cmd = eMSP430_LCDcom_cursorDisplay;
	if (!leftFlag) cmd |= 0x4;
	for (n = 0; n &lt; num; n++) {
		msp430_LCD_sendCmd(cmd);
	}
}

// cmd shift display
inline void msp430_LCD_cmdShiftDisplay (
		unsigned char leftFlag,	//!&lt; if 1 cursor is shift left
		unsigned char num		//!&lt; number of shifts
		) {
	unsigned char cmd,n;

	cmd = eMSP430_LCDcom_cursorDisplay | 0x8;
	if (!leftFlag) cmd |= 0x4;
	for (n = 0; n &lt; num; n++) {
		msp430_LCD_sendCmd(cmd);
	}
}

// cmd shift display
inline void msp430_LCD_cmdFunction (
		unsigned char datamode,		//!&lt; 0=4bit 1=8bit mode
		unsigned char displayLines	//!&lt; 0=1 line, 1=2 lines
		) {
	unsigned char cmd;

	cmd = eMSP430_LCDcom_function;
	if (datamode) cmd |= 0x10;
	if (displayLines) cmd |= 0x08;
		msp430_LCD_sendCmd(cmd);
}


// init the LCD display
void msp430_LCD_init()
{
	dMSP430_RS_LOW;

	//Delay 100ms
	msp430_DelayN100us(250);
	msp430_DelayN100us(250);
	msp430_DelayN100us(250);
	msp430_DelayN100us(250);

	// setup
	dMSP430_LCD_Data |= BIT4 | BIT5;            //D7-D4 = 0011
	dMSP430_LCD_Data &amp;= ~BIT6 &amp; ~BIT7;

	msp430_LCD_E();                               //toggle E for LCD
	msp430_DelayN100us(100);                   //10ms
	msp430_LCD_E();                               //toggle E for LCD
	msp430_DelayN100us(100);                   //10ms
	msp430_LCD_E();                               //toggle E for LCD
	msp430_DelayN100us(100);                   //10ms
	dMSP430_LCD_Data &amp;= ~BIT4;                  //D7-D4 = 0010
	msp430_LCD_E();                               //toggle E for LCD

	msp430_LCD_cmdFunction(0,1);
	msp430_LCD_cmdDisplay(1,1,1);
	msp430_LCD_cmdClear();
}

// writes a string at the display
void msp430_LCD_print (
		unsigned char 	x,
		unsigned char 	y,
		char * 			szStr
	) {
	msp430_LCD_cmdClear();
	msp430_LCD_cmdCurHome();

	while (*szStr) {
		msp430_LCD_sendChar(*szStr);
		szStr++;
	}
}


// ========================================
// UART
// ========================================

// type for the fifo structure
typedef struct Sstj32BitFIFO {
	uint32_t *		buffer;
	uint32_t *		pBufferEnd; // pointer with the end value of the buffer
	uint32_t * 		pW;		// write pointer
	uint32_t * 		pR;		// read pointer
	// write element
	unsigned int	eC;		// element counter
	// status
	unsigned int	num;	// amount of elements at the buffer
	unsigned int	numMax;	// maximum of elements
} Sstj32BitFIFO;

// inits the fifo
inline int stjFIFO_init (
		Sstj32BitFIFO * pFIFO,
		int 			elements
	) {
	pFIFO-&gt;buffer = malloc(elements*sizeof(uint32_t));
	if (!pFIFO-&gt;buffer) return -1;

	pFIFO-&gt;numMax = elements;

	// setup the fifo
	pFIFO-&gt;pBufferEnd = pFIFO-&gt;buffer + elements;
	pFIFO-&gt;pW = pFIFO-&gt;buffer;
	pFIFO-&gt;pR = pFIFO-&gt;buffer;

	pFIFO-&gt;eC = 3;

	pFIFO-&gt;num = 0;
	while (elements) {
		elements--;
		*pFIFO-&gt;pW = 0;
		pFIFO-&gt;pW++;
	}
	pFIFO-&gt;pW = pFIFO-&gt;buffer;
	return 0;
}

// frees the fifo
inline int stjFIFO_free (
		Sstj32BitFIFO * pFIFO
	) {
	free (pFIFO-&gt;buffer);
	pFIFO-&gt;buffer = NULL;

	pFIFO-&gt;numMax = 0;
	return 0;
}


// writes a char to the buffer
inline void stjFIFO_writeChar(Sstj32BitFIFO * pFIFO, uint8_t d) {
	*pFIFO-&gt;pW |= d;
	// some checks

	// 1. have we written 4 bytes?
	if (pFIFO-&gt;eC) {
		// no - do some shift stuff
		pFIFO-&gt;eC--;
		*(pFIFO-&gt;pW) &lt;&lt;= 8;
	} else {
		pFIFO-&gt;eC = 3;
		// yes - set that we got a new element
		pFIFO-&gt;num++;
		pFIFO-&gt;pW++;
		if (pFIFO-&gt;pW == pFIFO-&gt;pBufferEnd) {
			pFIFO-&gt;pW = pFIFO-&gt;buffer;
		}
	}
}

// writes a char to the buffer
inline void stjFIFO_writeCharWithRotation(Sstj32BitFIFO * pFIFO, uint8_t d) {
	*pFIFO-&gt;pW |= (((uint32_t)d) &lt;&lt; 24);
	// some checks

	// 1. have we written 4 bytes?
	if (pFIFO-&gt;eC) {
		// no - do some shift stuff
		pFIFO-&gt;eC--;
		*(pFIFO-&gt;pW) &gt;&gt;= 8;
	} else {
		pFIFO-&gt;eC = 3;
		// yes - set that we got a new element
		pFIFO-&gt;num++;
		pFIFO-&gt;pW++;
		if (pFIFO-&gt;pW == pFIFO-&gt;pBufferEnd) {
			pFIFO-&gt;pW = pFIFO-&gt;buffer;
		}
	}
}


// read a element(uint32_t) from the buffer
inline int stjFIFO_readElement (Sstj32BitFIFO * pFIFO, uint32_t * pRes) {
	// if there are no entries report error
	if (!pFIFO-&gt;num) return -1;
	// ok let's read a value
	*pRes = *pFIFO-&gt;pR;
	*pFIFO-&gt;pR = 0;
	pFIFO-&gt;pR++;
	pFIFO-&gt;num--;
	if (pFIFO-&gt;pR == pFIFO-&gt;pBufferEnd) {
		pFIFO-&gt;pR = pFIFO-&gt;buffer;
	}

	return 0;
}

Sstj32BitFIFO gMsp430_uartFIFO;

// init UART0 port
void msp430_UART_init(int fifoElements)
{

	P3SEL |= 0x30;                        // P3.4 = USART0 TXD, P3.5 = USART0 RXD
	P3DIR |= 0x10;                        // P3.4 output direction

	// setup UART0
	UCTL0 = CHAR;                         // 8-bit character

	UTCTL0 = SSEL1;                       // UCLK = XT2
	UBR00 = 0x41;                         // 8 000 000/9600
	UBR10 = 0x03;                         //
	UMCTL0 = 0x0;

	ME1 |= UTXE0 + URXE0;                 // Enabled USART0 TXD/RXD
	IE1 |= URXIE0;                        // Enabled USART0 RX interrupt

	// setup the fifo
	stjFIFO_init(&amp;gMsp430_uartFIFO,fifoElements);
}

//  UART rx isq
#pragma vector=UART0RX_VECTOR
__interrupt void msp430_UART_RXisr (void)
{
	unsigned char v;
	_NOP();
	// save value
	v = RXBUF0;
	stjFIFO_writeChar(&amp;gMsp430_uartFIFO, v);
}

// send a bytes via uart
void msp430_UART_send (unsigned char * pD, unsigned int amount)
{
	unsigned int c;

	for (c = 0; c &lt; amount; c++) {
		// wait till tx buffer is ready
		while ((IFG1 &amp; UTXIFG0) == 0);
		// copy data
		TXBUF0 = *pD;
		pD++;
	}
	// wait till transfer has finished
	while ((IFG1 &amp; UTXIFG0) == 0);
}


// ========================================
// AD/DA converter
// ========================================

// init DA converter
void msp430_DAC_init ()
{
	DAC12_0CTL = DAC12SREF1 + /*DAC12RES + */ DAC12IR + DAC12AMP_7;                          //Ve REF+, 8-bit resolution
	DAC12_1CTL = DAC12SREF1 + /*DAC12RES + */ DAC12IR + DAC12AMP_7;                          //Ve REF+, 8-bit resolution

//  DAC12_0CTL = DAC12SREF1 + DAC12RES + DAC12IR + DAC12AMP_7;                          //Ve REF+, 8-bit resolution
//  DAC12_1CTL = DAC12SREF1 + DAC12RES + DAC12IR + DAC12AMP_7;
}

// init AD converter
void msp430_ADC_init ()
{
	ADC12CTL0 = SHT0_0 + ADC12ON;         // Set sampling time, turn on ADC12
	ADC12CTL1 = SHP;                      // Use sampling timer
	//ADC12IE = 0x01;                       // Enable interrupt
	ADC12MCTL0 = SREF_7;                  //VR+ = VeREF+ and VR– = VREF–/VeREF–
	ADC12CTL0 |= ENC;                     // Conversion enabled
	P6SEL = BIT5 + BIT4 + BIT3 + BIT2 + BIT1 + BIT0;                        // P6.4 ADC option select
}

// set AD channel
void msp430_setADChannel (unsigned int channel)
{
	ADC12CTL0 &amp;= ~ENC;                                    //disable convertion
	ADC12MCTL0 &amp;= 0xfff8;                                 //clear select chanel bits
	ADC12MCTL0 |= channel;                                      //select chanel
	ADC12CTL0 |= ENC;                                     //enable convertion
	ADC12CTL0 |= ADC12SC;                                 //Sampling open
	while ((ADC12CTL1 &amp; ADC12BUSY) != 0);
}

// ========================================
// NAND FLASH
// ========================================

//pull flash pins to inactive condition
void msp430_Flash_inactive() {
	dMSP430_IO_DIR=dMSP430_INPUT;         //IO is inputs
	dMSP430__CE_OFF;              //=1
	dMSP430__RE_OFF;              //=1
	dMSP430__WE_OFF;              //=1
	dMSP430_ALE_OFF;              //=0
	dMSP430_CLE_OFF;              //=0
}

// write a data byte to the flash
void msp430_Flash_writeByte (unsigned char d) {
	dMSP430_IO_DIR=dMSP430_OUTPUT;        //IO is outputs
	dMSP430__WE_ON;
	dMSP430_OUT_PORT=d;
	dMSP430__WE_OFF;              //latch data
}

// reads a byte from the flash
unsigned char msp430_Flash_readByte()
{
	unsigned char f;

	dMSP430_IO_DIR=dMSP430_INPUT;         //IO is inputs
	dMSP430__RE_ON;
	f=dMSP430_IN_PORT;
	dMSP430__RE_OFF;              //read data
	return f;
}

// write a block to the flash
unsigned char msp430_Flash_write(
		unsigned char page,
		unsigned char colAddr,
        unsigned char rowAddLow,
        unsigned char rowAddHigh,
        unsigned char num,
        unsigned char * pD
	) {
	unsigned char k, l;

	msp430_Flash_inactive();
	dMSP430_CLE_ON;
	dMSP430__CE_ON;
	msp430_Flash_writeByte(page);
	dMSP430_CLE_OFF;
	dMSP430_ALE_ON;
	msp430_Flash_writeByte(colAddr);
	msp430_Flash_writeByte(rowAddLow);
	msp430_Flash_writeByte(rowAddHigh);
	dMSP430_ALE_OFF;
	for (k=0; k != num; k++) {
		msp430_Flash_writeByte(*pD);
		pD++;
	}
	dMSP430_CLE_ON;
	msp430_Flash_writeByte(dMSP430_WRITE_AKN);
	while ((dMSP430_R_B) == 0);
	msp430_Flash_writeByte(dMSP430_READ_STATUS);
	dMSP430_CLE_OFF;
	l = msp430_Flash_readByte();
	msp430_Flash_inactive();
	return l;
}

// read a block of bytes from the flash
void msp430_Flash_read (
		unsigned char colAddr,
        unsigned char rowAddLow,
        unsigned char rowAddHigh,
        unsigned char num,
        unsigned char * pD
	)
{
	unsigned char n;

	msp430_Flash_inactive();
	dMSP430_CLE_ON;
	dMSP430__CE_ON;
	msp430_Flash_writeByte(dMSP430_READ_0);
	dMSP430_CLE_OFF;
	dMSP430_ALE_ON;
	msp430_Flash_writeByte(colAddr);
	msp430_Flash_writeByte(rowAddLow);
	msp430_Flash_writeByte(rowAddHigh);
	dMSP430_ALE_OFF;
	while ((dMSP430_R_B) == 0);
	for (n=0; n != num; n++) {
		*pD = msp430_Flash_readByte();
		pD++;
	}
	msp430_Flash_inactive();
}

unsigned char msp430_Flash_erase(
        unsigned char blockAddLow,
        unsigned char blockAddHigh
	) {
	unsigned char m;

	msp430_Flash_inactive();
	dMSP430_CLE_ON;
	dMSP430__CE_ON;
	msp430_Flash_writeByte(dMSP430_ERASE_BLOCK);
	dMSP430_CLE_OFF;
	dMSP430_ALE_ON;
	msp430_Flash_writeByte(blockAddLow);
	msp430_Flash_writeByte(blockAddHigh);
	dMSP430_ALE_OFF;
	dMSP430_CLE_ON;
	msp430_Flash_writeByte(dMSP430_ERASE_AKN);
	while ((dMSP430_R_B) == 0);
	msp430_Flash_writeByte(dMSP430_READ_STATUS);
	dMSP430_CLE_OFF;
	m = msp430_Flash_readByte();
	msp430_Flash_inactive();
	return m;
}

// ========================================
// HW init
// ========================================

void msp430_start() {
	// Stop watchdog timer
	WDTCTL = WDTPW + WDTHOLD;

	//XT2-ON
	BCSCTL1 &amp;= ~BIT7;
	//XT2 is SMCLK
	BCSCTL2 |= BIT3;

	//hardware init
	// 1. configure I/O Pins

	P1DIR=BIT0;

	//NAND FLASH init
	P2OUT=0x07;
	P2DIR=0x1F;

	//LED1
	P3OUT = BIT6 | BIT7;
	//LED2
	P3DIR = BIT6 | BIT7;

	//LCD init
	P4OUT = 0;
	P4DIR = 0xff;
}

void msp430_initHW (int fifoElements) {
	//configure modules

	//1 first the UART!
	msp430_UART_init(fifoElements);
	//2nd the LCD, if switched with UART the port sends a ghost sign because Port 3 is used by LCD and UART
	msp430_LCD_init();
	//3th DAC
	msp430_DAC_init();
	// 4th ADC
	msp430_ADC_init();

	// Enable interrupts
	_EINT();
}
</Code><Code idCode="146">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
//#define dAPuseExternalAPCode

#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif

int main()
{
	TAP AP;
	int rc;

	InitHW(); 	// hardware config

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		//Write_LCD_str(&quot;audio processor init failed with error code %i!&quot;,rc);
		LCD_print(&quot;AP failed&quot;);
		goto exit;
	}
	LCD_print(&quot;AP started&quot;);

#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);
	LCD_print(&quot;AP ended&quot;);

	return 0;
}
</Code><Code idCode="147">// ===============================
// AP uuid = 9
// ===============================

// no RX handling so far yet
void UART_RXhandler (unsigned char data) {
	
}

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="148">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable ** ps = &amp;( pParams[0].fp_pV);
// parameter i descr: index of the string at the array
	int32_t* pi = &amp;( pParams[1].fp_integer);
// parameter length descr: length of the string
	int32_t* plength = &amp;( pParams[2].fp_integer);
};
</Code><Code idCode="149">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable ** ps = &amp;( pParams[0].fp_pV);
// parameter i descr: index of the string at the array
	int32_t* pi = &amp;( pParams[1].fp_integer);
// parameter p descr: position at the string where to start from
	int32_t* pp = &amp;( pParams[2].fp_integer);
// parameter v1 descr: chars coded as 4 byte integer
	int32_t* pv1 = &amp;( pParams[3].fp_integer);
// parameter v2 descr: chars coded as 4 byte integer
	int32_t* pv2 = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="150">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable * pV = pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int index = (int)pParams[1].fp_integer;
// parameter length descr: length of the string
	int length = (int) pParams[2].fp_integer;


	// Boundary check
//	TAPstringVector * pSV =	pV-&gt;pData;
//	if ((index &lt; 0) || (index &gt;= pSV-&gt;num)) {
//		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
//		return;
//	}
	// is performed by the AL compiler

	// get APstring
	TAPstring * pS = &amp;((TAPstringVector *)pV-&gt;pData)-&gt;pStr[index];
	// resize and check result
	if (APstring_resize(pS,length)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -2;
		return;
	}
	// and go to next instruction
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="151">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable * pV = pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int i = (int) pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int p = (int) pParams[2].fp_integer;
// parameter v1 descr: chars coded as 4 byte integer
//	uint32_t* pv1 = &amp;( pParams[3].fp_raw);
// parameter v2 descr: chars coded as 4 byte integer
//	uint32_t* pv2 = &amp;( pParams[4].fp_raw);
	char *pSrc = (char *)&amp;(pParams[3].fp_raw);

	// dynamic adjust amount of bytes to be copied
	// int amount =   ((dAPInterpreterFuncMaxParams-3) * sizeof(int)/sizeof(char));

	// get string boundary check is performed by the ALC compiler
	TAPstring * pS = &amp;((TAPstringVector *)pV-&gt;pData)-&gt;pStr[i];

	APstring_fill(pS,p,((dAPInterpreterFuncMaxParams-3) * sizeof(uint32_t)/sizeof(char)),pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="152">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode
//#define dWithDebugInterface

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;PC.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}

#endif

TAPMsgDrv 	gDrvL [1];
TAP 		AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

void printCPUregisters() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	printf (&quot;\tCF = %i\n\tEF = %i&quot;,(int)pCPU-&gt;CF,(int)pCPU-&gt;EF);
}

#endif

void printAPNodes () {
	TAPNode * pN = AP.pNodeList;
	fprintf(stdout,&quot;nodes:\n&quot;);
	while (pN) {
		fprintf(stdout,&quot;- node id: %u\n&quot;,pN-&gt;nodeID);
		pN = pN-&gt;pNext;
	}
}

void ui () {
	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'g':
				printf(&quot;registers:\n&quot;);
#ifdef dWithDebugInterface
				printCPUregisters();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'n':
				printAPNodes();
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\ng-CPU registers\nn-show nodes\ne-exit&quot;);
				break;
			default:
				printf(&quot;Unknown command!&quot;);
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

int main()
{
	WSADATA			wsaData;
	pthread_t		IPthread;
	pthread_t		MSthread;


	int rc;
	int endianS = eAP_littleEndian;

    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	printf(&quot;WSAStartup failed!&quot;);
    	return -1;
    }

	APdriver_1_init(&amp;gDrvL[0]);

	time_t t;

	time(&amp;t);
	srand((unsigned int)t);              /* Zufallsgenerator initialisieren */

	int uuid = rand();

	printf (&quot;AP uuid %i\n&quot;,uuid);

	// start up gtk+
	APgtk_start ();

	//rc = APinit(&amp;AP,815,gDrvL,1,1000,eAP_littleEndian);
	rc = APinit(&amp;AP,(TAPNodeID)uuid,gDrvL,1,1000,endianS);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
	if (rc) {
		printf(&quot;load programm failed with %i&quot;, rc);
		goto exit;
	}
#endif

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif
	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	ui();

exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}
</Code><Code idCode="153">// ===============================
// variable implementation for a string(var id = 3)
// ===============================
// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len - iStart;

	for (i = 0;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}

// --------------------------------------
// AP var interface
// --------------------------------------

// transmit the data
void HALimpl_3_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
return APstringVector_create((int) numberOfElements);
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="154">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system

	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="155">// ===========================================================
// socket functions to communicate via UDP
// ===========================================================
// written by Stefan Jaritz -&gt; prefix stj
// part I: defines

enum eAdminMsgTypes {
	eAdminMsgType_login 	= 'i',
	eAdminMsgType_logout	= 'o',
	eAdminMsgType_exit		= 'e',
	eAdminMsgType_ack		= 'a',
	eAdminMsgType_nack		= 'n'
};


typedef struct SstjSocket_addr {
	struct sockaddr_in	Addr;
	int					len;
} TstjSocket_addr;


typedef struct SstjSocket_loginMsg {
	uint8_t		msgID;
	uint16_t	uuid;
	uint16_t	dataOutPort;
	uint16_t	dataInPort;
} TstjSocket_loginMsg;

typedef uint8_t TstjSocket_loginRAWmsg [7];

// creates a addinfo struct with the address of the local
struct addrinfo * stjSocket_getLocalSocketAddress (uint16_t port);

// creates a UPD server
int stjSocket_createServer (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	);


// creates a UDP client witch connects to a local server
int stjSocket_createClient (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	);

// closes socket &amp; address
void stjSocket_close (
		SOCKET				S,		//!&lt;(in) socket
		TstjSocket_addr	*	pAI		//!&lt;(in) address info
	);

// sends some data to an address
int stjSocket_send (
		SOCKET	 			S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	);

// receives some data and filles the address with the sender
int stjSocket_recv (
		SOCKET 				S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	);

// ===========================================================
// socket functions to communicate via UDP
// ===========================================================
// written by Stefan Jaritz -&gt; prefix stj
// part II: implementation

// defines
#define dMaxHostNameChars (254)

/*
// creates a addinfo struct with the address of the local
struct addrinfo * stjSocket_getLocalSocketAddress (uint16_t port) {
	char 				szPath[dMaxHostNameChars] = &quot;&quot;;
	char				szDummyStr[255] = &quot;&quot;;
	struct hostent *	pHostInfo;
	struct addrinfo		hints;
	struct addrinfo	*	pAI;

	memset ( &amp;hints, 0,sizeof(hints));
	hints.ai_family = AF_UNSPEC; // IPv4 and IPv6
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_protocol = 0; // any protocol
	hints.ai_flags = 0;

	// resolve hostname
    if (gethostname(szPath,dMaxHostNameChars)) goto mainErrorWithMsg;

	pHostInfo = gethostbyname(szPath);
	if (!pHostInfo) goto mainErrorWithMsg;

	sprintf(szDummyStr,&quot;%u&quot;,(unsigned int)port);

	// build address info
	if (getaddrinfo (pHostInfo-&gt;h_name,szDummyStr,&amp;hints,&amp;pAI)) {
		fprintf (stderr,&quot;getting address-information of the TCP port failed (error code %s)!\n&quot;,gai_strerror(WSAGetLastError()));
		goto mainError;
	}

	return pAI;

mainErrorWithMsg:
	fprintf (stderr, &quot;error: %s\n&quot;,gai_strerror(WSAGetLastError()));
mainError:
    return NULL;

}
*/

// creates a UPD server
int stjSocket_createServer (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	) {
	// create socket
	*pS=socket(AF_INET,SOCK_DGRAM,0);
	if (!*pS) goto mainErrorWithMsg;

	// create address
	pAI-&gt;Addr.sin_family=AF_INET; // AF_UNSPEC
	pAI-&gt;Addr.sin_port=htons(port);
	pAI-&gt;Addr.sin_addr.s_addr=ADDR_ANY;
	pAI-&gt;len = sizeof(SOCKADDR_IN);

	// bind socket to adress
	if (SOCKET_ERROR == bind(*pS,(SOCKADDR*)&amp;(pAI-&gt;Addr),pAI-&gt;len)) goto mainErrorWithMsg;
    return 0;
mainErrorWithMsg:
   	printf (&quot;error: %s\n&quot;,gai_strerror(WSAGetLastError()));
   	return -1;
}

// creates a UDP client witch connects to a local server
int stjSocket_createClient (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	) {
	char 				szPath[dMaxHostNameChars] = &quot;&quot;;
	struct hostent *	pHostInfo;

	// resolve hostname
    if (gethostname(szPath,dMaxHostNameChars)) goto mainErrorWithMsg;

	pHostInfo = gethostbyname(szPath);
	if (!pHostInfo) goto mainErrorWithMsg;

	// create socket
	*pS=socket(AF_INET,SOCK_DGRAM,0);
	if (!*pS) goto mainErrorWithMsg;

	// get the local ip from the host
	char * szLocalIP;
	szLocalIP = inet_ntoa (*(struct in_addr *)*pHostInfo-&gt;h_addr_list);

	unsigned long addr = inet_addr(szLocalIP);
	if ((INADDR_NONE == addr) || (INADDR_ANY == addr)) {
		closesocket(*pS);
		printf (&quot;unknown inet address\nerror: %s\n&quot;,gai_strerror(WSAGetLastError()));
		return -2;
	}

	// create address
	pAI-&gt;Addr.sin_family=AF_INET; // AF_UNSPEC
	pAI-&gt;Addr.sin_port=htons(port);
	pAI-&gt;Addr.sin_addr.s_addr= addr;
	pAI-&gt;len = sizeof(SOCKADDR_IN);

    return 0;
mainErrorWithMsg:
   	printf (&quot;error: %s\n&quot;,gai_strerror(WSAGetLastError()));
   	return -1;
}

// closes socket &amp; address
void stjSocket_close (
		SOCKET				S,		//!&lt;(in) socket
		TstjSocket_addr	*	pAI		//!&lt;(in) address info
	) {
	// pAI is self build so we don't need a free call
	//freeaddrinfo(gMsgServer.aiAdmin);
	closesocket(S);
}

// sends some data to an address
int stjSocket_send (
		SOCKET	 			S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	) {
	int n;
	n = sendto (S, (const char *) pData, dataSize, 0,(struct sockaddr *)&amp;(pAddr-&gt;Addr), pAddr-&gt;len);
	if (n != dataSize) {
		fprintf (stderr,&quot;sending data failed (%i bytes send)!(error: %s)!\n&quot;,n,gai_strerror(WSAGetLastError()));
		return -1;
	}
	return 0;
}

// receives some data and filles the address with the sender
int stjSocket_recv (
		SOCKET 				S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	) {
	int n;
	n = recvfrom(S, (char *) pData, dataSize, 0,(struct sockaddr *)&amp;(pAddr-&gt;Addr), &amp;pAddr-&gt;len);
	if (n != dataSize) {
		fprintf (stderr,&quot;receiving data failed (%i bytes received)!(error: %s)!\n&quot;,n,gai_strerror(WSAGetLastError()));
		return -1;
	}
	return 0;
}

// ==========================================
// a TCP/IP client running the RX at an
// own thread and use a callback-function
// to sign that some data are received
// ==========================================
// part I: header defines

typedef int (* TpfktAPClientRecvCallback) (void *pUserData, uint16_t number, uint8_t * pData);

typedef struct SAPClient {
	uint16_t					uuid;			//!&lt; uuid of the client

	SOCKET 						sAdmin;			//!&lt; admin socket
	uint16_t	 				adminPort;		//!&lt; admin port
	TstjSocket_addr				aAdmin;			//!&lt; socket address of the admin

	SOCKET						sDataIn;		//!&lt; data in socket
	uint16_t					dataInPort;		//!&lt; port of the data in socket
	TstjSocket_addr				aDataIn;		//!&lt; socket address of the data port

	SOCKET						sDataOut;		//!&lt; data out socket
	uint16_t					dataOutPort;	//!&lt; port of the data out socket
	TstjSocket_addr				aDataOut;		//!&lt; socket address of the data port

	pthread_t					recvThread;		//!&lt; receive thread
	uint8_t	*					recvBuffer;		//!&lt; temporaly receive buffer
	uint16_t					recvBufferSize;	//!&lt; size in bytes of the receive buffer
	void *						pUserData;		//!&lt; user data (can be NULL)
	TpfktAPClientRecvCallback	fktRecvCB;		//!&lt; receive call back funtion
} TAPClient;

// creates an admin client
int APclient_create (
		TAPClient *					pC,					//!&lt;(in/out) pointer to a client structure to be filled
		uint16_t 					adminPort,			//!&lt;(in) the port of the admin server port
		uint16_t					recvBufferSize,		//!&lt;(in) size in bytes of the receive buffer
		void *						pUserData,			//!&lt;(in) user data
		TpfktAPClientRecvCallback	fktCB				//!&lt;(in) callback function when receiving data
	);

//! free's the client
int APclient_close (
		TAPClient *		pC			//!&lt;(in) pointer to a client structure
	);


int APclient_send (
		TAPClient *		pC,			//!&lt;(in) pointer to a client structure
		uint16_t		num,		//!&lt;(in) amount of bytes to send
		uint8_t *		pData		//!&lt;(in) pointer to the data
	);

// ==========================================
// a TCP/IP client running the RX at an
// own thread and use a callback-function
// to sign that some data are received
// ==========================================
// part II: implementation


// =====================================
// pre defs
// =====================================

// the thread function for receiving data
void * APclient_RecvThread (void *);


// =====================================
// functions
// =====================================


// creates an admin client
int APclient_create (
		TAPClient *					pC,					//!&lt;(in/out) pointer to a client structure to be filled
		uint16_t 					adminPort,			//!&lt;(in) the port of the admin server port
		uint16_t					recvBufferSize,		//!&lt;(in) size in bytes of the receive buffer
		void *						pUserData,			//!&lt;(in) user data
		TpfktAPClientRecvCallback	fktCB				//!&lt;(in) callback function when receiving data
	) {
	uint8_t		msgID;

	// 0. save the user data
	pC-&gt;pUserData = pUserData;

	// 1. create a socket to communicate with the admin port
	if (stjSocket_createClient(
			adminPort,
			&amp;(pC-&gt;sAdmin),
			&amp;(pC-&gt;aAdmin)
		)) {
		return -1;
	}

	pC-&gt;adminPort = adminPort;
	// 2. setup
	// request login
	msgID = eAdminMsgType_login;
	if (stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	// get the ports
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (msgID != eAdminMsgType_login) {
		fprintf(stderr,&quot;admin send wrong message back\n&quot;);
		goto abortAndError;
	}

	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;uuid),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;dataInPort),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;dataOutPort),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;


	printf(&quot;data in: %u\ndata out: %u\n&quot;,(unsigned int)pC-&gt;dataInPort,(unsigned int)pC-&gt;dataOutPort);

	// create data sockets
	if (stjSocket_createServer(
			pC-&gt;dataInPort,
			&amp;(pC-&gt;sDataIn),
			&amp;(pC-&gt;aDataIn)
		)) goto DataSocketCreationError;

	// create recv buffer &amp; threads
	pC-&gt;recvBuffer = malloc((size_t)recvBufferSize);
	if (!pC) goto abortAndError;
	pC-&gt;recvBufferSize = recvBufferSize;
	pC-&gt;fktRecvCB = fktCB;

	// now we can start the handling thread
	pthread_create(&amp;pC-&gt;recvThread,NULL,APclient_RecvThread,pC);

	// send ack to server
	msgID = eAdminMsgType_ack;
	if (stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;

	// wait till server is ready
	if (stjSocket_recv(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (eAdminMsgType_ack != msgID) {
		fprintf(stderr,&quot;admin error\n&quot;);
		return -10;
	}

	// now open the client data port
	if (stjSocket_createClient(
			pC-&gt;dataOutPort,
			&amp;(pC-&gt;sDataOut),
			&amp;(pC-&gt;aDataOut)
		)) goto DataSocketCreationError;

	// some info
    printf (&quot;client setup with uuid=%u data-in port:%u data-out port:%u\n&quot;,(unsigned int)pC-&gt;uuid,(unsigned int)pC-&gt;dataInPort,(unsigned int)pC-&gt;dataOutPort);
    fflush(stdout);
	return 0;

abortAndError:
	msgID = eAdminMsgType_nack;
	stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin));
	return -2;

sendFailed:
	fprintf(stderr,&quot;sending to admin failed\n&quot;);
	fprintf (stderr,&quot;error: %s\n&quot;,gai_strerror(WSAGetLastError()));
	return -3;

receivedFailed:
	fprintf(stderr,&quot;receiving from admin failed\n&quot;);
	fprintf (stderr,&quot;error: %s\n&quot;,gai_strerror(WSAGetLastError()));
	return -4;

DataSocketCreationError:
	fprintf(stderr,&quot;creating data sockets failed\n&quot;);
	fprintf (stderr,&quot;error: %s\n&quot;,gai_strerror(WSAGetLastError()));
	return -4;
}

//! free's the client
int APclient_close (
		TAPClient *		pC			//!&lt;(in/out) pointer to a client structure to be filled
	) {
	// vars
	uint8_t				msgID;

	// request logout
	msgID = eAdminMsgType_logout;
	if (stjSocket_send(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;uuid),2,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	// wait till server finished it
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (msgID != eAdminMsgType_ack) {
		fprintf(stderr,&quot;logout failed\n&quot;);
	}

	stjSocket_close(pC-&gt;sAdmin,&amp;(pC-&gt;aAdmin));
	stjSocket_close(pC-&gt;sDataIn,&amp;(pC-&gt;aDataIn));
	stjSocket_close(pC-&gt;sDataOut,&amp;(pC-&gt;aDataOut));

	// wait till thread is gone
	pthread_join(pC-&gt;recvThread,NULL);


	return 0;
sendFailed:
	fprintf(stderr,&quot;sending to admin failed\n&quot;);
	return -3;

receivedFailed:
	fprintf(stderr,&quot;receiving from admin failed\n&quot;);
	return -4;
}

// the thread function for receiving data
void * APclient_RecvThread (
		void *	pArg
	) {
	uint16_t			msgLen;
	uint8_t *			pNB;

	TAPClient *			pC = pArg;

	// get data
	for (;;) {
		// read amount of data to be received
		if (stjSocket_recv(pC-&gt;sDataIn,&amp;msgLen,2,&amp;(pC-&gt;aDataIn))) goto recvError;
		// check if we have enough memory allocated at the buffer
		if (msgLen &gt; pC-&gt;recvBufferSize) {
			pNB = realloc(pC-&gt;recvBuffer,msgLen);
			if (pNB) {
				pC-&gt;recvBuffer = pNB;
				pC-&gt;recvBufferSize = msgLen;
			} else {
				fprintf (stderr,&quot;realloc memory failed&quot;);
				goto recvError;
			}
		}
		// transmit data
		if (stjSocket_recv(pC-&gt;sDataIn,pC-&gt;recvBuffer,msgLen,&amp;(pC-&gt;aDataIn))) goto recvError;
		// and handle the data
		pC-&gt;fktRecvCB(pC-&gt;pUserData, msgLen, pC-&gt;recvBuffer);

	}
	pthread_exit((void *)0);
	return NULL;

recvError:
	// close data connections
	fprintf (stderr,&quot;receiving data failed!&quot;);
	pthread_exit((void *)-3);
	return NULL;
}


int APclient_send (
		TAPClient *		pC,			//!&lt;(in) pointer to a client structure
		uint16_t		num,		//!&lt;(in) amount of bytes to send
		uint8_t *		pData		//!&lt;(in) pointer to the data
	) {
	if (stjSocket_send(pC-&gt;sDataOut,&amp;pC-&gt;uuid,2,&amp;(pC-&gt;aDataOut))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sDataOut,&amp;num,2,&amp;(pC-&gt;aDataOut))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sDataOut,pData,(int)num,&amp;(pC-&gt;aDataOut))) goto sendFailed;

	return 0;
sendFailed:
	fprintf(stderr,&quot;sending data to server failed\n&quot;);
	return -1;

}
</Code><Code idCode="156"></Code><Code idCode="157">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drv_open_1 (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_close_1 (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_destroy_1 (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_ACK_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_NACK_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_startPrg_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_sendVariable_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_sendInstruction_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_endPrg_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_stop_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_step_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_run_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_updateVariable_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_login_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_logout_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="158">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="159">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="160">// ===============================
// driver uuid =1
// ===============================

// ------------------------------
// drv own functions
// ------------------------------

#define dAPClientServerAdminPort (50000)
#define dAPClientInitBuffer (1024)

// struct for the drv data
typedef struct SAPTCPIPdrv {
	TAPClient 					cl;			//!&lt; tcp/ip client
	TAPMsgHeader				txHeader;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TAPTCPIPdrv;

// ------------------------------
// drv own functions
// ------------------------------

int drv_1_sendHeader (
		TAPClient * pCl,
		uint32_t * pH,
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	pH[eAPMsgHeaderPosition_msgTypeID] = msgId;
	pH[eAPMsgHeaderPosition_msgNumber] = num;
	pH[eAPMsgHeaderPosition_receiver] = recv;
	pH[eAPMsgHeaderPosition_length] = length;
	if (APclient_send(pCl,sizeof(TAPMsgHeader),(uint8_t *)pH)) return -1;
	return 0;
}

// call back function of the TCP/IP driver
int drv_1_cbAPClient (void *pvDC, uint16_t number, uint8_t * pData) {
	TAPReceiveStateMachine * pSM = pvDC;
	return pSM-&gt;state (pSM, (uint32_t *) pData, number / sizeof(uint32_t));
}

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = NULL;

	pDC = malloc(sizeof(TAPTCPIPdrv));
	if (!pDC) return -1;
	if (APclient_create(&amp;(pDC-&gt;cl),dAPClientServerAdminPort,dAPClientInitBuffer,&amp;(pDC-&gt;rxSM),drv_1_cbAPClient)) return -2;
	// init header
	pDC-&gt;txHeader[eAPMsgHeaderPosition_endian] = ((TAP *) pAP)-&gt;sysEndian;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgTypeID] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgNumber] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = pDC;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;pDC-&gt;rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		APclient_close(&amp;pDC-&gt;cl);
	}
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		free(pDC);
		pDrv-&gt;pDrvData = NULL;
	}
	return 0;
}
//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_ACK, receiver, mNum, 0);
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_NACK, receiver, mNum, 0);
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_startPrg, receiver, mNum, 0) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;globalVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;localVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;instructionNumber)
		) return -10;
	return 0;
}

//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendVariable, receiver, mNum, 3) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;varTypeID) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;num)
		) return -10;
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t)*dAPInterpreterFuncMaxParams,(uint8_t *)fbc)
		) return -10;
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_endPrg, receiver, mNum, 0);
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_stop, receiver, mNum, 0);
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_step, receiver, mNum, 0);
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_run, receiver, mNum, 0);
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t i, uint32_t * data) {
	return -1;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_login, receiver, mNum, 0);
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_logout, receiver, mNum, 0);
}
</Code><Code idCode="161"></Code><Code idCode="162">// -------------------------------------------
// AP gtk helper
// -------------------------------------------

PangoFontDescription * gAPgtkMonoSpaceFont = NULL;


// a helper for destroying &quot;undestroyed&quot; UI's
void APgtk_helper_destroy (GtkWidget * pWG) {
	if (pWG) {
//		if (pWG-&gt;object.parent_instance.ref_count) {
			gtk_widget_destroy(pWG);
//		}
	}
}

// -------------------------------------------
// AP panel
// -------------------------------------------

// struct for a panel
typedef struct SAPgtkPanel {
	GtkWidget *		pWnd;		//!&lt; pointer to the window
	GtkWidget *		pBox;		//!&lt; placement box
} TAPgtkPanel;


// create a panel
int gtkAP_local_PanelCreate (
		TAPgtkPanel * 	pP,		//!&lt;(in/out) structure to be filled
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {
	// Create a new window
	pP-&gt;pWnd = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	if (!pP-&gt;pWnd) return -1;

	// UI's are at fixed positions
	pP-&gt;pBox = gtk_fixed_new();
	if (!pP-&gt;pBox) return -2;

	gtk_container_add(GTK_CONTAINER(pP-&gt;pWnd), pP-&gt;pBox);

	// setup main wnd
	gtk_window_set_title (GTK_WINDOW (pP-&gt;pWnd), &quot;AP Panel&quot;);
	gtk_window_set_default_size (GTK_WINDOW (pP-&gt;pWnd),xle, yle);
	gtk_window_move(GTK_WINDOW (pP-&gt;pWnd),x, y);

	// It's a good idea to do this for all windows
	//gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;destroy&quot;, GTK_SIGNAL_FUNC (gtk_exit), NULL);
	g_signal_connect (G_OBJECT (pP-&gt;pWnd), &quot;destroy&quot;, G_CALLBACK (gtk_widget_destroy), NULL);

	//gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;delete_event&quot;, GTK_SIGNAL_FUNC (gtk_exit), NULL);
	g_signal_connect (G_OBJECT (pP-&gt;pWnd), &quot;delete_event&quot;, G_CALLBACK (gtk_widget_destroy), NULL);

	// Sets the border width of the window
	gtk_container_set_border_width (GTK_CONTAINER (pP-&gt;pWnd), 1);

	gtk_widget_realize(pP-&gt;pWnd);

	gtk_widget_show_all(pP-&gt;pWnd);

	return(0);
}


// destroys a panel
void gtkAP_local_PanelDestroy (
		TAPgtkPanel * 	pP
	) {
	APgtk_helper_destroy(pP-&gt;pWnd);
	APgtk_helper_destroy(pP-&gt;pBox);
	pP-&gt;pWnd = NULL;
	pP-&gt;pBox = NULL;
}

// -------------------------------------------
// AP button
// -------------------------------------------

// struct for a AP button
typedef struct SAPgtkButton {
	GtkWidget *		pB;				//!&lt; pointer to the button
	int				pressCounter;	//!&lt; counter of the press event
} TAPgtkButton;

// call back to handle click calls
void gtkAP_cb_ButtonClicked (GtkWidget *widget, gpointer data) {
	TAPgtkButton * pB = (TAPgtkButton *) data;
	pB-&gt;pressCounter++;
}

// creates a AP button
int gtkAP_local_ButtonCreate (
		TAPgtkButton * 	pB,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {


	pB-&gt;pressCounter = 0;
	// create button
	pB-&gt;pB = gtk_button_new_with_label  (&quot;&quot;);
	if (!pB-&gt;pB) return -1;

	// bind it to the window
	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pB-&gt;pB, x, y);
	gtk_widget_set_size_request(pB-&gt;pB, xle, yle);

	gtk_widget_modify_font(gtk_bin_get_child (GTK_BIN(pB-&gt;pB)),gAPgtkMonoSpaceFont);

	gtk_widget_show (pB-&gt;pB);

	// set msg handler
	g_signal_connect(G_OBJECT(pB-&gt;pB), &quot;clicked&quot;, G_CALLBACK(gtkAP_cb_ButtonClicked), pB);


	return 0;
}

// destroys a button
void gtkAP_local_ButtonDestroy (
		TAPgtkButton * 	pB
	) {
	APgtk_helper_destroy(pB-&gt;pB);

	pB-&gt;pB = NULL;
	pB-&gt;pressCounter = 0;
}

// -------------------------------------------
// AP LED
// -------------------------------------------

// struct for a AP led
typedef struct SAPgtkLED {
	GtkWidget *		pLED;				//!&lt; pointer to the LED
	int				onFlag;
	double			onColor[3];
	double			offColor[3];
} TAPgtkLED;


static gboolean APgtk_cb_LEDexpose (
		GtkWidget *			da,
		GdkEventExpose *	event,
		gpointer        	data
	)
{
  cairo_t *		cr;
  TAPgtkLED	* 	pLED = (TAPgtkLED	*) data;
  double 		r;
  cr = gdk_cairo_create (gtk_widget_get_window(da));
  gdk_cairo_rectangle (cr, &amp;event-&gt;area);
  cairo_clip (cr);
  if (pLED-&gt;onFlag) {
	  cairo_set_source_rgb (cr, pLED-&gt;onColor[0], pLED-&gt;onColor[1], pLED-&gt;onColor[2]);
  } else {
	  cairo_set_source_rgb (cr, pLED-&gt;offColor[0], pLED-&gt;offColor[1], pLED-&gt;offColor[2]);
  }
  //cairo_rectangle(cr, event-&gt;area.x, event-&gt;area.y, event-&gt;area.width, event-&gt;area.height);
  r = (event-&gt;area.width &gt; event-&gt;area.height) ? event-&gt;area.width : event-&gt;area.height;
  r /= 2.f;
  cairo_arc (cr,event-&gt;area.x+r, event-&gt;area.y+r,r, 0.f, 2.f * M_PI);

  cairo_fill(cr);
  cairo_destroy (cr);
  return TRUE;
}

// creates a AP button
int gtkAP_local_LEDCreate (
		TAPgtkLED * 	pLED,	//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	pLED-&gt;onFlag = 0;
	pLED-&gt;offColor[0] = 0.0;
	pLED-&gt;offColor[1] = 0.0;
	pLED-&gt;offColor[2] = 0.0;
	pLED-&gt;onColor[0] = 1.0;
	pLED-&gt;onColor[1] = 1.0;
	pLED-&gt;onColor[2] = 1.0;


	pLED-&gt;pLED = gtk_drawing_area_new ();
	if (!pLED-&gt;pLED) return -1;
	gtk_widget_set_size_request (pLED-&gt;pLED, xle, yle);

	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pLED-&gt;pLED, x, y);

	g_signal_connect (pLED-&gt;pLED, &quot;expose-event&quot;,  G_CALLBACK (APgtk_cb_LEDexpose), pLED);

	gtk_widget_show (pLED-&gt;pLED);

	return 0;
}

// destroys a button
void gtkAP_local_LEDDestroy (
		TAPgtkLED * 	pLED
	) {
	APgtk_helper_destroy(pLED-&gt;pLED);

	pLED-&gt;pLED = NULL;
	pLED-&gt;onFlag = 0;
	pLED-&gt;offColor[0] = 0.0;
	pLED-&gt;offColor[1] = 0.0;
	pLED-&gt;offColor[2] = 0.0;
	pLED-&gt;onColor[0] = 0.0;
	pLED-&gt;onColor[1] = 0.0;
	pLED-&gt;onColor[2] = 0.0;
}


// -------------------------------------------
// AP Display
// -------------------------------------------

// struct for a AP led
typedef struct SAPgtkDisplay {
	GtkWidget *		pD;				//!&lt; pointer to the display
	GtkWidget *		pF;				//!&lt; frame around the label
	int				charsPerLine;
	int				lineCount;
} TAPgtkDisplay;


// creates a AP display
int gtkAP_local_DisplayCreate (
		TAPgtkDisplay *	pD,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	pD-&gt;pD = NULL;
	pD-&gt;charsPerLine = 10;
	pD-&gt;lineCount = 4;

	pD-&gt;pD = gtk_label_new (&quot;&quot;);
	if (!pD-&gt;pD) return -1;
	pD-&gt;pF = gtk_frame_new(NULL);
	if (!pD-&gt;pF) return -2;

	//gtk_widget_set_size_request (pD-&gt;pD, xle-2, yle-2);
	gtk_widget_set_size_request (pD-&gt;pF, xle, yle);

	//gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pD-&gt;pD, x, y);
	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pD-&gt;pF, x, y);
	gtk_container_add(GTK_CONTAINER(pD-&gt;pF), pD-&gt;pD);

	//gtk_widget_modify_font(gtk_bin_get_child (GTK_BIN(pD-&gt;pD)),gAPgtkMonoSpaceFont);
	gtk_widget_modify_font(pD-&gt;pD,gAPgtkMonoSpaceFont);

	/*
	// change colors
	GdkColor color;
	gdk_color_parse (&quot;yellow&quot;, &amp;color);
	gtk_widget_modify_fg (pD-&gt;pD, GTK_STATE_NORMAL, &amp;color);
	// background only works for the main wnd!
	gdk_color_parse (&quot;green&quot;, &amp;color);
	gtk_widget_modify_bg(pP-&gt;pWnd, GTK_STATE_NORMAL, &amp;color);
	 */

	gtk_widget_show (pD-&gt;pD);
	gtk_widget_show (pD-&gt;pF);

	return 0;
}

// destroys a display
void gtkAP_local_DisplayDestroy (
		TAPgtkDisplay * 	pD
	) {
	APgtk_helper_destroy(pD-&gt;pD);

	pD-&gt;pD = NULL;
	pD-&gt;charsPerLine = 10;
	pD-&gt;lineCount = 2;
}

// sets a display text
void gtkAP_local_DisplaySetTextDim(
		TAPgtkDisplay * 	pD,
		int					charsPerLine,
		int					lineCount
	) {
	pD-&gt;charsPerLine = charsPerLine;
	pD-&gt;lineCount = lineCount;
}


// sets a display text
void gtkAP_local_DisplaySetText(
		TAPgtkDisplay * 	pD,
		char *				szTxt
	) {
	const char const cLF = 0xA;
	char szdummyBuffer[pD-&gt;lineCount*pD-&gt;charsPerLine+1];
	char * pC = szdummyBuffer;
	int x = 0;
	int y = 0;

	while (*szTxt) {
		// check if we have a line break
		if (*szTxt == cLF) {
			y++;
			x = 0;
			// check if we reached the end
			if (y == pD-&gt;lineCount) {
				*pC = 0;
				goto printLines;
			}
		}

		// copy char
		*pC = *szTxt;
		szTxt++;
		pC++;
		x++;

		// check if we reached the end of the line
		if (x == pD-&gt;charsPerLine) {
			y++;
			x=0;
			// check if we reached the end
			if (y &lt; pD-&gt;lineCount) {
				*pC = cLF;
				pC++;
			} else {
				*pC = 0;
				goto printLines;
			}
		}

	}
	*pC = 0;
printLines:
	gtk_label_set_text(GTK_LABEL(pD-&gt;pD),szdummyBuffer);
}

// ===========================================
// AP gtk+ interface
// ===========================================

enum eAPgtkActionID {
	eAPgtkActionID_exit				= 1,
	eAPgtkActionID_redrawUI			= 10,
	eAPgtkActionID_setDisplayText	= 11,
	eAPgtkActionID_createPanel		= 20,
	eAPgtkActionID_deletePanel		= 21,
	eAPgtkActionID_createButton		= 30,
	eAPgtkActionID_deleteButton		= 31,
	eAPgtkActionID_createLED		= 40,
	eAPgtkActionID_deleteLED		= 41,
	eAPgtkActionID_createDisplay	= 50,
	eAPgtkActionID_deleteDisplay	= 51,

};

typedef struct SAPgtk_command {
	sem_t		ps;			//!&lt; process finsh semaphore
	GMutex *	gm;			//!&lt; guarding mutex
	int			newCmdFlag;	//!&lt; is set to indicate that there is a new command

	int 		cmd; 		//!&lt; command
	void *		pData1;
	void *		pData2;
	int 		x;
	int			y;
	int			xle;
	int			yle;


} TAPgtk_command;


TAPgtk_command			gAPgtkMsg;
GThread *				gAPgtkThread;

void APgtk_setMsg (
		int		id,
		void *	pD1,
		void *	pD2,
		int		x,
		int		y,
		int		xle,
		int		yle
) {
	g_mutex_lock(gAPgtkMsg.gm);
	// set the command
	gAPgtkMsg.cmd = id;
	gAPgtkMsg.pData1 = pD1;
	gAPgtkMsg.pData2 = pD2;
	gAPgtkMsg.x = x;
	gAPgtkMsg.y = y;
	gAPgtkMsg.xle = xle;
	gAPgtkMsg.yle = yle;
	gAPgtkMsg.newCmdFlag = 1;
	g_mutex_unlock(gAPgtkMsg.gm);

	sem_wait(&amp;gAPgtkMsg.ps);
}

gpointer APgtk_threadFunc (gpointer Args) {
	// init gtk and bind it to the thread
	if (FALSE ==  gtk_init_check(NULL, NULL)) return ((gpointer)-1);

	gAPgtkMonoSpaceFont = pango_font_description_from_string(&quot;monospace&quot;);

	// process messages &amp; user actions
	for (;;) {
		// check for message
		g_mutex_lock(gAPgtkMsg.gm);
		if (gAPgtkMsg.newCmdFlag) {
			switch (gAPgtkMsg.cmd) {
				case eAPgtkActionID_exit:
					goto exit;
					break;
				case eAPgtkActionID_redrawUI:
					gtk_widget_queue_draw (GTK_WIDGET(gAPgtkMsg.pData1));
					break;

				case eAPgtkActionID_setDisplayText:
					gtkAP_local_DisplaySetText(gAPgtkMsg.pData1,gAPgtkMsg.pData2);
					break;

				case eAPgtkActionID_createPanel:
					gtkAP_local_PanelCreate (
							gAPgtkMsg.pData1,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deletePanel:
					gtkAP_local_PanelDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createButton:
					gtkAP_local_ButtonCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteButton:
					gtkAP_local_ButtonDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createLED:
					gtkAP_local_LEDCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteLED:
					gtkAP_local_LEDDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createDisplay:
					gtkAP_local_DisplayCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteDisplay:
					gtkAP_local_DisplayDestroy(gAPgtkMsg.pData1);
					break;
			}
			gAPgtkMsg.newCmdFlag = 0;
			sem_post(&amp;gAPgtkMsg.ps);
		}
		g_mutex_unlock(gAPgtkMsg.gm);

		// message handling
		if (TRUE == gtk_events_pending ()) {
			gtk_main_iteration ();
		}

	}
	goto end;
exit:
	sem_post(&amp;gAPgtkMsg.ps);
	g_mutex_unlock(gAPgtkMsg.gm);
end:
	pango_font_description_free(gAPgtkMonoSpaceFont);
	gAPgtkMonoSpaceFont = NULL;
	return NULL;
}

int APgtk_start () {

	if (!g_thread_supported ()) g_thread_init (NULL);

	gAPgtkMsg.newCmdFlag = 0; // no cmd ready
	gAPgtkMsg.gm = g_mutex_new ();
	sem_init(&amp;gAPgtkMsg.ps,0,0);

	gAPgtkThread = g_thread_create(APgtk_threadFunc, NULL,TRUE, NULL);
	return 0;
}


void APgtk_end () {
	APgtk_setMsg(eAPgtkActionID_exit, NULL, NULL, 0, 0, 0, 0);
	g_thread_join(gAPgtkThread);
	g_mutex_free(gAPgtkMsg.gm);
	sem_destroy(&amp;gAPgtkMsg.ps);
}

// ----------------------------
// AP interface
// ----------------------------

// create a panel
int gtkAP_PanelCreate (
		TAPgtkPanel * 	pP,		//!&lt;(in/out) structure to be filled
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createPanel, pP, NULL, x, y, xle, yle);

	return(0);
}


// destroys a panel
void gtkAP_PanelDestroy (
		TAPgtkPanel * 	pP
	) {
	APgtk_setMsg (eAPgtkActionID_deletePanel, pP, NULL, 0,0,0,0);
}


// create a button
int gtkAP_ButtonCreate (
		TAPgtkButton * 	pB,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createButton, pB, pP, x, y, xle, yle);

	return(0);
}


// destroys a button
void gtkAP_ButtonDestroy (
		TAPgtkButton * 	pB
	) {
	APgtk_setMsg (eAPgtkActionID_deleteButton, pB, NULL, 0,0,0,0);
}

// create a LED
int gtkAP_LEDCreate (
		TAPgtkLED * 	pLED,	//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createLED, pLED, pP, x, y, xle, yle);

	return(0);
}


// destroys a LED
void gtkAP_LEDDestroy (
		TAPgtkLED * 	pLED
	) {
	APgtk_setMsg (eAPgtkActionID_deleteLED, pLED, NULL, 0,0,0,0);
}


// create a display
int gtkAP_DisplayCreate (
		TAPgtkDisplay * pD,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createDisplay, pD, pP, x, y, xle, yle);

	return(0);
}


// destroys a display
void gtkAP_DisplayDestroy (
		TAPgtkDisplay * 	pD
	) {
	APgtk_setMsg (eAPgtkActionID_deleteDisplay, pD, NULL, 0,0,0,0);
}

// destroys a display
void gtkAP_DisplaySetText (
		TAPgtkDisplay * 	pD,
		char *				pT
	) {
	APgtk_setMsg (eAPgtkActionID_setDisplayText, pD, pT, 0,0,0,0);
}


// ===========================================
// AP gtk general types and interface
// ===========================================

// AP gtk+ type enums
enum eAPgtkUItypes {
	eAPgtkUItype_unknown	= 0,
	eAPgtkUItype_panel		= 1,
	eAPgtkUItype_button		= 2,
	eAPgtkUItype_LED		= 3,
	eAPgtkUItype_display	= 4
};

// AP UI type
typedef struct SAPgtkUI {
	int		uuid;
	int 	x;
	int		y;
	int		xle;
	int		yle;
	int		typeID;
	union 	uAPgtkUI {
		TAPgtkPanel		panel;
		TAPgtkButton	button;
		TAPgtkDisplay	display;
		TAPgtkLED		led;
	} ui;
} TAPgtkUI;

// set the coordinates of the ui
void APgtkUI_setCoordinates (
		TAPgtkUI *	pUI,
		int 		x,
		int			y,
		int			xle,
		int			yle
	) {
	pUI-&gt;x = x;
	pUI-&gt;y = y;
	pUI-&gt;xle = xle;
	pUI-&gt;yle = yle;
}

// creates visible ui
int APgtkUI_createUI (
		TAPgtkUI *	pUI,
		TAPgtkUI *	pParentUI,
		int			uuid,
		int			typeID
	) {
	pUI-&gt;typeID = typeID;
	pUI-&gt;uuid = uuid;
	switch (typeID) {
		case eAPgtkUItype_panel:
			return gtkAP_PanelCreate(
					&amp;(pUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_button:
			return gtkAP_ButtonCreate(
					&amp;(pUI-&gt;ui.button),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_LED:
			return gtkAP_LEDCreate(
					&amp;(pUI-&gt;ui.led),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_display:
			return gtkAP_DisplayCreate(
					&amp;(pUI-&gt;ui.display),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
	}
	return -100;
}

// destroy visible ui
void APgtkUI_destroyUI (
		TAPgtkUI *	pUI
	) {
	switch (pUI-&gt;typeID) {
		case eAPgtkUItype_panel:
			gtkAP_PanelDestroy(&amp;(pUI-&gt;ui.panel));
			break;
		case eAPgtkUItype_button:
			gtkAP_ButtonDestroy(&amp;(pUI-&gt;ui.button));
			break;
		case eAPgtkUItype_LED:
			gtkAP_LEDDestroy(&amp;(pUI-&gt;ui.led));
			break;
		case eAPgtkUItype_display:
			gtkAP_DisplayDestroy(&amp;(pUI-&gt;ui.display));
			break;
	}
	pUI-&gt;typeID = eAPgtkUItype_unknown;
	pUI-&gt;uuid = 0;
}

// redraws a ui
void APgtkUI_redrawUI (
		TAPgtkUI *	pUI
	) {
	switch (pUI-&gt;typeID) {
		case eAPgtkUItype_panel:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.panel.pWnd, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_button:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.button.pB, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_LED:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.led.pLED, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_display:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.display.pD, NULL, 0,0,0,0);
			break;
	}
}


// AP UI array type
typedef struct SAPgtkUIvector {
	TAPgtkUI * 	pUI;
	int			number;
} TAPgtkUIvector;


TAPgtkUIvector * APgtkUI_createVector (
		int number,
		int uiType
	) {
	TAPgtkUIvector * 	pV;
	int					i;

	pV = malloc (sizeof(TAPgtkUIvector));
	if (!pV) return NULL;
	pV-&gt;pUI = malloc (sizeof(TAPgtkUI)*number);
	if (!pV-&gt;pUI) {
		free (pV);
		return NULL;
	}
	memset (pV-&gt;pUI,0,sizeof(TAPgtkUI)*number);

	pV-&gt;number = number;
	for (i = 0; i &lt; number; i++) {
		pV-&gt;pUI[i].typeID = uiType;
	}

	return pV;
}

void APgtkUI_destroyVector (
		TAPgtkUIvector * pUIv
	) {
	int i;
	for (i = 0; i &lt; pUIv-&gt;number; i++) {
		APgtkUI_destroyUI(&amp;(pUIv-&gt;pUI[i]));
	}
	free (pUIv-&gt;pUI);;
	free (pUIv);
}
</Code><Code idCode="163">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter xPos descr: x position in pixel
	int32_t* pxPos = &amp;( pParams[0].fp_integer);
// parameter yPos descr: y position in pixel
	int32_t* pyPos = &amp;( pParams[1].fp_integer);
// parameter xLen descr: x width
	int32_t* pxLen = &amp;( pParams[2].fp_integer);
// parameter yLen descr: y height
	int32_t* pyLen = &amp;( pParams[3].fp_integer);
// parameter uiVar descr: UI element
	TAPInterpreterVariable ** puiVar = &amp;( pParams[4].fp_pV);
};
</Code><Code idCode="164">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="165">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter b descr: button
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="166">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter d descr: display
	void ** pd = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="167">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter l descr: LED
	void ** pl = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="168">// ===============================
// variable implementation for pannel UI(var id = 100)
// ===============================

// transmit the data
void HALimpl_100_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_100_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_100_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_100_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
return NULL;
}
// fill the frame with data
void HALimpl_100_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {

}
</Code><Code idCode="169">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

// transmit the data
void HALimpl_101_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_101_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_101_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_101_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_button);
}
// fill the frame with data
void HALimpl_101_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="170">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

// transmit the data
void HALimpl_102_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_102_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_102_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_102_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_LED);
}
// fill the frame with data
void HALimpl_102_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="171">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

// transmit the data
void HALimpl_103_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_103_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_103_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_103_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_display);
}
// fill the frame with data
void HALimpl_103_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="172">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter xPos descr: x position in pixel
	int32_t xPos = pParams[0].fp_integer;
// parameter yPos descr: y position in pixel
	int32_t yPos = pParams[1].fp_integer;
// parameter xLen descr: x width
	int32_t xLen = pParams[2].fp_integer;
// parameter yLen descr: y height
	int32_t yLen = pParams[3].fp_integer;
// parameter ui descr: UI element
	TAPgtkUIvector * puiVec = (TAPgtkUIvector *) pParams[4].fp_pV;
// parameter uiIndex descr: UI element index
	int32_t uiIndex = pParams[5].fp_integer;
	
	APgtkUI_setCoordinates (
			&amp;(puiVec-&gt;pUI[uiIndex]),
			xPos,
			yPos,
			xLen,
			yLen
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="173">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[1].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[2].fp_integer);
};
</Code><Code idCode="174">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter b descr: button
	void ** pb = &amp;( pParams[1].fp_pD);
// parameter bIndex descr: button index
	int32_t* pbIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="175">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter d descr: display
	void ** pd = &amp;( pParams[1].fp_pD);
// parameter dIndex descr: display index
	int32_t* pdIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="176">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter l descr: LED
	void ** pl = &amp;( pParams[1].fp_pD);
// parameter lIndex descr: LED index
	int32_t* plIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="177">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter p descr: pannel
	TAPgtkUIvector * puiVec = (TAPgtkUIvector *) pParams[1].fp_pD;
// parameter pIndex descr: pannel index
	int32_t pIndex = pParams[2].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiVec-&gt;pUI[pIndex]),
			NULL,
			uiUUID,
			eAPgtkUItype_panel
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="178">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter b descr: button
	TAPgtkUIvector * puiB = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiB-&gt;pUI[bIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_button
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="179">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the panel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter b descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter bIndex descr: display index
	int32_t dIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiD-&gt;pUI[dIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_display
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="180">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t uiUUID = pParams[0].fp_integer;
// parameter l descr: LED
	TAPgtkUIvector * puiL = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiL-&gt;pUI[lIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_LED
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="181">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

// transmit the data
void HALimpl_100_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_100_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_100_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_100_initEnd (void * pVarData) {

}
// fill the frame with data
void HALimpl_100_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_panel);
}

// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="182">// ===============================
// function implementation for uiCheckButtonPressed(var id = 210)
// description: if the button was pressed the CF is set
// ===============================

void HALfunc_ID210_uiCheckButtonPressed(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter b descr: button
	TAPgtkUIvector * puiB = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[1].fp_integer;
// parameter p descr: panel

	if (puiB-&gt;pUI[bIndex].ui.button.pressCounter) {
		puiB-&gt;pUI[bIndex].ui.button.pressCounter--;
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="183">// ===============================
// function implementation for uiSetLED(var id = 211)
// description: set the LED state
// ===============================

void HALfunc_ID211_uiSetLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter l descr: LED
	TAPgtkUIvector * puiL = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[1].fp_integer;
// parameter onFlag descr: if the flag is not zero the LED is turned on
	int32_t  onFlag = pParams[2].fp_integer;

	puiL-&gt;pUI[lIndex].ui.led.onFlag = (!onFlag) ? 0 : 1;
	APgtkUI_redrawUI(&amp;(puiL-&gt;pUI[lIndex]));
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="184">// ===============================
// function implementation for jumpCF(var id = 51)
// description: jumps if the carry flag is set n instructions
// ===============================

void HALfunc_ID51_jumpCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (((TAPInterpreterCPU *)pIPcpu)-&gt;CF) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="185">// ===============================
// function implementation for jumpNCF(var id = 52)
// description: jumps if the carry flag is not set n instructions
// ===============================

void HALfunc_ID52_jumpNCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (!((TAPInterpreterCPU *)pIPcpu)-&gt;CF) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="186">// ===============================
// function implementation for setCF(var id = 55)
// description: sets the carry flag
// ===============================

void HALfunc_ID55_setCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter value descr: the value of the CF
	if (pParams[0].fp_integer) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="187">// --------------------------------------
// TAPstringVector
// --------------------------------------

// ap string
typedef struct SAPstring {
	char *	szTxt;	//!&lt; pointer to char buffer
	size_t	maxLen;	//!&lt; length of the char buffer(without the zero at the end)
} TAPstring;

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		sv;		//!&lt; string vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;sv = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;sv){
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * ps = pR-&gt;sv;
	for (i = 0; i &lt; num; i++) {
		ps-&gt;szTxt = NULL;
		ps-&gt;maxLen = 0;
		ps++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	if (pSV-&gt;sv) {
		TAPstring * ps = pSV-&gt;sv;
		for (i = 0; i &lt; pSV-&gt;num; i++) {
			if (ps-&gt;szTxt){
				free(ps-&gt;szTxt);
			}
		}
		free(pSV-&gt;sv);
	}
	free(pSV);
}

// resizes the amount of strings at the string vector
int APstringVector_resizeVector (
		TAPstringVector * 	pSV,	//!&lt;(in) pointer to the string vector
		int					num		//!&lt;(in) number of strings at the vector
	) {
	if (pSV-&gt;num == num) return 0;
	unsigned int	i;
	TAPstring * 	ps;

	if (pSV-&gt;sv) {
		ps = pSV-&gt;sv;
		for (i = 0; i &lt; pSV-&gt;num; i++) {
			if (ps-&gt;szTxt){
				free(ps-&gt;szTxt);
			}
		}
		free(pSV-&gt;sv);
	}
	pSV-&gt;sv = malloc(sizeof(TAPstring)*num);
	if (!pSV-&gt;sv){
		return -1;
	}
	// init str
	ps = pSV-&gt;sv;
	for (i = 0; i &lt; num; i++) {
		ps-&gt;szTxt = NULL;
		ps-&gt;maxLen = 0;
		ps++;
	}
	pSV-&gt;num = num;
	return 0;
}

// resizes a string at the vector
int APstringVector_resize (
		TAPstringVector * 	pSV,	//!&lt;(in) pointer to the string vector
		int					index,	//!&lt;(in) index of the string at the stringarray
		size_t				newLen	//!&lt;(in) new length of the string
	) {
	TAPstring * ps = pSV-&gt;sv + index;
	if (ps-&gt;maxLen &lt; newLen) {
		// allocate new string
		char * nsz = malloc(sizeof(char) * (newLen +1));
		if (!nsz) return -1;
		if (ps-&gt;szTxt) {
			// copy old string
			strcpy(nsz,ps-&gt;szTxt);
			// release old string
			free(ps-&gt;szTxt);
			ps-&gt;szTxt = NULL;
		} else {
			*nsz = 0;
		}
		// set the new string
		ps-&gt;szTxt =nsz;
		// remember the length
		ps-&gt;maxLen = newLen;
	} else {
		if(ps-&gt;szTxt) {
			// trail old string
			ps-&gt;szTxt[newLen] = 0;
		}
	}
	return 0;
}

// fills the string from an extern source
void APstringVector_fill(
		TAPstringVector * 	pSV,	//!&lt;(in) pointer to the string vector
		int					index,	//!&lt;(in) index of the string at the stringarray
		int					iStart,	//!&lt;(in) start index at the string
		int					iEnd,	//!&lt;(in) end index of the string
		char *				pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i, imax;
	char * pDest = pSV-&gt;sv[index].szTxt;
	pDest += iStart;
	// clip str
	imax = pSV-&gt;sv[index].maxLen;
	if (iEnd &gt; imax) {
		iEnd = imax;
	}

	for (i = iStart;i &lt; iEnd; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}


// concat string 2 with string 1
int APstringVector_concat(
		TAPstringVector * 	pSV1,		//!&lt;(in) pointer to the first string vector
		int					indexSV1,	//!&lt;(in) index of the string at the stringarray
		TAPstringVector * 	pSV2,		//!&lt;(in) pointer to the second string vector
		int					indexSV2	//!&lt;(in) index of the string at the stringarray
	) {
	TAPstring * ps1 = pSV1-&gt;sv + indexSV1;
	TAPstring * ps2 = pSV2-&gt;sv + indexSV2;
	// get new size
	size_t sl1;
	size_t sl2;
	sl1 = ps1-&gt;szTxt ? strlen(ps1-&gt;szTxt) : 0;
	sl2 = ps2-&gt;szTxt ? strlen(ps2-&gt;szTxt) : 0;
	size_t newL = sl1 + sl2;
	// reallocate?
	if (ps1-&gt;maxLen &lt; newL) {
		if (APstringVector_resize(pSV1, indexSV1, newL)) return -1;
	}
	if (ps2-&gt;szTxt) {
		// copy string 2 at the end of string 1
		strcpy(ps1-&gt;szTxt + sl1,ps2-&gt;szTxt);
	}
	return 0;
}


// assigns string 2 to string 1
int APstringVector_assign(
		TAPstringVector * 	pSV1,		//!&lt;(in) pointer to the first string vector
		int					indexSV1,	//!&lt;(in) index of the string at the stringarray
		TAPstringVector * 	pSV2,		//!&lt;(in) pointer to the second string vector
		int					indexSV2	//!&lt;(in) index of the string at the stringarray
	) {
	TAPstring * ps1 = pSV1-&gt;sv + indexSV1;
	TAPstring * ps2 = pSV2-&gt;sv + indexSV2;
	// get new size
	size_t sl2 = strlen(ps2-&gt;szTxt);
	// reallocate?
	if (ps1-&gt;maxLen &lt; sl2) {
		if (APstringVector_resize(pSV1, indexSV1, sl2)) return -1;
	}
	// copy string 2 at the end of string 1
	strcpy(ps1-&gt;szTxt,ps2-&gt;szTxt);

	return 0;
}


// print a floating point number into the string
void APstringVector_printFloat(
		TAPstringVector * 	pSV,			//!&lt;(in) pointer to the first string vector
		int					indexSV,		//!&lt;(in) index of the string at the stringarray
		float				number			//!&lt;(in) number to be printed
	) {
	APstringVector_resize(pSV,indexSV, 20);
	TAPstring * ps = pSV-&gt;sv + indexSV;
	snprintf(ps-&gt;szTxt, ps-&gt;maxLen+1, &quot;%f&quot;, (double)number);

}

// print a integer number into the string
void APstringVector_printInt(
		TAPstringVector * 	pSV,			//!&lt;(in) pointer to the first string vector
		int					indexSV,		//!&lt;(in) index of the string at the stringarray
		int					number			//!&lt;(in) number to be printed
	) {
	APstringVector_resize(pSV,indexSV, 20);
	TAPstring * ps = pSV-&gt;sv + indexSV;
	snprintf(ps-&gt;szTxt, ps-&gt;maxLen+1, &quot;%i&quot;, number);
}
</Code><Code idCode="188">// ===============================
// variable implementation for a string(var id = 3)
// ===============================

// transmit the data
void HALimpl_3_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
	return APstringVector_create((int)numberOfElements);
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="189">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int32_t i = pParams[1].fp_integer;
// parameter length descr: length of the string
	int32_t length = pParams[2].fp_integer;

	if (APstringVector_resize(pSV,(int) i, length)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="190">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int i = (int) pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int p = (int) pParams[2].fp_integer;

	char * pSrc =(char *) &amp;pParams[3].fp_raw;

	int pe = p + (dAPInterpreterFuncMaxParams-3) * sizeof(int32_t);
	
	APstringVector_fill(pSV,i,p,pe,pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="191">// ===============================
// function implementation for uiSetDisplay(var id = 212)
// description: set the text of a display
// ===============================

void HALfunc_ID212_uiSetDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[2].fp_pD;
// parameter iString descr: index of the string at the array
	int32_t iString = pParams[3].fp_integer;

	gtkAP_DisplaySetText (
			&amp;(puiD-&gt;pUI[dIndex].ui.display),
			pSV-&gt;sv[iString].szTxt
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="192">// ===============================
// variable implementation for a string(var id = 3)
// ===============================

// updates a variable the AP
int HALimpl_3_recvUpdate (void * pVarData, void * pMsg) {
	int32_t *			pD = (int32_t *) pMsg;
	TAPstringVector *	pSV = pVarData;
	TAPstring *			ps;
	int					i, num,imax;

	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	//1. get amount of strings at the string vector
	APendianConversation32Bit((uint32_t *)pD,eAP_littleEndian);
	num = (int) *pD;

	if (APstringVector_resizeVector(pSV,num)) {
		return -1;
	}

	pD++;
	ps = pSV-&gt;sv;
	//2. resize and fill the strings
	for (i = 0; i &lt; num; i++) {
		// get length
		APendianConversation32Bit((uint32_t *)pD,eAP_littleEndian);
		if (APstringVector_resize(pSV,i,(size_t)*pD)) {
			return -2;
		}
		imax = (int) *pD;
		pD++;
		for (i = 0;i &lt;imax; i++)  {
			ps-&gt;szTxt[i] = (char) *pD;
			pD++;
		}
		ps-&gt;szTxt[i] = 0;
		ps++;
	}
	return 0;
}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
	return APstringVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_3_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	// msgdata = (stringAmount)[(strlen)(string + fill byes), ...]
	// some vars
	unsigned int		indx;
	int 				stl;
	TAPstring * 		ps;
	TAPstringVector * 	pSV = (TAPstringVector *)pVarData;
	TAPMsgDrv * 		pMD = (TAPMsgDrv *) pDrv;
	int32_t 			uint32Amount = 1; // vector size
	int32_t				sendVal;
	char *				psz;
	// ok get the size of the message
	ps = pSV-&gt;sv;
	for (indx = 0;indx &lt; pSV-&gt;num; indx++) {
		// one element for the length
		uint32Amount++;
		// the string data
		stl = ps-&gt;szTxt ? strlen(ps-&gt;szTxt) : 0;
		uint32Amount+=stl;
		// next string
		ps++;
	}
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, uint32Amount);
	// send amount of elements
	sendVal = (int32_t) pSV-&gt;num;
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
	ps = pSV-&gt;sv;
	for (indx = 0; indx &lt; pSV-&gt;num; indx++) {
		if (ps-&gt;szTxt) {
			// get length
			sendVal = (int32_t) strlen(ps-&gt;szTxt);
			// send length
			pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
			// send string
			psz = ps-&gt;szTxt;
			while (*psz) {
				sendVal = (int32_t) *psz;
				pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
				psz++;
			}
		} else {
			sendVal = 0;
			// send length
			pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
		}
		ps++;
	}
	return 0;
}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="193">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

// updates a variable the AP
int HALimpl_100_recvUpdate (void * pVarData, void * pMsg) {
	return -1;
}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_panel);
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="194">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

// updates a variable the AP
int HALimpl_101_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_button);
}

// updates the vars at the other APs
int HALimpl_101_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}</Code><Code idCode="195">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

// updates a variable the AP
int HALimpl_102_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_LED);
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="196">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

// updates a variable the AP
int HALimpl_103_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_display);
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}</Code><Code idCode="197">// ===============================
// function implementation for assignConstInteger(var id = 20)
// description: a = values
// ===============================

void HALfunc_ID20_assignConstInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter iv descr: integer vector
	TAPgenericIntegerVector * piv = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter iStart descr: start index
	int32_t iStart = pParams[1].fp_integer;
// parameter num descr: number of values
	int32_t num = pParams[2].fp_integer;

	int32_t * pSrc =(int32_t *) &amp;pParams[3].fp_raw;

	APgenericIntegerVector_assignConst(piv, (int)iStart, (int)num, pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="198">// ===============================
// function implementation for assignInteger(var id = 21)
// description: a = b
// ===============================

void HALfunc_ID21_assignInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;

	APgenericIntegerVector_assign(pa, pb);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="199">// ===============================
// function implementation for addInteger(var id = 22)
// description: c = a + b
// ===============================

void HALfunc_ID22_addInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_add(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="200">// ===============================
// function implementation for subInteger(var id = 23)
// description: c = a - b
// ===============================

void HALfunc_ID23_subInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_sub(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="201">// ===============================
// function implementation for mulInteger(var id = 24)
// description: c = a * b
// ===============================

void HALfunc_ID24_mulInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_mul(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="202">// ===============================
// function implementation for divInteger(var id = 25)
// description: c = a / b
// ===============================

void HALfunc_ID25_divInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_div(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="203">// ===============================
// function implementation for modInteger(var id = 26)
// description: c = mod(a,b)
// ===============================

void HALfunc_ID26_modInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_mod(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="204">// ===============================
// function implementation for comparaIntegerLess(var id = 40)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID40_comparaIntegerLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="205">// ===============================
// function implementation for comparaIntegerMore(var id = 41)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID41_comparaIntegerMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="206">// ===============================
// function implementation for comparaIntegerEqual(var id = 42)
// description: a == b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID42_comparaIntegerEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="207">// ===============================
// function implementation for comparaIntegerNEqual(var id = 43)
// description: a != b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID43_comparaIntegerNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="208">// ===============================
// function implementation for comparaIntegerLessEqual(var id = 44)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID44_comparaIntegerLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="209">// ===============================
// function implementation for comparaIntegerMoreEqual(var id = 45)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID45_comparaIntegerMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="210">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// updates a variable the AP
int HALimpl_2_recvUpdate (void * pVarData, void * pMsgData) {
	uint32_t * pD = (uint32_t *) pMsgData;
	TAPgenericIntegerVector * pIV = pVarData;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	int imax = (int) *((int32_t *)pD);

	int i;

	if (APgenericIntegerVector_resize(pIV,imax)) {
		return -1;
	}

	pD++;

	for (i = 0; i &lt; imax; i++) {
		APendianConversation32Bit(pD,eAP_littleEndian);
		pIV-&gt;pVal[i] = *((int32_t *)pD);
		pD++;
	}
	return 0;
}

// create a new variable
void * HALimpl_2_create (unsigned int numberOfElements) {
	return APgenericIntegerVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_2_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	TAPgenericIntegerVector * pIV = pVarData;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	int32_t dataAmount = 1 + pIV-&gt;num;
	int32_t dummy;
	int indx;
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	// send amount of elements
	dummy = (int32_t) pIV-&gt;num;
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;dummy);
	// send elements
	for (indx = 0; indx &lt; pIV-&gt;num; indx++) {
		pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pIV-&gt;pVal[indx]);
	}
	return 0;
}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_2_delete (void * pVarData) {
	APgenericIntegerVector_destroy(pVarData);
}
</Code><Code idCode="211">// ===============================
// function implementation for comparaIntegerLess(var id = 40)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID40_compareIntegerLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="212">// ===============================
// function implementation for comparaIntegerMore(var id = 41)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID41_compareIntegerMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="213">// ===============================
// function implementation for comparaIntegerEqual(var id = 42)
// description: a == b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID42_compareIntegerEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) == 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="214">// ===============================
// function implementation for comparaIntegerNEqual(var id = 43)
// description: a != b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID43_compareIntegerNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) != 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="215">// ===============================
// function implementation for comparaIntegerLessEqual(var id = 44)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID44_compareIntegerLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="216">// ===============================
// function implementation for comparaIntegerMoreEqual(var id = 45)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID45_compareIntegerMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="217">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter var descr: the variable
	TAPInterpreterVariable ** pvar = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="218">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter var descr: the variable
	TAPInterpreterVariable ** pvar = &amp;( pParams[0].fp_pV);
// parameter varIndex descr: the variable index
	int* pvarIndex = &amp;( pParams[1].fp_VarIndex);
};
</Code><Code idCode="219">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,IP,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}



// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="220">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (TX_updateVariable(APInterpreterGetAPfromIP(((TAPInterpreterCPU *)pIPcpu)-&gt;IP),(uint32_t)pParams[0].fp_VarIndex)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -100;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="221">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,IP,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="222">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="223">// ===============================
// driver uuid =1
// ===============================
// ------------------------------
// drv own functions
// ------------------------------

#define dAPClientServerAdminPort (50000)
#define dAPClientInitBuffer (1024)

// struct for the drv data
typedef struct SAPTCPIPdrv {
	TAPClient 					cl;			//!&lt; tcp/ip client
	TAPMsgHeader				txHeader;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TAPTCPIPdrv;

// ------------------------------
// drv own functions
// ------------------------------

int drv_1_sendHeader (
		TAPClient * pCl,
		uint32_t * pH,
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	pH[eAPMsgHeaderPosition_msgTypeID] = msgId;
	pH[eAPMsgHeaderPosition_msgNumber] = num;
	pH[eAPMsgHeaderPosition_receiver] = recv;
	pH[eAPMsgHeaderPosition_length] = length;
	if (APclient_send(pCl,sizeof(TAPMsgHeader),(uint8_t *)pH)) return -1;
	return 0;
}

// call back function of the TCP/IP driver
int drv_1_cbAPClient (void *pvDC, uint16_t number, uint8_t * pData) {
	TAPReceiveStateMachine * pSM = pvDC;
	return pSM-&gt;state (pSM, (uint32_t *) pData, number / sizeof(uint32_t));
}

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = NULL;

	pDC = malloc(sizeof(TAPTCPIPdrv));
	if (!pDC) return -1;
	if (APclient_create(&amp;(pDC-&gt;cl),dAPClientServerAdminPort,dAPClientInitBuffer,&amp;(pDC-&gt;rxSM),drv_1_cbAPClient)) return -2;
	// init header
	pDC-&gt;txHeader[eAPMsgHeaderPosition_endian] = (uint32_t) gAPendianFlag;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgTypeID] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgNumber] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = pDC;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;pDC-&gt;rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		APclient_close(&amp;pDC-&gt;cl);
	}
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		free(pDC);
		pDrv-&gt;pDrvData = NULL;
	}
	return 0;
}

//sends raw data
int drv_1_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	return APclient_send(&amp;(pDC-&gt;cl),amount*sizeof(uint32_t),(uint8_t *)pData);
}

//a AP is going to be logged out of the system
int drv_1_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);

	if (gAPendianFlag == eAP_littleEndian) {
		return APclient_send(&amp;(pDC-&gt;cl),amount*sizeof(uint32_t),(uint8_t *)pData);
	} else {
		int i;
		int32_t v;
		for (i = 0; i &lt; amount; i++) {
			v = *pData;
			APendianConversation32Bit((uint32_t *)&amp;v,eAP_littleEndian);
			if (APclient_send(&amp;(pDC-&gt;cl),sizeof(int32_t),(uint8_t *)&amp;v)) {
				return -1;
			}
			pData++;
		}
	}
	return 0;
}

//a AP is going to be logged out of the system
int drv_1_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);

	return APclient_send(&amp;(pDC-&gt;cl),amount*sizeof(float),(uint8_t *)pData);
}



//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_ACK, receiver, mNum, 0);
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_NACK, receiver, mNum, 0);
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_startPrg, receiver, mNum, 0) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;globalVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;localVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;instructionNumber)
		) return -10;
	return 0;
}

//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendVariable, receiver, mNum, 3) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;varTypeID) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;num)
		) return -10;
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t)*dAPInterpreterFuncMaxParams,(uint8_t *)fbc)
		) return -10;
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_endPrg, receiver, mNum, 0);
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_stop, receiver, mNum, 0);
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_step, receiver, mNum, 0);
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_run, receiver, mNum, 0);
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;gIndex)
		) return -10;
	return 0;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_login, receiver, mNum, 0);
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_logout, receiver, mNum, 0);
}
</Code><Code idCode="224">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//send raw data
int drv_2_sendRaw (struct SAPMsgDrv *pDrv, int amount, void *pData) {
	return 0;
}
//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="225">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			// filter ack/nack msg
			if (ackMsgAllowed) {
				msgIDok = 1;
			} else {
				if (
						(*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
						(*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
					) {
					msgIDok = 1;
				}
			}
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}
		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	if (!pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="226">// ===============================
// AP uuid = 10
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// logout form all other devices
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pthread_mutex_init ( &amp;(pIP-&gt;gM), NULL);

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// reset the interpreter
void APInterpreterReset (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;
}


int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	APInterpreterReset(IP);
	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);


	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}

// ========================================
// the AP message system (thread save)
// ========================================

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pthread_mutex_init(&amp;pMS-&gt;gM, NULL);
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	// we go for shure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="227">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;ADSP.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}

#endif

TAP			AP;
TAPMsgDrv 	UARTdrv;

int main()
{
	int rc;

	APdriver_2_init(&amp;UARTdrv);


	rc = APinit(&amp;AP,21369,&amp;UARTdrv,1,50,eAP_bigEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,gAPendianFlag,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);
	return 0;
}</Code><Code idCode="228">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// updates a variable the AP
int HALimpl_1_recvUpdate (void * pVarData, void * pMsgData) {
	uint32_t * pD = (uint32_t *) pMsgData;
	TAPgenericRationalVector * pIV = pVarData;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	int imax = (int) *((int32_t *)pD);
	int i;

	if (APgenericRationalVector_resize(pIV,imax)) {
		return -1;
	}

	pD++;

	for (i = 0; i &lt; imax; i++) {
		pIV-&gt;pVal[i] = *((float *)pD);
		pD++;
	}
	return 0;
}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
	return APgenericRationalVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_1_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	TAPgenericRationalVector * pRV = pVarData;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	int32_t dataAmount = (int32_t) 1 + pRV-&gt;num;
	int32_t dummy;
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	// send amount of elements
	dummy = (int32_t) pRV-&gt;num;
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;dummy);
	// send elements
	pMD-&gt;pfkt_sendFloat32(pMD,pRV-&gt;num,pRV-&gt;pVal);
	return 0;
}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {
	APgenericRationalVector_destroy(pVarData);
}
</Code><Code idCode="229">// ===============================
// AP uuid = 11
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="230">// ===============================
// AP uuid = 11
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	initHW();

	startHW();


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}


// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
}
</Code><Code idCode="231">#define SRUDEBUG  // Check SRU Routings for errors.

#define DAC4
#define DAC3

// math defines

#ifndef M_E
	#define M_E		2.7182818284590452354
#endif

#ifndef M_LOG2E
	#define M_LOG2E		1.4426950408889634074
#endif

#ifndef M_LOG10E
	#define M_LOG10E	0.43429448190325182765
#endif

#ifndef M_LN2
	#define M_LN2		0.69314718055994530942
#endif

#ifndef M_LN10
	#define M_LN10		2.30258509299404568402
#endif

#ifndef M_PI
	#define M_PI		3.14159265358979323846
#endif

#ifndef M_PI_2
	#define M_PI_2		1.57079632679489661923
#endif

#ifndef M_PI_4
	#define M_PI_4		0.78539816339744830962
#endif

#ifndef M_1_PI
	#define M_1_PI		0.31830988618379067154
#endif

#ifndef M_2_PI
	#define M_2_PI		0.63661977236758134308
#endif

#ifndef M_2_SQRTPI
	#define M_2_SQRTPI	1.12837916709551257390
#endif

#ifndef M_SQRT2
	#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT1_2
	#define M_SQRT1_2	0.70710678118654752440
#endif

// ===============================
// // extra code for group &quot;ADSP 21369&quot;
// ===============================

// The following definition allows the SRU macro to check for errors. Once the routings have
// been verified, this definition can be removed to save some program memory space.
// The preprocessor will issue a warning stating this when using the SRU macro without this
// definition
#define SRUDEBUG  // Check SRU Routings for errors.
#include &lt;SRU.h&gt;


// c includes
#include &lt;stdio.h&gt;

// =======================================================
// AD 1835 defines
// =======================================================

//
//  AD1835.h
//
//  Configuration values for the AD1835A codec
//

#define DACCTRL1   	(0x0000)  // DAC control register 1    (R/W)
#define DACCTRL2   	(0x1000)  // DAC control register 2    (R/W)
#define DACVOL_L1   (0x2000)  // DAC volume - left 1       (R/W)
#define DACVOL_R1   (0x3000)  // DAC volume - right 1      (R/W)
#define DACVOL_L2   (0x4000)  // DAC volume - left 2       (R/W)
#define DACVOL_R2   (0x5000)  // DAC volume - right 2      (R/W)
#define DACVOL_L3   (0x6000)  // DAC volume - left 3       (R/W)
#define DACVOL_R3   (0x7000)  // DAC volume - right 3      (R/W)
#define DACVOL_L4   (0x8000)  // DAC volume - left 4       (R/W)
#define DACVOL_R4   (0x9000)  // DAC volume - right 4      (R/W)
#define ADCPEAKL   	(0xA000)  // ADC left peak              (R)
#define ADCPEAKR   	(0xB000)  // ADC right peak             (R)
#define ADCCTRL1   	(0xC000)  // ADC control 1             (R/W)
#define ADCCTRL2   	(0xD000)  // ADC control 2             (R/W)
#define ADCCTRL3   	(0xE000)  // ADC control 3             (R/W)

#define RD         	(0x0800)
#define WR         	(0x0000)  // Write to register


// DAC control register 1
#define DEEMPH44_1 	(0x0100)  // Deemphasis filter for 44.1 KHz
#define DEEMPH32   	(0x0200)  // Deemphasis filter for 32.0 KHz
#define DEEMPH48   	(0x0300)  // Deemphasis filter for 48.0 KHz

#define DACI2S     	(0x0000)  // DAC receives I2S format
#define DACRJ      	(0x0020)  // DAC receives I2S format
#define DACDSP     	(0x0040)  // DAC receives I2S format
#define DACLJ      	(0x0060)  // DAC receives I2S format
#define DACPACK256 	(0x0080)  // DAC receives I2S format

#define DAC24BIT   	(0x0000)  // 24-bit output word length
#define DAC20BIT   	(0x0008)  // 20-bit output word length
#define DAC16BIT   	(0x0010)  // 16-bit output word length

#define DACPOWERDN 	(0x0004)  // DAC into power-down mode

#define DACFS48    	(0x0000)  // Sample rate = 48 KHz (x8)
#define DACFS96    	(0x0001)  // Sample rate = 96 KHz (x4)
#define DACFS192   	(0x0002)  // Sample rate = 192 KHz (x2)


// DAC control register 2

#define DACREPLICATE  (0x0100)  // Replicate output of DAC 1/2 on 3/4, 5/6 &amp; 7/8
#define DACMUTE_R4    (0x0080)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L4    (0x0040)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R3    (0x0020)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L3    (0x0010)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R2    (0x0008)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L2    (0x0004)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R1    (0x0002)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L1    (0x0001)  // Mute DAC output channel (clear to un-mute)


//-------------------------------------------------------------------------------
//DAC Volume Control - 10-bit granularity (1024 levels)
#define DACVOL_MIN      (0x000)
#define DACVOL_LOW      (0X100)
#define DACVOL_MED      (0X200)
#define DACVOL_HI       (0X300)
#define DACVOL_MAX      (0x3FF)
#define DACVOL_MASK     (0x3FF)  // Volume in dB is in 10 LSBs
                                 //   3FF = 0 dBFS = 1023/1023
                                 //   3FE = -0.01 dBFS = 1022/1023
                                 //      ...
                                 //   002 = -50.7 dBFS = 3/1023
                                 //   001 = -54.2 dBFS = 2/1023

//-------------------------------------------------------------------------------
//  ADC Control 1

#define ADCHPF     (0x0100)  // High pass filter (AC-coupled)
#define ADCPOWERDN (0x0080)  // DAC into power-down mode
#define ADCFS48    (0x0000)  // Sample rate = 48 KHz
#define ADCFS96    (0x0040)  // Sample rate = 96 KHz

//-------------------------------------------------------------------------------
//  ADC Control 2

#define AUXSLAVE   (0x0000)  // Aux input is in slave mode
#define AUXMASTER  (0x0200)  // Aux input is in master mode

#define ADCI2S     (0x0000)  // ADC transmits in I2S format
#define ADCRJ      (0x0040)  // ADC transmits in right-justified format
#define ADCDSP     (0x0080)  // ADC transmits in DSP (TDM) format
#define ADCLJ      (0x00C0)  // ADC transmits in left-justified format
#define ADCPACK256 (0x0100)  // ADC transmits in packed 256 format
#define ADCAUX256  (0x0180)  // ADC transmits in packed 128 format

#define ADC24BIT   (0x0000)  // 24-bit output word length
#define ADC20BIT   (0x0010)  // 20-bit output word length
#define ADC16BIT   (0x0020)  // 16-bit output word length

#define ADCMUTER   (0x0002)  // Mute right channel from ADC
#define ADCMUTEL   (0x0001)  // Mute right channel from ADC

//-------------------------------------------------------------------------------
//  ADC Control 3

#define IMCLKx2    (0x0000)  // Internal MCLK = external MCLK x 2
#define IMCLKx1    (0x0040)  // Internal MCLK = external MCLK
#define IMCLKx23   (0x0080)  // Internal MCLK = external MCLK x 2/3

#define PEAKRDEN   (0x0020)  // Enable reads of peak ADC levels
#define PEAKLEVELMASK  (0x003F)  // Six significant bit of level
									// 000000 = 0dBFS, -1dB/LSB


// =======================================================
// talk through interface
// =======================================================
#define NUM_SAMPLES 1024

// Function prototypes for this talkthrough code

extern void InitPLL_SDRAM(void);
extern void processBlock(unsigned int *);

extern void InitSRU(void);
extern void Init1835viaSPI(void);

extern void InitSPORT(void);
extern void TalkThroughISR(int);
extern void ClearSPORT(void);

extern void SetupSPI1835 (void) ;
extern void DisableSPI1835 (void) ;
extern void Configure1835Register (int i) ;
extern unsigned int Get1835Register (int i) ;

extern void SetupIRQ01 (void) ;
extern void Irq0ISR (int i) ;
extern void Irq1ISR (int i) ;

typedef void (* TFkt_ADSPuartCB) (unsigned int value);

extern void initUART(TFkt_ADSPuartCB cbRXFunction);
extern void UARTisr();
extern void sendUARTuint32Values(unsigned int *pD, int amount);

extern void Delay (int i) ;

// =======================================================
// init AD1835
// =======================================================
/* Setup the SPI pramaters here in a buffer first */
unsigned int Config1835Param [] = {
            WR | DACCTRL1 | DACI2S | DAC24BIT | DACFS48,
            WR | DACCTRL2 ,//| DACMUTE_R4 | DACMUTE_L4,
            WR | DACVOL_L1 | DACVOL_MAX,
            WR | DACVOL_R1 | DACVOL_MAX,
            WR | DACVOL_L2 | DACVOL_MAX,
            WR | DACVOL_R2 | DACVOL_MAX,
            WR | DACVOL_L3 | DACVOL_MAX,
            WR | DACVOL_R3 | DACVOL_MAX,
            WR | DACVOL_L4 | DACVOL_MAX,
            WR | DACVOL_R4 | DACVOL_MAX,
            WR | ADCCTRL1 | ADCFS48,
            WR | ADCCTRL2 | ADCI2S | ADC24BIT,
            WR | ADCCTRL3 | IMCLKx2
        } ;

volatile int spiFlag ;

//Set up the SPI port to access the AD1835
void SetupSPI1835 ()
{
    /* First configure the SPI Control registers */
    /* First clear a few registers     */
    *pSPICTL = (TXFLSH | RXFLSH) ;
    *pSPIFLG = 0;
    *pSPICTL = 0;

    /* Setup the baud rate to 500 KHz */
    *pSPIBAUD = 100;

    /* Setup the SPI Flag register to FLAG3 : 0xF708*/
    *pSPIFLG = 0xF708;

    /* Now setup the SPI Control register : 0x5281*/
    *pSPICTL = (SPIEN | SPIMS | MSBF | WL16 | TIMOD1) ;

}

//Disable the SPI Port
void DisableSPI1835 ()
{
    *pSPICTL = (TXFLSH | RXFLSH);
}

//Send a word to the AD1835 via SPI
void Configure1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI to indicate that it has finished.
    while (1)
    {
        if (*pSPISTAT &amp; SPIF)
            break ;
    }
    Delay (100) ;
}

//Receive a register setting from the AD1835
unsigned int Get1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI port to indicate that it has finished
    while (1)
    {
        if (SPIF &amp; *pSPISTAT)
            break ;
    }
    Delay (100) ;
    return *pRXSPI ;
//  return i ;
}

//Set up all AD1835 registers via SPI
void Init1835viaSPI()
{
    int configSize = sizeof (Config1835Param) / sizeof (int) ;
    int i ;

    SetupSPI1835 () ;

    for (i = 0; i &lt; configSize; ++i)
    {
        Configure1835Register (Config1835Param[i]) ;
    }

    DisableSPI1835 () ;

}

//Delay loop
void Delay (int i)
{
    for (;i&gt;0;--i)
        asm (&quot;nop;&quot;) ;
}

// =======================================================
// PLL for SDRAM init
// =======================================================
void InitPLL_SDRAM(){

int i, pmctlsetting;

//Change this value to optimize the performance for quazi-sequential accesses (step &gt; 1)
#define SDMODIFY 1

    pmctlsetting= *pPMCTL;
    pmctlsetting &amp;= ~(0xFF); //Clear

    // CLKIN= 24.576 MHz, Multiplier= 27, Divisor= 1, INDIV=1, CCLK_SDCLK_RATIO= 2.
    // Core clock = (24.576 MHz * 27) /2 = 331.776 MHz
    pmctlsetting= SDCKR2|PLLM27|INDIV|DIVEN;
    *pPMCTL= pmctlsetting;
    pmctlsetting|= PLLBP;
    *pPMCTL= pmctlsetting;

    //Wait for around 4096 cycles for the pll to lock.
    for (i=0; i&lt;4096; i++)
          asm(&quot;nop;&quot;);

    *pPMCTL ^= PLLBP;       //Clear Bypass Mode
    *pPMCTL |= (CLKOUTEN);  //and start clkout


    // Programming SDRAM control registers and enabling SDRAM read optimization
    // CCLK_SDCLK_RATIO= 2.5
    // RDIV = ((f SDCLK X t REF )/NRA) - (tRAS + tRP )
    // (166*(10^6)*64*(10^-3)/4096) - (7+3) = 2583

    *pSDRRC= (0xA17)|(SDMODIFY&lt;&lt;17)|SDROPT;

    //===================================================================
    //
    // Configure SDRAM Control Register (SDCTL) for PART MT48LC4M32B2
    //
    //  SDCL3  : SDRAM CAS Latency= 3 cycles
    //  DSDCLK1: Disable SDRAM Clock 1
    //  SDPSS  : Start SDRAM Power up Sequence
    //  SDCAW8 : SDRAM Bank Column Address Width= 8 bits
    //  SDRAW12: SDRAM Row Address Width= 12 bits
    //  SDTRAS7: SDRAM tRAS Specification. Active Command delay = 7 cycles
    //  SDTRP3 : SDRAM tRP Specification. Precharge delay = 3 cycles.
    //  SDTWR2 : SDRAM tWR Specification. tWR = 2 cycles.
    //  SDTRCD3: SDRAM tRCD Specification. tRCD = 3 cycles.
    //
    //--------------------------------------------------------------------

    *pSDCTL= SDCL3|DSDCLK1|SDPSS|SDCAW8|SDRAW12|SDTRAS7|SDTRP3|SDTWR2|SDTRCD3;

    // Note that MS2 &amp; MS3 pin multiplexed with flag2 &amp; flag3.
    // MSEN bit must be enabled to access SDRAM, but LED7 cannot be driven with sdram
    *pSYSCTL |=MSEN;

    // Mapping Bank 2 to SDRAM
    // Make sure that jumper is set appropriately so that MS2 is connected to
    // chip select of 16-bit SDRAM device
    *pEPCTL |=B2SD;
    *pEPCTL &amp;= ~(B0SD|B1SD|B3SD);

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL0) Bank 0 for the ISSI IS61LV5128
    //
    //  WS2 : Wait States = 2 cycles
    //  HC1  : Bus Hold Cycle (at end of write access)= 1 cycle.
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //SRAM Settings
    *pAMICTL0 = WS2|HC1|AMIEN|BW8;

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL) Bank 1 for the AMD AM29LV08
    //
    //  WS23 : Wait States= 23 cycles
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //Flash Settings
    *pAMICTL1 = WS23|AMIEN|BW8;
}

// =======================================================
// serial Port
// =======================================================
/*
   Here is the mapping between the SPORTS and the DACS
   ADC -&gt; DSP  : SPORT0A : I2S
   DSP -&gt; DAC1 : SPORT1A : I2S
   DSP -&gt; DAC2 : SPORT1B : I2S
   DSP -&gt; DAC3 : SPORT2A : I2S
   DSP -&gt; DAC4 : SPORT2B : I2S
*/

unsigned int PCI = 0x00080000 ;
unsigned int OFFSET = 0x00080000 ;

// TCB blocks for Chaining
//Each block will be used for:
//      Filling from the ADC
//      Processing filled data
//      Sending to DAC
//
//Each one is doing only one of these steps for each SPORT interrupt.

//For this example the startup state is
// Start to 1st interrupt: gBlock_A is filled first, gBlock_C is sent
// 1st int to 2nd int: gBlock_C filled, gBlock_A processed, gBlock_B sent
// 2nd int to 3rd int: gBlock_B filled, gBlock_C processed, gBlock_A sent
// 3rd int to 4th int: gBlock_A filled, gBlock_B processed, gBlock_C sent
unsigned int gBlock_A[NUM_SAMPLES] ;
unsigned int gBlock_B[NUM_SAMPLES] ;
unsigned int gBlock_C[NUM_SAMPLES] ;

//Set up the TCBs to rotate automatically
int TCB_gBlock_A[4] = { 0, sizeof(gBlock_A), 1, 0};;
int TCB_gBlock_B[4] = { 0, sizeof(gBlock_B), 1, 0};
int TCB_gBlock_C[4] = { 0, sizeof(gBlock_C), 1, 0};

void InitSPORT()
{
    //Proceed from Block A to Block C
    TCB_gBlock_A[0] = (int) TCB_gBlock_C + 3 - OFFSET + PCI ;
    TCB_gBlock_A[3] = (unsigned int) gBlock_A - OFFSET ;

    //Proceed from Block B to Block A
    TCB_gBlock_B[0] = (int) TCB_gBlock_A + 3 - OFFSET + PCI ;
    TCB_gBlock_B[3] = (unsigned int) gBlock_B - OFFSET ;

    //Proceed from Block C to Block B
    TCB_gBlock_C[0] = (int) TCB_gBlock_B + 3 - OFFSET + PCI ;
    TCB_gBlock_C[3] = (unsigned int) gBlock_C - OFFSET ;

    //Clear the Mutlichannel control registers
    *pSPMCTL0 = 0;
    *pSPMCTL1 = 0;
    *pSPMCTL2 = 0;
    *pSPCTL0 = 0 ;
    *pSPCTL1 = 0 ;
    *pSPCTL2 = 0 ;

    //============================================================
    //
    // Configure SPORT 0 for input from ADC
    //
    //------------------------------------------------------------


    *pSPCTL0 = (OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A);

    // Enabling Chaining
    // Block A will be filled first
    *pCPSP0A = (unsigned int) TCB_gBlock_A - OFFSET + 3 ;

    //============================================================
    //
    // Configure SPORTs 1 &amp; 2 for output to DACs 1-4
    //
    //------------------------------------------------------------

    #ifdef DAC1
    *pSPCTL1 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC1
    *pCPSP1A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC2
    *pSPCTL1 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC2
    *pCPSP1B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC3
    *pSPCTL2 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC3
    *pCPSP2A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC4
    *pSPCTL2 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC4
    *pCPSP2B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif
}


// =======================================================
// init SRU
// =======================================================

void InitSRU(){

//-----------------------------------------------------------------------------
//
//  MCLK: The output of the 12.288 MHz xtal is either directly connected to the
//        codec, but also connected to DAI_P06, or just to DAI_P17. This is
//        determined by switch SW3 For this example we route the MCLK into
//        DAI_P17 and supply the clock to the ADC via DAI_P06  by routing the
//        signal through the SRU.

//  Tie the pin buffer input LOW.
    SRU(LOW,DAI_PB17_I);

//  Tie the pin buffer enable input LOW
    SRU(LOW,PBEN17_I);

//-----------------------------------------------------------------------------
//
//  Connect the ADC: The codec drives a BCLK output to DAI pin 7, a LRCLK
//          (a.k.a. frame sync) to DAI pin 8 and data to DAI pin 5.
//
//          Connect the ADC to SPORT0, using data input A
//
//          All three lines are always inputs to the SHARC so tie the pin
//          buffer inputs and pin buffer enable inputs all low.


//------------------------------------------------------------------------
//  Connect the ADC to SPORT0, using data input A

    //  Clock in on pin 7
    SRU(DAI_PB07_O,SPORT0_CLK_I);

    //  Frame sync in on pin 8
    SRU(DAI_PB08_O,SPORT0_FS_I);

    //  Data in on pin 5
    SRU(DAI_PB05_O,SPORT0_DA_I);

//------------------------------------------------------------------------
//    Tie the pin buffer inputs LOW for DAI pins 5, 7 and 8.  Even though
//    these pins are inputs to the SHARC, tying unused pin buffer inputs
//    LOW is &quot;good coding style&quot; to eliminate the possibility of
//    termination artifacts internal to the IC.  Note that signal
//    integrity is degraded only with a few specific SRU combinations.
//    In practice, this occurs VERY rarely, and these connections are
//    typically unnecessary.


    SRU(LOW,DAI_PB05_I);
    SRU(LOW,DAI_PB07_I);
    SRU(LOW,DAI_PB08_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs LOW for DAI pins 5, 6, 7 and 8 so
//  that they are always input pins.

    SRU(LOW,PBEN05_I);
    SRU(LOW,PBEN07_I);
    SRU(LOW,PBEN08_I);

//-----------------------------------------------------------------------------
//
//  Connect the DACs: The codec accepts a BCLK input from DAI pin 13 and
//          a LRCLK (a.k.a. frame sync) from DAI pin 14 and has four
//          serial data outputs to DAI pins 12, 11, 10 and 9
//
//          Connect DAC1 to SPORT1, using data output A
//          Connect DAC2 to SPORT1, using data output B
//          Connect DAC3 to SPORT2, using data output A
//          Connect DAC4 to SPORT2, using data output B
//
//          Connect the clock and frame sync inputs to SPORT1 and SPORT2
//          should come from the ADC on DAI pins 7 and 8, respectively
//
//          Connect the ADC BCLK and LRCLK back out to the DAC on DAI
//          pins 13 and 14, respectively.
//
//          All six DAC connections are always outputs from the SHARC
//          so tie the pin buffer enable inputs all high.
//

//------------------------------------------------------------------------
//  Connect the pin buffers to the SPORT data lines and ADC BCLK &amp; LRCLK

    SRU(SPORT2_DB_O,DAI_PB09_I);
    SRU(SPORT2_DA_O,DAI_PB10_I);
    SRU(SPORT1_DB_O,DAI_PB11_I);
    SRU(SPORT1_DA_O,DAI_PB12_I);

//------------------------------------------------------------------------
//  Connect the clock and frame sync input from the ADC directly
//    to the output pins driving the DACs.

    SRU(DAI_PB07_O,DAI_PB13_I);
    SRU(DAI_PB08_O,DAI_PB14_I);
    SRU(DAI_PB17_O,DAI_PB06_I);

//------------------------------------------------------------------------
//  Connect the SPORT clocks and frame syncs to the clock and
//  frame sync from the SPDIF receiver

    SRU(DAI_PB07_O,SPORT1_CLK_I);
    SRU(DAI_PB07_O,SPORT2_CLK_I);
    SRU(DAI_PB08_O,SPORT1_FS_I);
    SRU(DAI_PB08_O,SPORT2_FS_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs HIGH to make DAI pins 9-14 outputs.
    SRU(HIGH,PBEN06_I);
    SRU(HIGH,PBEN09_I);
    SRU(HIGH,PBEN10_I);
    SRU(HIGH,PBEN11_I);
    SRU(HIGH,PBEN12_I);
    SRU(HIGH,PBEN13_I);
    SRU(HIGH,PBEN14_I);
//--------------------------------------------------------------------------
// Route SPI signals to AD1835.

    SRU(SPI_MOSI_O,DPI_PB01_I)      //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I)     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I)      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG3_O, DPI_PB04_I)     //Connect SPI FLAG3 to DPI PB4.
//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peipherals to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG3_PBEN_O, DPI_PBEN04_I);

//-----------------------------------------------------------------------------
// UART config
    SRU2(UART0_TX_O,DPI_PB09_I); // UART transmit signal is connected to DPI pin 9
    SRU2(HIGH,DPI_PBEN09_I);
    SRU2(DPI_PB10_O,UART0_RX_I); // connect the pin buffer output signal to the UART0 receive
    SRU2(LOW,DPI_PB10_I);
    SRU2(LOW,DPI_PBEN10_I);      // disables DPI pin10 as input
}

// =======================================================
// IRQ's
// =======================================================
void SetupIRQ01 ()
{
    //Enable the pins as IRQ0 and IRQ1
    *pSYSCTL|= IRQ0EN | IRQ1EN;
    asm (&quot;#include &lt;def21369.h&gt;&quot;) ;
    //Set the IRQ pins to be edge sensitive
    asm (&quot;bit set mode2 IRQ0E;&quot;) ;
    asm (&quot;bit set mode2 IRQ1E;&quot;) ;
}

void Irq0ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ0 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol -= 0x3F ;
    rightDAC4Vol -= 0x3F ;

    if (leftDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

void Irq1ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ1 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol += 0x3F ;
    rightDAC4Vol += 0x3F ;

    if (leftDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

// =======================================================
// UART
// =======================================================

// type for the low level receive
typedef struct SADSPuartRecv {
	unsigned int 	val;	//!&lt; the value
	int				i;		//!&lt; the index
	TFkt_ADSPuartCB cb;		//!&lt; the callback function when we received 4 bytes of data
} TADSPuartRecv;

TADSPuartRecv gUARTrx;


// init ADSP uart
//          Bits per Second  -&gt; 19200
//          Data Bits        -&gt; 8
//          Parity           -&gt; odd
//          Stop Bits        -&gt; 2
//          Flow Control     -&gt; None
void initUART(TFkt_ADSPuartCB cbRXFunction) {
	// Sets the Baud rate for UART0
	*pUART0LCR = UARTDLAB;  //enables access to Divisor register to set baud rate
//	*pUART0DLL = 0x1c;      //0x21c = 540 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
//    *pUART0DLH = 0x02;

	*pUART0DLL = 0x38;      //1080 = 0x438 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
	*pUART0DLH = 0x04;



    // Configures UART0 LCR
//    *pUART0LCR = UARTWLS8| 				// word length 8
//                 UARTPEN| 				// parity enable ODD parity
//                 UARTSTB ; 				// Two stop bits
	*pUART0LCR = UARTWLS8;	// 8Bit 1StopBit NoParity

    //enables UART0 in receive mode
    *pUART0RXCTL = UARTEN;
    //enables UART0 in core driven mode
    *pUART0TXCTL = UARTEN;

    // set rx callback function and the state machine
    gUARTrx.val = 0;
    gUARTrx.i = 3;
    gUARTrx.cb = cbRXFunction;
}

// UART isr
void UARTisr() {
	unsigned int v;
	v = *pUART0RBR;
	// shift register
	gUARTrx.val &lt;&lt;= 8;
	gUARTrx.val |= v;
	if (gUARTrx.i) {
		gUARTrx.i--;
	} else {
		gUARTrx.cb(gUARTrx.val);
		gUARTrx.i = 3;
		gUARTrx.val = 0;
	}
}

// UART send
void sendUARTuint32Values(unsigned int *pD, int amount) {
	unsigned int	v;
	int				i;
	int				j;

	for (i = 0; i &lt; amount; i++) {
		v = *pD;
		for (j = 0; j &lt; 4; j++) {
			// wait till the transmitter is ready
			while ((*pUART0LSR &amp; UARTTHRE) == 0);
			// mask all other bytes out and send the lowest byte
			*pUART0THR = v &amp; 0xFF;
			v &gt;&gt;= 8;
		}
		pD++;
	}
	// wait till the transmitter is ready
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
}


// =======================================================
// SPORT IRQs
// =======================================================

    //Pointer to the blocks

unsigned int *gpProcessBuffer[3] = {gBlock_A,gBlock_C,gBlock_B};

// Counter to choose which buffer to process
volatile int gProcessBufferCounter=2;
// Semaphore to indicate to main that a block is ready for processing
volatile int gProcessBufferReady=0;

void TalkThroughISR(int sig_int)
{
    //Increment the block pointer
    gProcessBufferCounter++;
    gProcessBufferCounter %= 3;

    gProcessBufferReady = 1;
}

// =======================================================
// LED func
// =======================================================

void LEDSRUinit () {
	// Init LED Ports
	SRU(LOW,DPI_PB06_I);				// Connect GND to DPI_PB06 input (LED1)
	SRU(LOW,DPI_PB07_I);	    		// Connect GND to DPI_PB07 input (LED2)
	SRU(LOW,DPI_PB08_I);	    		// Connect GND to DPI_PB08 input (LED3)
	SRU(LOW,DPI_PB13_I);	    		// Connect GND to DPI_PB13 input (LED4)
	SRU(LOW,DPI_PB14_I);	    		// Connect GND to DPI_PB14 input (LED5)
	SRU(LOW,DAI_PB15_I);		  		// Connect GND to DAI_PB15 input (LED6)
	SRU(LOW,DAI_PB16_I);  				// Connect GND to DAI_PB16 input (LED7)

	//Enabling the Buffer using the following sequence: High -&gt; Output, Low -&gt; Input

	SRU(HIGH,DPI_PBEN06_I);				// LED 1
	SRU(HIGH,DPI_PBEN07_I);				// LED 2
	SRU(HIGH,DPI_PBEN08_I);				// LED 3
	SRU(HIGH,DPI_PBEN13_I);				// LED 4
	SRU(HIGH,DPI_PBEN14_I);				// LED 5
	SRU(HIGH,PBEN15_I);					// LED 6
	SRU(HIGH,PBEN16_I);					// LED 7
}

#define set_LED_1 SRU(HIGH,DPI_PB06_I)
#define set_LED_2 SRU(HIGH,DPI_PB07_I)
#define set_LED_3 SRU(HIGH,DPI_PB08_I)
#define set_LED_4 SRU(HIGH,DPI_PB13_I)
#define set_LED_5 SRU(HIGH,DPI_PB14_I)
#define set_LED_6 SRU(HIGH,DPI_PB15_I)
#define set_LED_7 SRU(HIGH,DPI_PB16_I)

#define clear_LED_1 SRU(LOW,DPI_PB06_I)
#define clear_LED_2 SRU(LOW,DPI_PB07_I)
#define clear_LED_3 SRU(LOW,DPI_PB08_I)
#define clear_LED_4 SRU(LOW,DPI_PB13_I)
#define clear_LED_5 SRU(LOW,DPI_PB14_I)
#define clear_LED_6 SRU(LOW,DPI_PB15_I)
#define clear_LED_7 SRU(LOW,DPI_PB16_I)

int x = 0;
void cbUARTdummy (unsigned int v) {
	x++;
}

// =======================================================
// init HW
// =======================================================

void initHW() {

	// uart stuff
	*pPICR2 &amp;= ~(0x3E0); //Sets the UART0 receive interrupt to P13

	*pPICR2 |= (0x13&lt;&lt;5);


    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

	*pUART0LCR=0;
    *pUART0IER   = UARTRBFIE;    // enables UART0 receive interrupt
	interrupt(SIG_P13,UARTisr);


    // init LEDs
    LEDSRUinit();

    // init UART
    initUART (cbUARTdummy);
    unsigned int vals [] = {1,2,3,4,5,0x11223344,0x55667788};
    sendUARTuint32Values (vals,sizeof(vals)/sizeof(unsigned int));

}

void startHW() {
    // Finally setup the sport to receive / transmit the data
    InitSPORT();
}


// =======================================================
// processing
// =======================================================


#ifndef INT24_MAX
	#define INT24_MIN (-16777215-1)
	#define INT24_MAX (16777215)
#endif

#define dAD1835_ChannelAmount (2)
#define dAD1835_leftChannelOffset (1)
#define dAD1835_rightChannelOffset (0)

#define dAD1835_ChannelFlag_left ('l')
#define dAD1835_ChannelFlag_right ('r')

// the adsp codec channel type
typedef struct SCodecChannel {
	unsigned int 	size;			//!&lt; size of the channel
	char			channelFlag;	//!&lt; l=left r=right channel
} TCodecChannel;

// the codec channel list
typedef struct SCodecChannelList {
	TCodecChannel *		pCC;
	int					number;
} TCodecChannelList;

// find the channel struct by a given channel
inline TCodecChannel * ADSP_getChannel (int channel) {
	extern TCodecChannelList gADSPcodecChannels;
	if ((channel &lt; 0) || (channel &gt;= gADSPcodecChannels.number)) return NULL;
	return &amp;gADSPcodecChannels.pCC[channel];
}

// wait for the sample frame
inline void ADSP_waitForSamples () {
	if (!gProcessBufferReady) {
		set_LED_1;
		while (!gProcessBufferReady) {

		};
		gProcessBufferReady = 0;
		clear_LED_1;
	}
}

// ADSP ADC 24Bit value format
// 011...11		+FS
// 0......0		0
// 111...11		-FS
//
// reads some samples from the input channel
void ADSP_readSamplesFromChannel (TCodecChannel * pIC, float * pBuffer, unsigned int amount) {
	// wait for new samples
	ADSP_waitForSamples ();

	// after that get the pointer to the buffer
	int * pBinSRC  = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pIC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}

//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBuffer = ((float) ((int)(*pBinSRC)&lt;&lt;8)) * (1.0/2147483648.0);
		pBuffer++;
		pBinSRC += dAD1835_ChannelAmount;
	}
}


// writes some samples to the output channel
void ADSP_writesSamplesToChannel (TCodecChannel * pOC, float * pBuffer, unsigned int amount) {
	int * pBinSRC = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	float tv;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pOC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}
//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBinSRC = ((int)(2147483648.0 * pBuffer[i]))&gt;&gt;8;
		pBinSRC += dAD1835_ChannelAmount;
	}
}

TCodecChannel gADSPcodecChannel []= {
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left},	// ADC left input
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left}	// DAC4 &amp; DAC3 left output
};

TCodecChannelList gADSPcodecChannels = {
		gADSPcodecChannel,
		sizeof(gADSPcodecChannel) / sizeof(TCodecChannel)
};
</Code><Code idCode="232">// ===============================
// driver uuid =2
// ===============================

// INFO
// the ADSP internal dataformat is BIG endian
// the UART send function sends data in little endian
// thats why we use the BIG endian function

// ------------------------------
// drv own functions
// ------------------------------

// struct for the drv data
typedef struct SADSPuartDrv {
	TAPMsgHeader				h;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TADSPuartDrv;

TADSPuartDrv gADSPuartDrv;

// ------------------------------
// drv own functions
// ------------------------------

void drv_2_sendHeader (
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgTypeID] = msgId;
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgNumber] = num;
	gADSPuartDrv.h[eAPMsgHeaderPosition_receiver] = recv;
	gADSPuartDrv.h[eAPMsgHeaderPosition_length] = length;
	sendUARTuintVectorBigEndian(gADSPuartDrv.h,sizeof(TAPMsgHeader)/sizeof(uint32_t));
}

// call back function of the uart driver
int drv_2_cbAPClient (unsigned int d) {
	return gADSPuartDrv.rxSM.state (&amp;(gADSPuartDrv.rxSM), &amp;d, 1);
}

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	// init header
	gADSPuartDrv.h[eAPMsgHeaderPosition_endian] = gAPendianFlag;
	gADSPuartDrv.h[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	gADSPuartDrv.h[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgTypeID] = 0;
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgNumber] = 0;
	gADSPuartDrv.h[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = &amp;gADSPuartDrv;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;gADSPuartDrv.rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}

//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}

//send raw data
int drv_2_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t *pData) {
	sendUARTraw4ByteVector(pData,amount);
	return 0;
}

//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_2_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	sendUARTintVectorBigEndian(pData,amount);
	return 0;
}
//sends float data in float chunks
int drv_2_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	sendUARTFloatVector(pData,amount);
	return 0;
}



//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_ACK, receiver, mNum, 0);
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_NACK, receiver, mNum, 0);
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	drv_2_sendHeader(eAPMsgTypes_startPrg, receiver, mNum, 0);
	sendUARTintVectorBigEndian(globalVariableNumber,1);
	sendUARTintVectorBigEndian(localVariableNumber,1);
	sendUARTintVectorBigEndian(instructionNumber,1);
	return 0;
}

//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	drv_2_sendHeader(eAPMsgTypes_sendVariable, receiver, mNum, 3);
	sendUARTintVectorBigEndian(&amp;index,1);
	sendUARTintVectorBigEndian(&amp;varTypeID,1);
	sendUARTintVectorBigEndian(&amp;num,1);
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	drv_2_sendHeader(eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1);
	sendUARTintVectorBigEndian(&amp;index,1);
	sendUARTraw4ByteVector(fbc,sizeof(int32_t)*dAPInterpreterFuncMaxParams);
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_endPrg, receiver, mNum, 0);
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_stop, receiver, mNum, 0);
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_step, receiver, mNum, 0);
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_run, receiver, mNum, 0);
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	drv_2_sendHeader(eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1);
	sendUARTintVectorBigEndian(&amp;gIndex,1);
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_login, receiver, mNum, 0);
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_logout, receiver, mNum, 0);
	return 0;
}
</Code><Code idCode="233">// ===============================
// AP uuid = 12
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	initHW();

	startHW();

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}


// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
}
</Code><Code idCode="234">// ===============================
// AP uuid = 11
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	msp430_initHW(10);

	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

// ================================
// MMU functions
// ================================

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}

// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

extern void drv_3_feedRecvStateM (void);

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// process msg receiving
		drv_3_feedRecvStateM ();

		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}

// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;state, msgEndian);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;index, msgEndian);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID, msgEndian);
		APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;index, msgEndian);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != gAPendianFlag) {
		APendianConversation32Bit((uint32_t *)&amp;fid, msgEndian);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	// we go for sure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}


// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:
	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	drv_3_feedRecvStateM();
	goto checkMessages;
exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		drv_3_feedRecvStateM();
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i], gAPendianFlag);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}

// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}
</Code><Code idCode="235">// ===============================
// driver uuid =3
// ===============================

// struct for the drv data
typedef struct SMSP430uartDrv {
	TAPMsgHeader				h;			//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TMSP430uartDrv;

TMSP430uartDrv gMSP430uartDrv;

// ------------------------------
// drv own functions
// ------------------------------

void drv_3_sendHeader (
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgTypeID] = msgId;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgNumber] = num;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_receiver] = recv;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_length] = length;
	msp430_UART_send((unsigned char *)gMSP430uartDrv.h,sizeof(TAPMsgHeader));
}


// function for feeding the recv state machine
void drv_3_feedRecvStateM () {
	uint32_t d;
	while (!stjFIFO_readElement(&amp;gMsp430_uartFIFO ,&amp;d)) {
		gMSP430uartDrv.rxSM.state (&amp;(gMSP430uartDrv.rxSM), &amp;d, 1);
	}
}
//open an existing driver and bind it to the AP
int drv_3_open (void * pAP, struct SAPMsgDrv *pDrv) {
	// init header
	gMSP430uartDrv.h[eAPMsgHeaderPosition_endian] = gAPendianFlag;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgTypeID] = 0;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgNumber] = 0;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = &amp;gMSP430uartDrv;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;gMSP430uartDrv.rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}

//close the driver
int drv_3_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_3_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}

//sends raw data in uint32_t chunks
int drv_3_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	msp430_UART_send((unsigned char *)pData,amount*sizeof(uint32_t));
	return 0;
}
//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_3_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	msp430_UART_send((unsigned char *)pData,amount*sizeof(uint32_t));
	return 0;
}
//sends float data in float chunks
int drv_3_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	msp430_UART_send((unsigned char *)pData,amount*sizeof(uint32_t));
	return 0;
}

//acknowledge
int drv_3_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_ACK, receiver, mNum, 0);
	return 0;
}
//not acknowledge
int drv_3_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_NACK, receiver, mNum, 0);
	return 0;
}
//start sending a program
int drv_3_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	drv_3_sendHeader(eAPMsgTypes_startPrg, receiver, mNum, 0);
	msp430_UART_send((unsigned char *)&amp;globalVariableNumber,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;localVariableNumber,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;instructionNumber,sizeof(int32_t));
	return 0;
}

//sends a variable
int drv_3_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	drv_3_sendHeader(eAPMsgTypes_sendVariable, receiver, mNum, 3);
	msp430_UART_send((unsigned char *)&amp;index,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;varTypeID,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;num,sizeof(int32_t));
	return 0;
}
//sends an instruction
int drv_3_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	drv_3_sendHeader(eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1);
	msp430_UART_send((unsigned char *)&amp;index,sizeof(int32_t));
	msp430_UART_send((unsigned char *)fbc,sizeof(int32_t) * (dAPInterpreterFuncMaxParams+1));
	return 0;
}
//sings that the program transmission has completed
int drv_3_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_endPrg, receiver, mNum, 0);
	return 0;
}
//stops the AP
int drv_3_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_stop, receiver, mNum, 0);
	return 0;
}
//the AP executes one instruction
int drv_3_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_step, receiver, mNum, 0);
	return 0;
}
//the AP runs the program
int drv_3_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_run, receiver, mNum, 0);
	return 0;
}
//a variable going to be updated
int drv_3_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	drv_3_sendHeader(eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1);
	msp430_UART_send((unsigned char *)&amp;gIndex,sizeof(int32_t));
	return 0;
}
//a AP is going to be logged in to the system
int drv_3_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_login, receiver, mNum, 0);
	return 0;
}
//a AP is going to be logged out of the system
int drv_3_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_logout, receiver, mNum, 0);
	return 0;
}
</Code><Code idCode="236">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;MSP430.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}

#endif

// needed for the printf functions
int putchar(int v) {
	return v;
}

TAP AP;

// the main function
int main()
{

	int rc;

	TAPMsgDrv UARTdrv;

	msp430_start();

	APdriver_3_init(&amp;UARTdrv);

	rc = APinit(&amp;AP,430,&amp;UARTdrv,1,50,eAP_littleEndian);
	msp430_LCD_print(0,0,&quot;AP start ...&quot;);
	if (rc) {
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;
	msp430_LCD_print(0,0,&quot;AP run ...&quot;);
	rc = APInterpreterSetState (AP.IP,gAPendianFlag,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	msp430_LCD_cmdClear();
	msp430_LCD_print(0,0,&quot;AP shout down ...&quot;);
	APdelete(&amp;AP);

	return 0;
}
</Code><Code idCode="237">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

typedef struct SMSP430_panel {
	unsigned char dummy;
} TMSP430_panel;

typedef struct SMSP430_panelVec {
	TMSP430_panel * pP;
	int num;
} TMSP430_panelVec;

// updates a variable the AP
int HALimpl_100_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	TMSP430_panelVec * pPV;

	pPV = malloc(sizeof(TMSP430_panelVec));
	if (!pPV) return NULL;

	pPV-&gt;pP = malloc(sizeof(TMSP430_panel)*numberOfElements);
	if (!pPV-&gt;pP) {
		free(pPV);
		return NULL;
	}
	pPV-&gt;num = (int) numberOfElements;
	return pPV;
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	TMSP430_panelVec * pPV = (TMSP430_panelVec *) pVarData;
	if (pPV) {
		if (pPV-&gt;pP) free(pPV-&gt;pP);
		free (pPV);
	}
}
</Code><Code idCode="238">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

typedef struct SMSP430_button {
	unsigned char port1Mask;
} TMSP430_button;

typedef struct SMSP430_buttonVec {
	TMSP430_button * pB;
	int num;
} TMSP430_buttonVec;


// updates a variable the AP
int HALimpl_101_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	TMSP430_buttonVec * pBV;

	pBV = malloc(sizeof(TMSP430_buttonVec));
	if (!pBV) return NULL;

	pBV-&gt;pB = malloc(sizeof(TMSP430_button)*numberOfElements);
	if (!pBV-&gt;pB) {
		free(pBV);
		return NULL;
	}

	pBV-&gt;num = (int) numberOfElements;
	memset (pBV-&gt;pB, 0, sizeof(TMSP430_button)*numberOfElements);
	return pBV;
}
// updates the vars at the other APs
int HALimpl_101_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	TMSP430_buttonVec * pBV = (TMSP430_buttonVec *) pVarData;
	if (pBV) {
		if (pBV-&gt;pB) free(pBV-&gt;pB);
		free (pBV);
	}
}</Code><Code idCode="239">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

typedef struct SMSP430_LED {
	unsigned char port3mask;
} TMSP430_LED;

typedef struct SMSP430_LEDvec {
	TMSP430_LED * pL;
	int num;
} TMSP430_LEDvec;

// updates a variable the AP
int HALimpl_102_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	TMSP430_LEDvec * pLV;

	pLV = malloc(sizeof(TMSP430_LEDvec));
	if (!pLV) return NULL;

	pLV-&gt;pL = malloc(sizeof(TMSP430_LED)*numberOfElements);
	if (!pLV-&gt;pL) {
		free(pLV);
		return NULL;
	}

	pLV-&gt;num = (int) numberOfElements;
	memset (pLV-&gt;pL, 0, sizeof(TMSP430_LED)*numberOfElements);
	return pLV;
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	TMSP430_LEDvec * pLV = (TMSP430_LEDvec *) pVarData;
	if (pLV) {
		if (pLV-&gt;pL) free(pLV-&gt;pL);
		free (pLV);
	}

}
</Code><Code idCode="240">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

typedef struct SMSP430_display {
	unsigned char dummy; 
} TMSP430_display;

typedef struct SMSP430_displayVec {
	TMSP430_display * pD;
	int num;
} TMSP430_displayVec;

// updates a variable the AP
int HALimpl_103_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	TMSP430_displayVec * pDV;

	pDV = malloc(sizeof(TMSP430_displayVec));
	if (!pDV) return NULL;

	pDV-&gt;pD = malloc(sizeof(TMSP430_display)*numberOfElements);
	if (!pDV-&gt;pD) {
		free(pDV);
		return NULL;
	}

	pDV-&gt;num = (int) numberOfElements;
	memset (pDV-&gt;pD, 0, sizeof(TMSP430_display)*numberOfElements);
	return pDV;
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	TMSP430_displayVec * pDV = (TMSP430_displayVec *) pVarData;
	if (pDV) {
		if (pDV-&gt;pD) free(pDV-&gt;pD);
		free (pDV);
	}
}
</Code><Code idCode="241">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="242">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// do nothing
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="243">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t UUID = pParams[0].fp_integer;
// parameter b descr: button
	TMSP430_buttonVec * pbv = (TMSP430_buttonVec *) pParams[1].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TMSP430_panelVec * pp = (TMSP430_panelVec *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;


	if ((bIndex &lt; 0) || (bIndex &gt;= pbv-&gt;num)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -202;
		return;
	}
	switch (UUID) {
		case 21:
			pbv-&gt;pB[bIndex].port1Mask = BIT5;
			break;
		case 22:
			pbv-&gt;pB[bIndex].port1Mask = BIT6;
			break;
		case 23:
			pbv-&gt;pB[bIndex].port1Mask = BIT7;
			break;
		default:
			((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -202;
			return;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="244">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t UUID = pParams[0].fp_integer;
// parameter b descr: button
	TMSP430_displayVec * pdv = (TMSP430_displayVec *) pParams[1].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TMSP430_panelVec * ppv = pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if ((dIndex &lt; 0) || (dIndex &gt;= pdv-&gt;num)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -203;
		return;
	}
	if (UUID != 11) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -203;
		return;
	}
	// do nothing
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="245">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t UUID = pParams[0].fp_integer;
// parameter l descr: led
	TMSP430_LEDvec * plv = (TMSP430_LEDvec *) pParams[1].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TMSP430_panelVec * ppv = (TMSP430_panelVec *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if ((lIndex &lt; 0) || (lIndex &gt;= plv-&gt;num)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -204;
		return;
	}
	switch (UUID) {
		case 31:
			plv-&gt;pL[lIndex].port3mask = BIT6;
			break;
		case 32:
			plv-&gt;pL[lIndex].port3mask = BIT7;
			break;
		default:
			((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -204;
			return;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="246">// ===============================
// function implementation for uiCheckButtonPressed(var id = 210)
// description: if the button was pressed the CF is set
// ===============================

void HALfunc_ID210_uiCheckButtonPressed(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter b descr: button
	TMSP430_buttonVec * pbv = (TMSP430_buttonVec *) pParams[0].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[1].fp_integer;

	if ((bIndex &lt; 0) || (bIndex &gt;= pbv-&gt;num)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -210;
		return;
	}
	unsigned char r = P1IN &amp; pbv-&gt;pB[bIndex].port1Mask;
	((TAPInterpreterCPU *)pIPcpu)-&gt;CF = r ? 1 : 0;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="247">// ===============================
// function implementation for uiSetLED(var id = 211)
// description: set the LED state
// ===============================

void HALfunc_ID211_uiSetLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter l descr: LED
	TMSP430_LEDvec * plv = pParams[0].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[1].fp_integer;
// parameter onFlag descr: if the flag is not zero the LED is turned on
	int32_t onFlag = pParams[2].fp_integer;

	if ((lIndex &lt; 0) || (lIndex &gt;= plv-&gt;num)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -211;
		return;
	}

	if (onFlag) {
		P3OUT &amp;= ~(plv-&gt;pL[lIndex].port3mask);
	} else {
		P3OUT |= plv-&gt;pL[lIndex].port3mask;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="248">// ===============================
// function implementation for uiSetDisplay(var id = 212)
// description: set the text of a display
// ===============================

void HALfunc_ID212_uiSetDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	TMSP430_display * pd = pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter s descr: the string
	TAPstringVector * pSV = pParams[2].fp_pD;
// parameter iString descr: index of the string at the array
	int iString = (int) pParams[3].fp_integer;

	msp430_LCD_print(0,0,pSV-&gt;sv[iString].szTxt);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="249">// ===============================
// AP uuid = 12
// ===============================



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="250">// =================================================
// a generic biquad filter lib based on the math.h
// part I - defines
// =================================================
//        a0 + a1 *z-1 + a2*z-2
// H(z) = ---------------------
//        1 + b1 *z-1 + b2*z-2
//
// y(n)   a0 + a1 *z-1 + a2*z-2
// ---- = ---------------------
// x(n)   1 + b1 *z-1 + b2*z-2
//
// y(n) + b1 *y(n-1) + b2*y(n-2) = a0 * x(n) + a1 *x(n-1) + a2*x(n-2)
// y(n) = a0 * x(n) + a1 *x(n-1) + a2*x(n-2) - b1 *y(n-1) + b2*y(n-2)

#define dstjBQF_implementPrintFunctions

#define dstjBQF_implementUseDoubleForCoeff

#ifdef dstjBQF_implementUseDoubleForCoeff
	typedef double TstjBQF_BiquadFloat;
#else
	#define dBQF_UseFloatMath
	typedef float TstjBQF_BiquadFloat;
#endif
// the biquad structure at the direct form II
typedef struct SstjBiquad {
    float a [3]; // numerator
	float b [2]; // denumerator
	float x [2];
	float y [2];
} TstjBiquad;

// a cascade of biquad filters
typedef struct SstjBiquadCascade {
	int				num;
	TstjBiquad *	pB;
} TstjBiquadCascade;

//! creates a cascade of biquad filters
int stjBQF_cascadeCreate (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) pointer to a struct to be filled
		int 				num		//!&lt; amount of filters
	);

//! deletes a cascade of biquad filters
void stjBQF_cascadeDelete (
		TstjBiquadCascade *	pBQC	//!&lt; (in) pointer to a struct to be freed
	);

//! convolut the input with the biquad filter cascade and generate the output (y = BQFc * x)
void stjBQF_cascadeConvolute (
		TstjBiquadCascade *	pBQC,	//!&lt; (in) the biquad cascade
		float * 			px,		//!&lt; (in) input signal vector
		unsigned int		xNum,	//!&lt; (in) amount of elements at the input vector
		float * 			py		//!&lt; (out) output signal vector (size must be more or equal to px)
	);

//! Initializes a element of the biquad cascade as high-pass(HP) filter
int stjBQF_cascadeInitHP (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biquad cascade
		unsigned int		index,	//!&lt; (in) the index of the filter witch should be used as HP
		float  				fs,		//!&lt; (in) sample frequency
		float  				fc		//!&lt; (in) cut off frequency
	);

//! initializes a element of the biquad cascade as low-pass(LP) filter
int stjBQF_cascadeInitLP (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biquad cascade
		unsigned int		index,	//!&lt; (in) the index of the filter witch should be used as LP
		float  				fs,		//!&lt; (in) sample frequency
		float  				fc		//!&lt; (in) cut off frequency
	);

//! initializes a element of the biquad cascade as peak boost/cut filter
int stjBQF_cascadeInitPeak (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biquad cascade
		unsigned int		index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  				fs,		//!&lt; (in) sample frequency
		float  				fc,		//!&lt; (in) center frequency
		float				g,		//!&lt; (in) gain
		float				q		//!&lt; (in) quality
	);

//! initializes a element of the biquad cascade as low frequency shelving filter
int stjBQF_cascadeInitLowFreqShelving (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biquad cascade
		unsigned int		index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  				fs,		//!&lt; (in) sample frequency
		float  				f,		//!&lt; (in) cut/boost frequency
		float				g		//!&lt; (in) gain
	);

//! initializes a element of the biquad cascade as high frequency shelving filter
int stjBQF_cascadeInitHighFreqShelving (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biquad cascade
		unsigned int		index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  				fs,		//!&lt; (in) sample frequency
		float  				f,		//!&lt; (in) cut/boost frequency
		float				g		//!&lt; (in) gain
	);

//! initializes a element of the biquad cascade from a array with the coefficients
void stjBQF_initFromCoefficents (
		TstjBiquadCascade *	pBQC,			//!&lt; (in/out) the biquad cascade
		int					index,			//!&lt; (in) the index of the filter witch should be used as peak filter
		float				numerator [3],	//!&lt; (in) n0 to n2
		float				denominator [3] //!&lt; (in) d0 to d2
	);

//! gets from an element of the biquad cascade the coefficients
void stjBQF_getNumAndDenom (
		TstjBiquadCascade *	pBQC,			//!&lt; (in/out) the biquad cascade
		int					index,			//!&lt; (in) the index of the filter witch should be used as peak filter
		float *				pNumerator,		//!&lt; (in) n0 to n2
		float *				pDenominator	//!&lt; (in) d0 to d2
	);

#ifdef dstjBQF_implementPrintFunctions

#include &lt;stdio.h&gt;

// a simple print function (n0, n1, n2, d0, d1, d2)
void stjBQF_printBiquad(TstjBiquadCascade *pBC, FILE * stream);
#endif

// =================================================
// a generic biquad filter lib based on the math.h
// part II - implementations
// =================================================

// math defines
#ifndef M_E
	#define M_E		2.7182818284590452354
#endif

#ifndef M_LOG2E
	#define M_LOG2E		1.4426950408889634074
#endif

#ifndef M_LOG10E
	#define M_LOG10E	0.43429448190325182765
#endif

#ifndef M_LN2
	#define M_LN2		0.69314718055994530942
#endif

#ifndef M_LN10
	#define M_LN10		2.30258509299404568402
#endif

#ifndef M_PI
	#define M_PI		3.14159265358979323846
#endif

#ifndef M_PI_2
	#define M_PI_2		1.57079632679489661923
#endif

#ifndef M_PI_4
	#define M_PI_4		0.78539816339744830962
#endif

#ifndef M_1_PI
	#define M_1_PI		0.31830988618379067154
#endif

#ifndef M_2_PI
	#define M_2_PI		0.63661977236758134308
#endif

#ifndef M_2_SQRTPI
	#define M_2_SQRTPI	1.12837916709551257390
#endif

#ifndef M_SQRT2
	#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT1_2
	#define M_SQRT1_2	0.70710678118654752440
#endif



#ifdef dstjBQF_UseFloatMath
	#define dStjBQFsqrt sqrtf
#else
	#define dStjBQFsqrt sqrt
#endif


TstjBQF_BiquadFloat _stjBQF_getK (float fs, float fc) {
#ifdef dstjBQF_UseFloatMath
	return tanf(M_PI*fc/fs);
#else
	return  tan(M_PI*fc/fs);
#endif
}

void _stjBQF_resetMemory(TstjBiquad * pBQ) {
	int i;
	for (i = 0; i &lt; 2; i++) {
		pBQ-&gt;x[i] = 0.0f;
		pBQ-&gt;y[i] = 0.0f;
	}
}

//! creates a cascade of biquad filters
int stjBQF_cascadeCreate (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) pointer to a struct to be filled
		int 					num		//!&lt; amount of filters
	) {
	int i, j;

	// alloc / realloc the biquad
	if (pBQC-&gt;num != num) {
		if (pBQC-&gt;pB) {
			free(pBQC-&gt;pB);
		}
		pBQC-&gt;pB = malloc (sizeof(TstjBiquad) * num);
		if (!pBQC-&gt;pB) {
			pBQC-&gt;num = 0;
			return -1;
		}
		pBQC-&gt;num = num;
	}

	// init data fields
	for (i = 0; i &lt; num; i++) {
		for (j =0; j &lt; 3; j++) pBQC-&gt;pB[i].a[j] = 0.0f;
		for (j =0; j &lt; 2; j++) pBQC-&gt;pB[i].b[j] = 0.0f;
		for (j =0; j &lt; 2; j++) pBQC-&gt;pB[i].x[j] = 0.0f;
		for (j =0; j &lt; 2; j++) pBQC-&gt;pB[i].y[j] = 0.0f;
	}
	return 0;
}

//! deletes a cascade of biquad filters
void stjBQF_cascadeDelete (
		TstjBiquadCascade *	pBQC	//!&lt; (in) pointer to a struct to be freed
	) {
	free (pBQC-&gt;pB);
	pBQC-&gt;pB = NULL;
	pBQC-&gt;num = 0;
}

//! convolut the input with the biquad filter cascade and generate the output (y = BQFc * x)
void stjBQF_cascadeConvolute (
		TstjBiquadCascade *	pBQC,	//!&lt; (in) the biqaud cascade
		float * 				px,		//!&lt; (in) input signal vector
		unsigned int			xNum,	//!&lt; (in) amount of elements at the input vector
		float * 				py		//!&lt; (out) output signal vector (size must be more or equal to px)
	) {
	int 		i, j;
	float 		y, x;
	TstjBiquad *pF;

	for (i = 0; i &lt; xNum; i++) {
		x = *px;
		pF = pBQC-&gt;pB;
		for (j = 0; j &lt; pBQC-&gt;num; j++) {
            y = pF-&gt;a[0] * x + pF-&gt;a[1] * pF-&gt;x[0] + pF-&gt;a[2]*pF-&gt;x[1] - pF-&gt;b[0] *pF-&gt;y[0] - pF-&gt;b[1]*pF-&gt;y[1];
            pF-&gt;x[1] = pF-&gt;x[0];
            pF-&gt;x[0] = x;
            pF-&gt;y[1] = pF-&gt;y[0];
            pF-&gt;y[0] = y;
			// output is input for the next filter
            x = y;
			pF++;
		}
		// save result to the output
		*py = y;
		px++;
		py++;
	}
}

//! initializes a element of the biquad cascade as high-pass(HP) filter
int stjBQF_cascadeInitHP (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int		index,	//!&lt; (in) the index of the filter witch should be used as HP
		float  				fs,		//!&lt; (in) sample frequency
		float  				fc		//!&lt; (in) cut off frequency
	) {
	TstjBQF_BiquadFloat K, denum;
	int i;

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}

	K = _stjBQF_getK(fs, fc);
    denum = 1.0f + M_SQRT2*K + K*K;
    pBQC-&gt;pB[index].a[0] = 1.0f;
    pBQC-&gt;pB[index].a[1] = -2.0f;
    pBQC-&gt;pB[index].a[2] = 1.0f;
    for (i = 0; i &lt; 3; i ++) {
    	pBQC-&gt;pB[index].a[i] /= denum;
    }

    pBQC-&gt;pB[index].b[0] = 2.0f * (K * K - 1.0f);
	pBQC-&gt;pB[index].b[1] = 1.0f - M_SQRT2 *K  + K * K;
    for (i = 0; i &lt; 2; i ++) {
    	pBQC-&gt;pB[index].b[i] /= denum;
    }

    _stjBQF_resetMemory(&amp;pBQC-&gt;pB[index]);
	return 0;
}

//! initializes a element of the biquad cascade as low-pass(LP) filter
int stjBQF_cascadeInitLP (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as LP
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc		//!&lt; (in) cut off frequency
	) {
	TstjBQF_BiquadFloat K, denum;
	int i;

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}

	K = _stjBQF_getK(fs, fc);

    denum = 1.0f + M_SQRT2*K + K*K;
    pBQC-&gt;pB[index].a[0] = K * K;
    pBQC-&gt;pB[index].a[1] = 2.0f * K * K;
    pBQC-&gt;pB[index].a[2] = K * K;
    for (i = 0; i &lt; 3; i ++) {
    	pBQC-&gt;pB[index].a[i] /= denum;
    }

    pBQC-&gt;pB[index].b[0] = 2.0f * (K * K - 1.0f);
    pBQC-&gt;pB[index].b[1] = 1.0f - M_SQRT2 *K  + K * K;
    for (i = 0; i &lt; 2; i ++) {
    	pBQC-&gt;pB[index].b[i] /= denum;
    }

	_stjBQF_resetMemory(&amp;pBQC-&gt;pB[index]);

	return 0;
}

//! initializes a element of the biquad cascade as peak boost/cut filter
int stjBQF_cascadeInitPeak (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc,		//!&lt; (in) center frequency
		float					g,		//!&lt; (in) gain
		float					q		//!&lt; (in) quality
	) {
	TstjBQF_BiquadFloat K, V0, denum;
	int i;

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}

	K = _stjBQF_getK(fs, fc);

	if (g &gt; 0.0f) {
		V0 = (TstjBQF_BiquadFloat) g;
		denum = 1.0f + 1.0f / q * K + K * K;
		pBQC-&gt;pB[index].a[0] = 1.0f + V0 / q * K + K * K;
		pBQC-&gt;pB[index].a[1] = 2.0f * (K * K - 1.0f);
		pBQC-&gt;pB[index].a[2] = 1.0f - V0 / q * K + K * K;
	    for (i = 0; i &lt; 3; i ++) {
	    	pBQC-&gt;pB[index].a[i] /= denum;
	    }

		pBQC-&gt;pB[index].b[0] = 2.0f * (K * K - 1.0f);
		pBQC-&gt;pB[index].b[1] = 1.0f - 1.0f / q * K  + K * K;
	    for (i = 0; i &lt; 2; i ++) {
	    	pBQC-&gt;pB[index].b[i] /= denum;
	    }

	} else {
		V0 = -(TstjBQF_BiquadFloat)g;
		denum = 1.0f + V0 / q * K + K * K;
		pBQC-&gt;pB[index].a[0] = 1.0f +  1.0 / q * K + K * K;
		pBQC-&gt;pB[index].a[1] = 2.0f * (K * K - 1.0f);
		pBQC-&gt;pB[index].a[2] = 1.0f - 1.0f / q * K + K * K;
	    for (i = 0; i &lt; 3; i ++) {
	    	pBQC-&gt;pB[index].a[i] /= denum;
	    }

		pBQC-&gt;pB[index].b[0] = 2.0f * ( K * K - 1.0f);
		pBQC-&gt;pB[index].b[1] = 1.0f - V0 / q * K  + K * K;
	    for (i = 0; i &lt; 2; i ++) {
	    	pBQC-&gt;pB[index].b[i] /= denum;
	    }
	}
	_stjBQF_resetMemory(&amp;pBQC-&gt;pB[index]);
	return 0;
}

//! initializes a element of the biquad cascade as low frequency shelving filter
int stjBQF_cascadeInitLowFreqShelving (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					f,		//!&lt; (in) cut/boost frequency
		float					g		//!&lt; (in) gain
	) {
	TstjBQF_BiquadFloat K, V0, denum;
	int i;

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}

	K = _stjBQF_getK(fs, f);
	if (g &gt; 0.0f) {
		V0 = (TstjBQF_BiquadFloat) g;
		denum = 1.0 + M_SQRT2* K + K * K;
		pBQC-&gt;pB[index].a[0] = 1.0f + dStjBQFsqrt(2.0f * V0) * K + V0 * K * K;
		pBQC-&gt;pB[index].a[1] = 2.0f * (V0 * K * K - 1.0f);
		pBQC-&gt;pB[index].a[2] = 1.0f - sqrt(2.0f * V0) * K + V0 * K * K;
	    for (i = 0; i &lt; 3; i ++) {
	    	pBQC-&gt;pB[index].a[i] /= denum;
	    }

		pBQC-&gt;pB[index].b[0] = 2.0f * (K * K - 1.0f);
		pBQC-&gt;pB[index].b[1] = 1.0f - M_SQRT2 * K  + K * K;
	    for (i = 0; i &lt; 2; i ++) {
	    	pBQC-&gt;pB[index].b[i] /= denum;
	    }

	} else {
		V0 = -(TstjBQF_BiquadFloat)g;
		denum = 1.0 + dStjBQFsqrt(2.0f * V0)* K + K * K;
		pBQC-&gt;pB[index].a[0] = 1.0f + M_SQRT2 * K + K * K;
		pBQC-&gt;pB[index].a[1] = 2.0f * (K * K - 1.0f);
		pBQC-&gt;pB[index].a[2] = 1.0f - M_SQRT2 * K + K * K;
	    for (i = 0; i &lt; 3; i ++) {
	    	pBQC-&gt;pB[index].a[i] /= denum;
	    }

		pBQC-&gt;pB[index].b[0] = 2.0f * (V0 * K * K - 1.0f);
		pBQC-&gt;pB[index].b[1] = 1.0f - dStjBQFsqrt(2.0f * V0) * K  + V0 * K * K;
	    for (i = 0; i &lt; 2; i ++) {
	    	pBQC-&gt;pB[index].b[i] /= denum;
	    }
	}

	_stjBQF_resetMemory(&amp;pBQC-&gt;pB[index]);
	return 0;
}

//! initializes a element of the biquad cascade as high frequency shelving filter
int stjBQF_cascadeInitHighFreqShelving (
		TstjBiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					f,		//!&lt; (in) cut/boost frequency
		float					g		//!&lt; (in) gain
	) {
	TstjBQF_BiquadFloat K, V0, denum;
	int i;

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}

	K = _stjBQF_getK(fs, f);
	if (g &gt; 0.0f) {
        V0 = (TstjBQF_BiquadFloat) g;
        denum = 1.0f + M_SQRT2* K + K * K;
        pBQC-&gt;pB[index].a[0] = V0 + dStjBQFsqrt(2.0f * V0) * K + K * K;
        pBQC-&gt;pB[index].a[1] = 2.0f * (K * K - V0);
        pBQC-&gt;pB[index].a[2] = V0 - dStjBQFsqrt(2.0f * V0) * K + K * K;
	    for (i = 0; i &lt; 3; i ++) {
	    	pBQC-&gt;pB[index].a[i] /= denum;
	    }

        pBQC-&gt;pB[index].b[0] = 2.0f * (K * K - 1.0f);
        pBQC-&gt;pB[index].b[1] = 1.0f - M_SQRT2 * K  + K * K;
	    for (i = 0; i &lt; 2; i ++) {
	    	pBQC-&gt;pB[index].b[i] /= denum;
	    }

	} else {
        V0 = -(TstjBQF_BiquadFloat)g;
        denum = V0 + dStjBQFsqrt(2.0f * V0)* K + K * K;
        pBQC-&gt;pB[index].a[0] = 1.0f + M_SQRT2 * K + K * K;
        pBQC-&gt;pB[index].a[1] = 2.0f * (K * K - 1.0);
        pBQC-&gt;pB[index].a[2] = 1.0f - M_SQRT2 * K + K * K;
	    for (i = 0; i &lt; 3; i ++) {
	    	pBQC-&gt;pB[index].a[i] /= denum;
	    }

        denum = 1.0f + dStjBQFsqrt(2.0f / V0)* K + K * K / V0;
        pBQC-&gt;pB[index].b[0] = 2.0f * ( K * K / V0 - 1.0f);
        pBQC-&gt;pB[index].b[1] = 1.0f - dStjBQFsqrt(2.0f / V0) * K  + K * K / V0;
	    for (i = 0; i &lt; 2; i ++) {
	    	pBQC-&gt;pB[index].b[i] /= denum;
	    }
	}
	_stjBQF_resetMemory(&amp;pBQC-&gt;pB[index]);
	return 0;

}
#ifdef dstjBQF_implementPrintFunctions

// a simple print function (n0, n1, n2, d0, d1, d2)
void stjBQF_printBiquad(TstjBiquadCascade *pBC, FILE * stream) {
	int i,j;

	fprintf(stream,&quot;BQC:\n&quot;);
	for (i = 0; i &lt; pBC-&gt;num; i++) {
		fprintf(stream,&quot;[%i]:\n&quot;,i);
		for (j = 0; j &lt; 3; j++) {
			fprintf(stream,&quot;\ta%i = %f\n&quot;,j,pBC-&gt;pB[i].a[j]);
		}
		fprintf(stream,&quot;\tb0 = 1.0\n&quot;);
		for (j = 0; j &lt; 2; j++) {
			fprintf(stream,&quot;\tb%i = %f\n&quot;,j+1,pBC-&gt;pB[i].b[j]);
		}
	}
	fflush(stream);
}

#endif
</Code><Code idCode="251">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TstjBiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = *((TAPgenericIntegerVector *) pParams[1].fp_pD)-&gt;pVal;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter fc descr: cut off frequency
	float fc = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;

	if (stjBQF_cascadeInitHP(pbqc, (unsigned int) index, fs, fc)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -100;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="252">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

// updates a variable the AP
int HALimpl_10_recvUpdate (void * pVarData, void * pMsgData) {
	uint32_t * pD = (uint32_t *) pMsgData;
	TstjBiquadCascade * pV =(TstjBiquadCascade *) pVarData;
	TstjBiquad * pE;
	int i,j, imax;


	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	if (gAPendianFlag != eAP_littleEndian) {
		APendianConversation32Bit(pD,eAP_littleEndian);
	}
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
		if (stjBQF_cascadeCreate(pV,imax)) {
			return -1;
		}
	}

	// 2. fill parameters
	pE = pV-&gt;pB;
	for (i = 0; i &lt; imax; i++) {
		// read a
		for (j = 0; j &lt; 3; j++) {
			pE-&gt;a[j] = *((float *)pD);
			pD++;
		}
		// read b
		for (j = 0; j &lt; 2; j++) {
			pE-&gt;b[j] = *((float *)pD);
			pD++;
		}
		// reset memory
		for (j = 0; j &lt; 2; j++) {
			pE-&gt;x[j] = 0.0f;
			pE-&gt;y[j] = 0.0f;
		}
		pE++;
	}
#ifdef dBQF_implementPrintFunctions
	fprintf(stdout,&quot;rx biquad:\n&quot;)
	BQF_PrintBiquad(pV,stdout);
	fflush(stdout);
#endif
	return 0;
}

// create a new variable
void * HALimpl_10_create (unsigned int numberOfElements) {
	TstjBiquadCascade * pBC = malloc(sizeof(TstjBiquadCascade));
	if (!pBC) return NULL;
	pBC-&gt;num = 0;
	pBC-&gt;pB = NULL;
	if (stjBQF_cascadeCreate(pBC, numberOfElements)) {
		free(pBC);
		return NULL;
	}
	return pBC;
}

// updates the vars at the other APs
int HALimpl_10_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	TstjBiquadCascade * pV =(TstjBiquadCascade *) pVarData;
	TstjBiquad * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;

	int32_t dataAmount;
	int32_t n;

	// calc amount of transmission bytes
	dataAmount = (int32_t) 1 + pV-&gt;num * 5;

	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);

	// 2 send vector elementwise

	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);

	// 2.2 send element
	pE = pV-&gt;pB;
	for (n = 0; n &lt; pV-&gt;num; n++) {
		pMD-&gt;pfkt_sendFloat32(pMD,3,pE-&gt;a);
		pMD-&gt;pfkt_sendFloat32(pMD,2,pE-&gt;b);
		// inc
		pE++;
	}
#ifdef dBQF_implementPrintFunctions
	fprintf(stdout,&quot;tx biquad:\n&quot;)
	stjBQF_printBiquad(pV,stdout);
	fflush(stdout);
#endif

	return 0;
}
// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	TstjBiquadCascade * pBC = (TstjBiquadCascade *) pVarData;
	if (pBC) {
		stjBQF_cascadeDelete(pBC);
		free (pBC);
	}
}</Code><Code idCode="253">// ===============================
// function implementation for initBiquadAsLP(var id = 101)
// description: inits a biquad filter as a low pass filter
// ===============================
void HALfunc_ID101_initBiquadAsLP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TstjBiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index =*((TAPgenericIntegerVector *) pParams[1].fp_pD)-&gt;pVal;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter fc descr: cut off frequency
	float fc = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;

	if (stjBQF_cascadeInitLP(pbqc, (unsigned int) index, fs, fc)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="254">// ===============================
// function implementation for initBiquadAsPeakFilter(var id = 102)
// description: inits a biquad filter as peak filter
// ===============================
void HALfunc_ID102_initBiquadAsPeakFilter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TstjBiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = *((TAPgenericIntegerVector *) pParams[1].fp_pD)-&gt;pVal;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter fc descr: center frequency
	float fc = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter q descr: quality
	float q = *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;
// parameter g descr: gain (not in dB)
	float g = *((TAPgenericRationalVector *) pParams[5].fp_pD)-&gt;pVal;

	if (stjBQF_cascadeInitPeak(pbqc, (unsigned int) index, fs, fc, g, q)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -102;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="255">// ===============================
// function implementation for initBiquadAsLowFreqShelvFilter(var id = 103)
// description: inits a biquad filter as low ferquency shelving filter
// ===============================
void HALfunc_ID103_initBiquadAsLowFreqShelvFilter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TstjBiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index =*((TAPgenericIntegerVector *) pParams[1].fp_pD)-&gt;pVal;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter f descr: cut/boost frequency
	float f = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter g descr: gain (not in dB)
	float g = *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;

	if (stjBQF_cascadeInitLowFreqShelving(pbqc, (unsigned int) index, fs, f, g)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -103;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="256">// ===============================
// function implementation for initBiquadAsHighFreqShelvFilter(var id = 104)
// description: inits a biquad filter as high ferquency shelving filter
// ===============================
void HALfunc_ID104_initBiquadAsHighFreqShelvFilter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TstjBiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = *((TAPgenericIntegerVector *) pParams[1].fp_pD)-&gt;pVal;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter f descr: cut/boost frequency
	float f = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter g descr: gain (not in dB)
	float g = *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;

	if (stjBQF_cascadeInitHighFreqShelving(pbqc, (unsigned int) index, fs, f, g)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -104;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="257">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================
void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * pXvec = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter bqa descr: biquad cascade
	TstjBiquadCascade * pbqc = (TstjBiquadCascade *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * pYvec = (TAPgenericRationalVector *) pParams[2].fp_pD;

	stjBQF_cascadeConvolute(pbqc,pXvec-&gt;pVal, pXvec-&gt;num, pYvec-&gt;pVal);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="258">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gALCdumpEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gALCdumpEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

TAP 		AP;

void * APIPthread(void * pArgs) {
	APInterpreterProcessState(AP.IP);

	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

#define dMyEndian (eAP_littleEndian)

int main()
{
	WSADATA			wsaData;
	pthread_t		IPthread;
	pthread_t		MSthread;



	int rc;

    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	printf(&quot;WSAStartup failed!&quot;);
    	return -1;
    }

	time_t t;

	time(&amp;t);
	srand((unsigned int)t);              /* Zufallsgenerator initialisieren */

	int uuid = rand();

	printf (&quot;AP uuid %i\n&quot;,uuid);

	// start up gtk+
	APgtk_start ();

	//rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	rc = APinit(&amp;AP,(TAPNodeID)uuid,NULL,0,1000,dMyEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
	if (rc) {
		printf(&quot;load programm failed with %i&quot;, rc);
		goto exit;
	}
#endif

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif

	rc = APInterpreterSetState (AP.IP,dMyEndian,eAPInterpreterState_run);

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	printf(&quot;press a key to exit&quot;);
	getch();

	rc = APInterpreterSetState (AP.IP,dMyEndian,eAPInterpreterState_halt);


exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}
</Code><Code idCode="259">// ===============================
// function implementation for assignConstRational(var id = 27)
// description: a = values
// ===============================
void HALfunc_ID27_assignConstRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter iv descr: rational vector
	TAPgenericRationalVector * piv = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter iStart descr: start index
	int32_t iStart = pParams[1].fp_integer;
// parameter num descr: amount of values used
	int32_t num = pParams[2].fp_integer;

	float * pSrc =(float *) &amp;pParams[3].fp_raw;

	APgenericRationalVector_assignConst (piv, (int)iStart, (int)num, pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="260">// ===============================
// function implementation for assignRational(var id = 28)
// description: a = b
// ===============================
void HALfunc_ID28_assignRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[1].fp_pD;

	APgenericRationalVector_assign(pa, pb);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="261">// ===============================
// function implementation for addRational(var id = 29)
// description: c = a + b
// ===============================
void HALfunc_ID29_addRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_add(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="262">// ===============================
// function implementation for subRational(var id = 30)
// description: c = a - b
// ===============================
void HALfunc_ID30_subRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_sub(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="263">// ===============================
// function implementation for mulRational(var id = 31)
// description: c = a * b
// ===============================
void HALfunc_ID31_mulRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_mul(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="264">// ===============================
// function implementation for divRational(var id = 32)
// description: c = a / b
// ===============================
void HALfunc_ID32_divRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_div(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="265">// ===============================
// function implementation for modRational(var id = 33)
// description: c = mod(a,b)
// ===============================
void HALfunc_ID33_modRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_mod(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="266">// ===============================
// function implementation for compareRationalLess(var id = 34)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID34_compareRationalLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;


};
</Code><Code idCode="267">// ===============================
// function implementation for compareRationalMore(var id = 35)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID35_compareRationalMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="268">// ===============================
// function implementation for compareRationalEqual(var id = 36)
// description: a == b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID36_compareRationalEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib) == 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="269">// ===============================
// function implementation for compareRationalNEqual(var id = 37)
// description: a != b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID37_compareRationalNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib)  != 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="270">// ===============================
// function implementation for compareRationalLessEqual(var id = 38)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID38_compareRationalLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib)  &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="271">// ===============================
// function implementation for compareRationalMoreEqual(var id = 39)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID39_compareRationalMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib)  &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="272">// ========================================
// dynamics processing (DynProc)
// ========================================
// Literature:
// Udo Zölzer, Digitale Audiosignal Verarbeitung, 3. Auflage
// Udo Zölzer, DAFX - Digital Audio Effects


// short:
// 		AT - attack time
//		RT - release time
//		TAV - average time
//		LT- limiter threshold
//		LS - limiter slope


// ---------------------------------
// helper
// ---------------------------------

float DynProc_calcSlope (
		float x1db, float y1db,
		float x2db, float y2db
	);

float DynProc_calcThreshold (
		float xDB,
		float xMax
	);

float DynProc_calcDB (float v);

float DynProc_calcValueFromDB (float dbVlaue, float xMax);

//! calc time parameter (AT, RT, TAV)
float DynProc_calcTimeParameter (
	float 		Ta, 	//!&lt; (in) sampling period
	float		t		//!&lt; (in) time parameter
	);

float DynProc_calcTimeFromTimeparameter (
		float Ta,
		float Tval
		);


// ---------------------------------
// RMS
// ---------------------------------
// RMS calc after Zölzer @p. 238

// structure for RMS calculation
typedef struct SDynProc_RMS {
	float	TAV;			//!&lt; time average
	float	oneMinusTAV;	//!&lt; 1-TAV
	float	x2Old;			//!&lt; x²(n-1)
} TDynProc_RMS;

//! init rms
void DynProc_InitRMS (
	TDynProc_RMS *	pRMS,	//!&lt; (in/out) structure to be filled
	float			TAV		//!&lt; (in) averaging time coefficient
	);

//! calc rms for one step (!rms = x²!)
float DynProc_calcRMS (
		TDynProc_RMS *	pRMS,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	);

// ---------------------------------
// Peak
// ---------------------------------
// Peak calc after Zölzer

// structure for Peak calculation
typedef struct SDynProc_Peak {
	float	AT;			//!&lt; attack time
	float	RT;			//!&lt; release time
	float	oneMinusAT;	//!&lt; 1 - AT
	float	oneMinusRT;	//!&lt; 1 - RT
	float	peak;		//!&lt; peak
} TDynProc_Peak;


//! init peak
void DynProc_InitPeak (
	TDynProc_Peak *	pPeak,	//!&lt; (in/out) structure to be filled
	float			AT,		//!&lt; (in) attack time
	float			RT		//!&lt; (in) release time
	);

//! calc peak for one step
float DynProc_calcPeak (
		TDynProc_Peak *	pPeak,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	);


// ---------------------------------
// smooth gain
// ---------------------------------
// smooth the gain value
// idea: use a hysteresis curve
//
// formula: g(n) = (1-k) * g(n - 1) + k * f(n)
//
// k = AT or k = RT
// k = (f(n) &gt; f(n-1)) ? AT : RT
// if new value is over the old value -&gt; attack
// else -&gt; release

// structure for attack and release time adjustment calculation
typedef struct SDynProc_SmoothG {
	float 			AT;		//!&lt; attack time
	float 			RT;		//!&lt; release time
	float			fOld;	//!&lt; f(n-1)
	float			gOld;	//!&lt; g(n-1)
} TDynProc_SmoothG;

//! init AT/RT
void DynProc_InitSmoothG (
	TDynProc_SmoothG *	pSG,	//!&lt; (in/out) structure to be filled
	float				AT,		//!&lt; (in) attack time
	float				RT		//!&lt; (in) release time
	);

//! init AT/RT
float DynProc_calcSmoothG (
	float 				fn,		//!&lt; (in) input
	TDynProc_SmoothG *	pSG	//!&lt; (in) structure to be filled
	);

// ---------------------------------
// limiter
// ---------------------------------
// LT - limiter treshold (where the limiter starts working)
// LS - limiter slope (how fast the limiter works)

// structure for dynamic range controler calculation
typedef struct SDynProc_Limiter {
	float 				LTlog;			//!&lt; limiter threshold LT
	float 				LS;				//!&lt; limiter slope LS
	TDynProc_Peak		peakDetector;	//!&lt; the peak detector
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay;			//!&lt; delay at the input - output lane
} TDynProc_Limiter;

//! init AT/RT
void DynProc_InitLimiter (
		TDynProc_Limiter *	pLim,		//!&lt; (in/out) structure to be filled
		float				peakAT,		//!&lt; (in) peak attack time
		float				peakRT,		//!&lt; (in) peak release time
		float				smoothAT,	//!&lt; (in) smoothing attack time
		float				smoothRT,	//!&lt; (in) smoothing release time
		float				LT,			//!&lt; (in) limiter threshold
		float				LS			//!&lt; (in) limiter slope
);

//! init AT/RT
float DynProc_calcLimiter (
		TDynProc_Limiter *	pLim,	//!&lt; (in) the limiter
		float 				x		//!&lt; (in) input signal
	);

// ---------------------------------
// compressor
// ---------------------------------
// CT - compressor treshold (where the compressor starts working)
// CS - compressor slope (how fast the compressor works)

// structure for dynamic range controller calculation
typedef struct SDynProc_Compressor {
	float 				CTlog;				//!&lt; compressor threshold
	float 				CSlog;				//!&lt; compressor slope
	TDynProc_RMS		RMS;			//!&lt; RMS unit
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay[2];		//!&lt; delay at the input - output lane
} TDynProc_Compressor;



//! init compressor
void DynProc_InitCompressor (
	TDynProc_Compressor *	pComp,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					CT,			//!&lt; (in) compressor treshold
	float					CS			//!&lt; (in) compressor slope
);

//! calc compressor
float DynProc_calcCompressor (
		TDynProc_Compressor *	pComp,	//!&lt; (in) the compressor
		float 					x		//!&lt; (in) input signal
	);

// ---------------------------------
// expander
// ---------------------------------
// ET - expander threshold (where the expander starts working)
// ES - expander slope (how fast the expander works)

// structure for dynamic range controller calculation
typedef struct SDynProc_Expander {
	float 				ETlog;		//!&lt; expander threshold log10 (ET)
	float 				ESlog;		//!&lt; expander slope log10 (ES)
	TDynProc_RMS		RMS;			//!&lt; RMS unit
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay[2];		//!&lt; delay at the input - output lane
} TDynProc_Expander;

//! init expander
void DynProc_InitExpander (
	TDynProc_Expander *	pExp,		//!&lt; (in/out) structure to be filled
	float				rmsTAV,		//!&lt; (in) rms time average coefficient
	float				smoothAT,	//!&lt; (in) smoothing attack time
	float				smoothRT,	//!&lt; (in) smoothing release time
	float				ET,			//!&lt; (in) expander treshold in dB
	float				ES			//!&lt; (in) expander slope in dB
);

//! calc expander
float DynProc_calcExpander (
		TDynProc_Expander *	pExp,	//!&lt; (in) the expander
		float 					x		//!&lt; (in) input signal
	);

// ---------------------------------
// noisegate
// ---------------------------------
// NT - noisegate threshold (till the noisegate works)

// structure for dynamic range controller calculation
typedef struct SDynProc_Noisegate {
	float 				NTlog;			//!&lt; noisegate threshold log10 (NT)
	float 				NSlog;			//!&lt; noisegate slope log10 (NS)
	TDynProc_RMS		RMS;			//!&lt; RMS unit
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay[2];		//!&lt; delay at the input - output lane
} TDynProc_Noisegate;

//! init noisegate
void DynProc_InitNoisegate (
	TDynProc_Noisegate *	pNG,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					NT,	//!&lt; (in) noisegate threshold
	float					NS	//!&lt; (in) noisegate slope
);

//! calc noisegate
float DynProc_calcNoisegate (
		TDynProc_Noisegate *	pNG,	//!&lt; (in) the noisegate
		float 					x		//!&lt; (in) input signal
	);

// ========================================
// dynamics processing (DynProc)
// ========================================
// Literature:
// Udo Zölzer, Digitale Audiosignal Verarbeitung, 3. Auflage
// Udo Zölzer, DAFX - Digital Audio Effects


// short:
// 		AT - attack time
//		RT - release time
//		TAV - average time
//		LT- limiter threshold
//		LS - limiter slope

// it works in that way
// Y(n) = G(n) * x(n -D)
// g = {noisegate, expander, compressor, limiter}
// D - delay m - samples


// helper

float DynProc_calcSlope (
		float x1db, float y1db,
		float x2db, float y2db
	) {
	// y = m * x + n; P1 &amp; P2
	// m = (P2y - P1y) / (P2x - P1x)
	return (y2db - y1db) / (x2db - x1db);
}

float DynProc_calcThreshold (
		float xDB,
		float xMax
	) {
	return xMax * powf (10.0f, xDB / 20.0f);
}

float DynProc_calcDB (float x) {
	return 10.0f * logf(x*x); // = 10.0 * log(x²)  = 20.0f * log(x)
}

float DynProc_calcValueFromDB (float dbVlaue, float xMax) {
	return powf(10.0f, dbVlaue / 20.0) * xMax;
}


float DynProc_calcCompressionFactor (float slope) {
	return 1.f / (1.f- slope);
}

//! calc time parameter (AT, RT, TAV)
float DynProc_calcTimeParameter (
	float 		Ta, 	//!&lt; (in) sampling period
	float		t		//!&lt; (in) time parameter
	) {
	// formular and 2.2 explained at &quot;Digitale Audio Signalverarbeitung&quot; @p.237
	return (1.0f - expf((-2.2f * Ta) / t));
}

float DynProc_calcTimeFromTimeparameter (
		float Ta,
		float Tval
		) {
	return (-2.2f * Ta)/ (logf(1-Tval));
}

// ---------------------------------
// RMS
// ---------------------------------
// RMS calc after Zölzer @p. 238

//! init rms
void DynProc_InitRMS (
	TDynProc_RMS *	pRMS,	//!&lt; (in/out) structure to be filled
	float			TAV		//!&lt; (in) averaging time coefficient
	) {
	pRMS-&gt;TAV = TAV;
	pRMS-&gt;oneMinusTAV = 1.0f - TAV;
	pRMS-&gt;x2Old = 0.0f;
}

//! calc rms for one step
float DynProc_calcRMS (
		TDynProc_RMS *	pRMS,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	) {
	float x2RMS;
	// calc forward
	x2RMS = pRMS-&gt;oneMinusTAV * pRMS-&gt;x2Old + pRMS-&gt;TAV * x * x;
	// calc backward
	pRMS-&gt;x2Old = x2RMS;
	return x2RMS;
}

// ---------------------------------
// Peak
// ---------------------------------
// Peak calc after Zölzer

//! init peak
void DynProc_InitPeak (
	TDynProc_Peak *	pPeak,	//!&lt; (in/out) structure to be filled
	float			AT,		//!&lt; (in) attack time
	float			RT		//!&lt; (in) release time
	) {
	pPeak-&gt;AT = AT;
	pPeak-&gt;RT = RT;
	pPeak-&gt;oneMinusAT = 1.0f - AT;
	pPeak-&gt;oneMinusRT = 1.0f - RT;
	pPeak-&gt;peak = 0.0f;
}

//! calc peak for one step
float DynProc_calcPeak (
		TDynProc_Peak *	pPeak,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	) {

	// formula from Zölzer @p. 235 wrong!
	// |x(n)| &gt; xPeak(n-1) -&gt; attack
	// |x(n)| &lt;= xPeak(n-1) -&gt; release
	// @attack: xpeak(n) = (1-AT) * xpeak(n-1) + AT * |x(n)|
	// @release: xpeak(n) = (1-RT) * peak(n-1)
	float a;
	a = fabsf(x);

	if (a &gt; pPeak-&gt;peak) {
		pPeak-&gt;peak = pPeak-&gt;oneMinusAT * (pPeak-&gt;peak) + pPeak-&gt;AT * a;
	} else {
		pPeak-&gt;peak = pPeak-&gt;oneMinusRT * (pPeak-&gt;peak) + pPeak-&gt;RT * a;
	}
	return pPeak-&gt;peak;
}

// ---------------------------------
// smooth gain
// ---------------------------------
// smooth the gain value
// idea: use a hysteresis curve
//
// formula: g(n) = (1-k) * g(n - 1) + k * f(n)
//
// k = AT or k = RT
// k = (f(n) &gt; f(n-1)) ? AT : RT
// if new value is over the old value -&gt; attack
// else -&gt; release

//! init AT/RT
void DynProc_InitSmoothG (
	TDynProc_SmoothG *	pSG,	//!&lt; (in/out) structure to be filled
	float				AT,		//!&lt; (in) attack time
	float				RT		//!&lt; (in) release time
	) {
	pSG-&gt;AT = AT;
	pSG-&gt;RT = RT;
	pSG-&gt;fOld = 0.0f;
	pSG-&gt;gOld = 0.0f;
}

//! init AT/RT
float DynProc_calcSmoothG (
	float 				fn,		//!&lt; (in) input
	TDynProc_SmoothG *	pSG	//!&lt; (in) structure to be filled
	) {
	float k;
	float gn;

	// attack or release
	k = (fn &gt; pSG-&gt;fOld) ? pSG-&gt;AT : pSG-&gt;RT;

	// calc gain
	gn = (1.0f-k) * pSG-&gt;gOld + k * fn;
	pSG-&gt;gOld = gn;
	pSG-&gt;fOld = fn;
	return gn;
}

// ---------------------------------
// limiter
// ---------------------------------
// LT - limiter treshold (where the limiter starts working)
// LS - limiter slope (how fast the limiter works)

//! init AT/RT
void DynProc_InitLimiter (
	TDynProc_Limiter *	pLim,		//!&lt; (in/out) structure to be filled
	float				peakAT,		//!&lt; (in) peak attack time
	float				peakRT,		//!&lt; (in) peak release time
	float				smoothAT,	//!&lt; (in) smoothing attack time
	float				smoothRT,	//!&lt; (in) smoothing release time
	float				LT,			//!&lt; (in) limiter threshold
	float				LS			//!&lt; (in) limiter slope
) {
	DynProc_InitPeak(&amp;(pLim-&gt;peakDetector),peakAT,peakRT);
	DynProc_InitSmoothG(&amp;(pLim-&gt;SmoothG),smoothAT,smoothRT);
	pLim-&gt;LTlog = log10f(LT);
	pLim-&gt;LS = LS;
	pLim-&gt;delay = 0.0f;
}

//! init AT/RT
float DynProc_calcLimiter (
		TDynProc_Limiter *	pLim,	//!&lt; (in) the limiter
		float 				x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pLim-&gt;delay;
	// 1.1.) recalc delay
	pLim-&gt;delay = x;

	// 2.) calc limiter gain
	// 2.1) peak detect
	g = DynProc_calcPeak(&amp;(pLim-&gt;peakDetector),x);
	g = log10f(g);
	// 2.3. if we are over the threshold
	if (g &gt; pLim-&gt;LTlog) {
		g = -pLim-&gt;LS * (g - pLim-&gt;LTlog);
	} else {
		g = 0.0;
	}
	g = powf (10.0f, g);
	g = DynProc_calcSmoothG(g, &amp;(pLim-&gt;SmoothG));
	// 3. calc result of delay mul compressor gain
	y *= g;

	// AND return
	return y;
}

// ---------------------------------
// compressor
// ---------------------------------
// CT - compressor treshold (where the compressor starts working)
// CS - compressor slope (how fast the compressor works)

//! init compressor
void DynProc_InitCompressor (
	TDynProc_Compressor *	pComp,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					CT,			//!&lt; (in) compressor treshold
	float					CS			//!&lt; (in) compressor slope
) {
	DynProc_InitRMS(&amp;(pComp-&gt;RMS),rmsTAV);
	DynProc_InitSmoothG(&amp;(pComp-&gt;SmoothG),smoothAT,smoothRT);
	pComp-&gt;CTlog = DynProc_calcDB(CT);
	pComp-&gt;CSlog = -CS;
	pComp-&gt;delay[0] = 0.0f;
	pComp-&gt;delay[1] = 0.0f;
}

//! calc compressor
float DynProc_calcCompressor (
		TDynProc_Compressor *	pComp,	//!&lt; (in) the compressor
		float 					x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pComp-&gt;delay[1];
	// 1.1.) recalc delay
	pComp-&gt;delay[1] = pComp-&gt;delay[0];
	pComp-&gt;delay[0] = x;

	// 2.) calc compressor gain
	// 2.1) peak detect
	g = DynProc_calcRMS(&amp;(pComp-&gt;RMS),x);
	// 2.2) lin/log
	g = log10f(g);
	g *= 10.0f; // rms = x² - &gt; log(x²) = 2 log(x²) -&gt; Xdb = 20*log(x) -&gt; 20 / 2 = 10

	// 2.3. if we are over the threshold
	if (g &gt; pComp-&gt;CTlog) {
		g = pComp-&gt;CSlog*(g-pComp-&gt;CTlog) / 20.0f;
	} else {
		g = 0.0f;
	}
	g = powf (10.0f, g);
	g = DynProc_calcSmoothG(g, &amp;(pComp-&gt;SmoothG));
	// 3. calc result of delay mul compressor gain
	y *= g;

	// AND return
	return y;
}


// ---------------------------------
// expander
// ---------------------------------
// ET - expander threshold (where the expander starts working)
// ES - expander slope (how fast the expander works)

//! init expander
void DynProc_InitExpander (
	TDynProc_Expander *	pExp,		//!&lt; (in/out) structure to be filled
	float				rmsTAV,		//!&lt; (in) rms time average coefficient
	float				smoothAT,	//!&lt; (in) smoothing attack time
	float				smoothRT,	//!&lt; (in) smoothing release time
	float				ET,			//!&lt; (in) expander treshold in dB
	float				ES			//!&lt; (in) expander slope in dB
) {
	DynProc_InitRMS(&amp;(pExp-&gt;RMS),rmsTAV);
	DynProc_InitSmoothG(&amp;(pExp-&gt;SmoothG),smoothAT,smoothRT);
	pExp-&gt;ETlog = DynProc_calcDB(ET);
	pExp-&gt;ESlog = ES;
	pExp-&gt;delay[0] = 0.0f;
	pExp-&gt;delay[1] = 0.0f;
}

//! calc expander
float DynProc_calcExpander (
		TDynProc_Expander *		pExp,	//!&lt; (in) the expander
		float 					x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pExp-&gt;delay[1];
	// 1.1.) recalc delay
	pExp-&gt;delay[1] = pExp-&gt;delay[0];
	pExp-&gt;delay[0] = x;

	// 2.) calc compressor gain
	// 2.1) peak detect
	g = DynProc_calcRMS(&amp;(pExp-&gt;RMS),x);
	// 2.2) lin/log
	g = log10f(g);
	g *= 10.0f; // rms = x² - &gt; log(x²) = 2 log(x²) -&gt; Xdb = 20*log(x) -&gt; 20 / 2 = 10

	// 2.3. if we are over the threshold
	if (g &gt; pExp-&gt;ETlog) {
		g = pExp-&gt;ESlog*(pExp-&gt;ETlog-g) / 20.0;
	} else {
		g = 0.0f;
	}
	g = powf (10.0f, g);
	g = DynProc_calcSmoothG(g, &amp;(pExp-&gt;SmoothG));
	// 3. calc result of delay mul compressor gain
	y *= g;

	// AND return
	return y;
}


// ---------------------------------
// noisegate
// ---------------------------------
// NT - noisegate threshold (till the noisegate works)

//! init noisegate
void DynProc_InitNoisegate (
	TDynProc_Noisegate *	pNG,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					NT,			//!&lt; (in) noisegate threshold
	float					NS			//!&lt; (in) noisegate slope
) {
	DynProc_InitRMS(&amp;(pNG-&gt;RMS),rmsTAV);
	DynProc_InitSmoothG(&amp;(pNG-&gt;SmoothG),smoothAT,smoothRT);
	pNG-&gt;NTlog = DynProc_calcDB(NT);
	pNG-&gt;NSlog = NS;
	pNG-&gt;delay[0] = 0.0f;
	pNG-&gt;delay[1] = 0.0f;
}

//! calc noisegate
float DynProc_calcNoisegate (
		TDynProc_Noisegate *	pNG,	//!&lt; (in) the noisegate
		float 					x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pNG-&gt;delay[1];
	// 1.1.) recalc delay
	pNG-&gt;delay[1] = pNG-&gt;delay[0];
	pNG-&gt;delay[0] = x;

	// 2.) calc noisegate gain
	// 2.1) rms detect
	g = DynProc_calcRMS(&amp;(pNG-&gt;RMS), x);
	// 2.2) lin/log
	g = log10f(g);
	g *= 10.0f; // rms = x² - &gt; log(x²) = 2 log(x²) -&gt; Xdb = 20*log(x) -&gt; 20 / 2 = 10

	// 2.3. if we are over the threshold
	if (g &gt; pNG-&gt;NTlog) {
		// calc linear function at log space
		g = pNG-&gt;NSlog*(g-pNG-&gt;NTlog) / 20.0;
		g = powf(10.f, g);
	} else {
		g = 0.0f;
	}
	// and smooth
	g = DynProc_calcSmoothG(g, &amp;(pNG-&gt;SmoothG));
	// 3. calc result of delay mul noisegate gain
	y *= g;

	// AND return
	return y;
}</Code><Code idCode="273">// ===============================
// function implementation for initNoisegate(var id = 111)
// description: initialize a noisegate
// ===============================
void HALfunc_ID111_initNoisegate(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter ng descr: noisegate
	TDynProc_Noisegate * pNG = (TDynProc_Noisegate *) pParams[0].fp_pD;
// parameter rmsTAV descr: time average value for the rms
	float rmsTAV = pParams[1].fp_rational;
// parameter AT descr: attack value for the smoothing
	float AT = pParams[2].fp_rational;
// parameter RT descr: release value for the smoothing
	float RT = pParams[3].fp_rational;
// parameter NT descr: noise cut off threshold
	float NT = pParams[4].fp_rational;
// parameter NS descr: slope
	float NS = pParams[5].fp_rational;

	DynProc_InitNoisegate(pNG, rmsTAV, AT, RT, NT, NS);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="274">// ===============================
// function implementation for initExpander(var id = 112)
// description: initialize a expander
// ===============================
void HALfunc_ID112_initExpander(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter exp descr: expander
	TDynProc_Expander * pExp = (TDynProc_Expander *) pParams[0].fp_pD;
// parameter rmsTAV descr: time average value for the rms
	float rmsTAV = pParams[1].fp_rational;
// parameter AT descr: attack value for the smoothing
	float AT = pParams[2].fp_rational;
// parameter RT descr: release value for the smoothing
	float RT = pParams[3].fp_rational;
// parameter ET descr: expander threshold
	float ET = pParams[4].fp_rational;
// parameter ES descr: slope
	float ES = pParams[5].fp_rational;

	DynProc_InitExpander(pExp, rmsTAV, AT, RT, ET, ES);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="275">// ===============================
// function implementation for initCompressor(var id = 113)
// description: initialize a compressor
// ===============================
void HALfunc_ID113_initCompressor(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter comp descr: compressor
	TDynProc_Compressor * pComp = (TDynProc_Compressor *) pParams[0].fp_pD;
// parameter rmsTAV descr: time average value for the rms
	float rmsTAV = pParams[1].fp_rational;
// parameter AT descr: attack value for the smoothing
	float AT = pParams[2].fp_rational;
// parameter RT descr: release value for the smoothing
	float RT = pParams[3].fp_rational;
// parameter CT descr: compressor threshold
	float CT = pParams[4].fp_rational;
// parameter CS descr: slope
	float CS = pParams[5].fp_rational;

	DynProc_InitCompressor(pComp, rmsTAV, AT, RT, CT, CS);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="276">// ===============================
// function implementation for initLimiter(var id = 114)
// description: initialize a limiter
// ===============================
void HALfunc_ID114_initLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter lim descr: limiter
	TDynProc_Limiter * pLim = (TDynProc_Limiter *) pParams[0].fp_pD;
// parameter ATpeak descr: attack value for the peak detection
	float ATpeak = pParams[1].fp_rational;
// parameter RTpeak descr: release value for the peak detection
	float RTpeak = pParams[2].fp_rational;
// parameter ATsmooth descr: attack value for the smoothing
	float ATsmooth = pParams[3].fp_rational;
// parameter RTsmooth descr: release value for the smoothing
	float RTsmooth = pParams[4].fp_rational;
// parameter LT descr: limiter threshold
	float LT = pParams[5].fp_rational;
// parameter LS descr: slope
	float LS = pParams[6].fp_rational;

	DynProc_InitLimiter(pLim, ATpeak, RTpeak, ATsmooth, RTsmooth, LT, LS);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="277">// ===============================
// function implementation for calcNoisegate(var id = 115)
// description: sends a stream of samples through a noisegate
// ===============================
void HALfunc_ID115_calcNoisegate(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter ng descr: noisegate
	TDynProc_Noisegate * pNG = (TDynProc_Noisegate *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcNoisegate(pNG, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="278">// ===============================
// function implementation for calcExpander(var id = 116)
// description: sends a stream of samples through a expander
// ===============================
void HALfunc_ID116_calcExpander(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter exp descr: expander
	TDynProc_Expander * pExp = (TDynProc_Expander *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcExpander(pExp, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="279">// ===============================
// function implementation for calcCompressor(var id = 117)
// description: sends a stream of samples through a compressor
// ===============================
void HALfunc_ID117_calcCompressor(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter comp descr: compressor
	TDynProc_Compressor * pComp = (TDynProc_Compressor *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcCompressor(pComp, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="280">// ===============================
// function implementation for calcLimiter(var id = 118)
// description: sends a stream of samples through a limiter
// ===============================
void HALfunc_ID118_calcLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter lim descr: limiter
	TDynProc_Limiter * pLim = (TDynProc_Limiter *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcLimiter(pLim, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="281">// ===============================
// variable implementation for a noisegate(var id = 11)
// ===============================

// updates a variable the AP
int HALimpl_11_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_11_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Noisegate));
}
// updates the vars at the other APs
int HALimpl_11_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_11_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_11_delete (void * pVarData) {
	TDynProc_Noisegate * pNG = (TDynProc_Noisegate *) pVarData;
	free (pNG);
}
</Code><Code idCode="282">// ===============================
// variable implementation for a expander(var id = 12)
// ===============================

// updates a variable the AP
int HALimpl_12_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_12_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Expander));

}
// updates the vars at the other APs
int HALimpl_12_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_12_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_12_delete (void * pVarData) {
	TDynProc_Expander * pExp = (TDynProc_Expander *) pVarData;
	free (pExp);

}
</Code><Code idCode="283">// ===============================
// variable implementation for a compressor(var id = 13)
// ===============================

// updates a variable the AP
int HALimpl_13_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_13_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Compressor));
}
// updates the vars at the other APs
int HALimpl_13_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_13_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_13_delete (void * pVarData) {
	TDynProc_Compressor * pCmp = (TDynProc_Compressor *) pVarData;
	free (pCmp);
}
</Code><Code idCode="284">// ===============================
// variable implementation for a limiter(var id = 14)
// ===============================

// updates a variable the AP
int HALimpl_14_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_14_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Limiter));
}
// updates the vars at the other APs
int HALimpl_14_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_14_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_14_delete (void * pVarData) {
	TDynProc_Limiter * pLim = (TDynProc_Limiter *) pVarData;
	free (pLim);
}
</Code><Code idCode="285">// ===============================
// function implementation for concatStrings(var id = 7)
// description: concat two strings
// ===============================
void HALfunc_ID7_concatStrings(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s1 descr: the string at its end the other string is concated
	TAPstringVector * s1 = (TAPstringVector *) pParams[0].fp_pD;
// parameter i1 descr: index of the string 1
	int i1 = (int) pParams[1].fp_integer;
// parameter s2 descr: the concat string
	TAPstringVector * s2 = (TAPstringVector *) pParams[2].fp_pD;
// parameter i2 descr: index of the string 2
	int i2 = (int) pParams[3].fp_integer;

	if (APstringVector_concat(s1,i1,s2,i2)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="286">// ===============================
// function implementation for rationalToString(var id = 8)
// description: converts a rational to a string
// ===============================
void HALfunc_ID8_rationalToString(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * s = (TAPstringVector *) pParams[0].fp_pD;
// parameter sIndex descr: index of the string at the array
	int sIndex = (int) pParams[1].fp_integer;
// parameter r descr: rational vector
	TAPgenericRationalVector * r = (TAPgenericRationalVector *) pParams[2].fp_pD;
// parameter rIndx descr: rational vector index
	int rIndx = (int) pParams[3].fp_integer;

	APstringVector_printFloat(s, sIndex, r-&gt;pVal[rIndx]);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="287">// ===============================
// function implementation for integerToString(var id = 9)
// description: converts an integer to a string
// ===============================
void HALfunc_ID9_integerToString(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * s = (TAPstringVector *) pParams[0].fp_pD;
// parameter sIndex descr: index of the string at the array
	int sIndex = (int) pParams[1].fp_integer;
// parameter i descr: integer vector
	TAPgenericIntegerVector * i = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter iIndex descr: integer vector indx
	int iIndex = (int) pParams[3].fp_integer;

	APstringVector_printInt(s, sIndex, i-&gt;pVal[iIndex]);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="288">// ===============================
// function implementation for assignString(var id = 10)
// description: assigns a string to an other
// ===============================
void HALfunc_ID10_assignString(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s1 descr: the string at its end the other string is concated
	TAPstringVector * s1 = (TAPstringVector *) pParams[0].fp_pD;
// parameter i1 descr: index of the string 1
	int i1 = (int) pParams[1].fp_integer;
// parameter s2 descr: the concat string
	TAPstringVector * s2 = (TAPstringVector *) pParams[2].fp_pD;
// parameter i2 descr: index of the string 2
	int i2 = (int) pParams[3].fp_integer;

	if (APstringVector_assign(s1,i1,s2,i2)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}

};
</Code><Code idCode="289">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// updates a variable the AP
int HALimpl_1_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
return NULL;
}
// updates the vars at the other APs
int HALimpl_1_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {

}
</Code><Code idCode="290">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// updates a variable the AP
int HALimpl_1_recvUpdate ( void * pVarData, void * pMsgData ) {
  
}
// create a new variable
void * HALimpl_1_create ( unsigned int numberOfElements ) {
 return NULL; 
}
// updates the vars at the other APs
int HALimpl_1_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
 
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
    int n, N;
    
    int32_t dataAmount = (int32_t) 1 + myDataElements;
    
    // 1 send header
    pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
    
    
    // 2 send vector elementwise
    N = elements at the vector;
    pVD = pVvecD-&gt; first element
    // 2.1 send amount of elements at the vector
    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pVvecD-&gt;element amount);
    // 2.2 send element
    for (n = 0; n &lt; N; n++) {    
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;value);

        pVD++;
    }
    return 0; 
}
// decode data for the HAL functions
void * HALimpl_1_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_1_delete ( void * pVarData ) {
  
}
</Code><Code idCode="291">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
  
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 return NULL; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
 
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
    int n, N;
    
    int32_t dataAmount = (int32_t) 1 + myDataElements;
    
    // 1 send header
    pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
    
    
    // 2 send vector elementwise
    N = elements at the vector;
    pVD = pVvecD-&gt; first element
    // 2.1 send amount of elements at the vector
    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pVvecD-&gt;element amount);
    // 2.2 send element
    for (n = 0; n &lt; N; n++) {    
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b2);

        pVD++;
    }
    return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
  
}
</Code><Code idCode="292">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function template
    uint32_t * pD = (uint32_t *) pMsgData;
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    int i,imax 
    
    // at the first possion at the message is the global var index
    pD++; // skip it (it's the varindex)
    // and now we are at amount of values
    APendianConversation32Bit(pD,eAP_littleEndian);
    imax = (int) *((int32_t *)pD);
    int i;

    resize your vector here
    pD++;

    pVD = pVvecD-&gt;first element
    
    for (i = 0; i &lt; imax; i++) {
		pVD-&gt;a0=*((float *)pD);
		pD++;
		pVD-&gt;a1=*((float *)pD);
		pD++;
		pVD-&gt;a2=*((float *)pD);
		pD++;
		pVD-&gt;b0=*((float *)pD);
		pD++;
		pVD-&gt;b1=*((float *)pD);
		pD++;
		pVD-&gt;b2=*((float *)pD);
		pD++;
        pVD++;
    }

    return 0; 
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 return NULL; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
     // tx function template
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
    int n, N;
    
    int32_t dataAmount = (int32_t) 1 + total amount of data except length of the vector;
    
    // 1 send header
    pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
    
    
    // 2 send vector elementwise
    N = elements at the vector;
    pVD = pVvecD-&gt; first element
    // 2.1 send amount of elements at the vector
    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pVvecD-&gt;element amount);
    // 2.2 send element
    for (n = 0; n &lt; N; n++) {
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b2);
        pVD++;
    }
    return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
  
}
</Code><Code idCode="293">// ===============================
// variable implementation for sixxx (varID=66)
// ===============================

// element structure for sixxx
typedef struct SApVar_ele_sixxx {
	float * pA_dataL;// the data list (array)
	int32_t num_dataL;// amount of dataL elements
	float keffi;//koefficent
	int32_t indx;//index
} TApVar_ele_sixxx;

// vector structure for sixxx
typedef struct SApVar_vec_sixxx {
    TApVar_ele_sixxx * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_sixxx;


// updates a variable the AP
int HALimpl_66_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for sixxx
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_sixxx * pV =(TApVar_vec_sixxx *) pVarData;
	TApVar_ele_sixxx * pE;
	int i, imax;
	int32_t n, nmax;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a sixxx vector
		if (pV) {
		    if (pV-&gt;pFE) {
		        // go over every element and delete the array paramters
				pE = pV-&gt;pFE;
				for (i=0; i&lt;pV-&gt;num;i++) { 
					// delete parameter dataL
					if (pE-&gt;pA_dataL) {
					    free(pE-&gt;pA_dataL);
					    pE-&gt;pA_dataL=NULL;
					    pE-&gt;num_dataL=0;
					}
					
					
				    pE++;
				}
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for sixxx
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_sixxx)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    // rx dataL
		APendianConversation32Bit(pD,eAP_littleEndian);
		nmax = *((int32_t *) pD);
		// resize parameter
		if (nmax != pE-&gt;num_dataL) {
		    if (pE-&gt;pA_dataL) free(pE-&gt;pA_dataL);
		    pE-&gt;pA_dataL = malloc(sizeof(float)*nmax);
		    if (!pE-&gt;pA_dataL) return -2;
		    pE-&gt;num_dataL = nmax;
		}
		
		pD++;
		for (n = 0; n &lt; pE-&gt;num_dataL; n++) {
		    // no endian conversation
		    pE-&gt;pA_dataL[n]=*((float *)pD);
		    pD++;
		}
		// rx keffi
		// no endian conversation
		pE-&gt;keffi=*((float *)pD);
		pD++;
		// rx indx
		APendianConversation32Bit(pD,eAP_littleEndian);
		pE-&gt;indx=*((int32_t *)pD);
		pD++;
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_66_create ( unsigned int numberOfElements ) {
 // create a new sixxx vector
	pV = malloc(sizeof(TApVar_vec_sixxx));
	if (!pV) {
	    return -1;
	}
	// create the elements for sixxx
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_sixxx)*numOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return -1;
	}
	pV-&gt;num = numOfElements; 
}
// updates the vars at the other APs
int HALimpl_66_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for sixxx
	TApVar_vec_sixxx * pV =(TApVar_vec_sixxx *) pVarData;
	TApVar_ele_sixxx * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t i;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 3;
	// calc amount of elements from the params
	pE = pV-&gt;pFE;
	for (i = 0; i &lt; pV-&gt;num; i++) {
	    dataAmount += pE-&gt;num_dataL;
	}
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (i = 0; i &lt; pV-&gt;num; i++) {
	    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pE-&gt;num_dataL);
		pMD-&gt;pfkt_sendFloat32(pMD,pE-&gt;num_dataL,pE-&gt;pA_dataL);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;keffi);
		pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pE-&gt;indx);
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_66_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_66_delete ( void * pVarData ) {
 TApVar_ele_sixxx * pE;
	int32_t i;// frees a sixxx vector
	if (pV) {
	    if (pV-&gt;pFE) {
	        // go over every element and delete the array paramters
			pE = pV-&gt;pFE;
			for (i=0; i&lt;pV-&gt;num;i++) { 
				// delete parameter dataL
				if (pE-&gt;pA_dataL) {
				    free(pE-&gt;pA_dataL);
				    pE-&gt;pA_dataL=NULL;
				    pE-&gt;num_dataL=0;
				}
				
				
			    pE++;
			}
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="294">// ===============================
// variable implementation for sixxx (varID=66)
// ===============================

// element structure for sixxx
typedef struct SApVar_ele_sixxx {
	float * pA_dataL;// the data list (array)
	int32_t num_dataL;// amount of dataL elements
	float keffi;//koefficent
	int32_t indx;//index
	int32_t * pA_array2;// array nummero 2 (array)
	int32_t num_array2;// amount of array2 elements
} TApVar_ele_sixxx;

// vector structure for sixxx
typedef struct SApVar_vec_sixxx {
    TApVar_ele_sixxx * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_sixxx;


// updates a variable the AP
int HALimpl_66_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for sixxx
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_sixxx * pV =(TApVar_vec_sixxx *) pVarData;
	TApVar_ele_sixxx * pE;
	int i, imax;
	int32_t n, nmax;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a sixxx vector
		if (pV) {
		    if (pV-&gt;pFE) {
		        // go over every element and delete the array paramters
				pE = pV-&gt;pFE;
				for (i=0; i&lt;pV-&gt;num;i++) { 
					// delete parameter dataL
					if (pE-&gt;pA_dataL) {
					    free(pE-&gt;pA_dataL);
					    pE-&gt;pA_dataL=NULL;
					    pE-&gt;num_dataL=0;
					}
					
					
					// delete parameter array2
					if (pE-&gt;pA_array2) {
					    free(pE-&gt;pA_array2);
					    pE-&gt;pA_array2=NULL;
					    pE-&gt;num_array2=0;
					}
				    pE++;
				}
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for sixxx
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_sixxx)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    // rx dataL
		APendianConversation32Bit(pD,eAP_littleEndian);
		nmax = *((int32_t *) pD);
		// resize parameter
		if (nmax != pE-&gt;num_dataL) {
		    if (pE-&gt;pA_dataL) free(pE-&gt;pA_dataL);
		    pE-&gt;pA_dataL = malloc(sizeof(float)*nmax);
		    if (!pE-&gt;pA_dataL) return -2;
		    pE-&gt;num_dataL = nmax;
		}
		
		pD++;
		for (n = 0; n &lt; pE-&gt;num_dataL; n++) {
		    // no endian conversation
		    pE-&gt;pA_dataL[n]=*((float *)pD);
		    pD++;
		}
		// rx keffi
		// no endian conversation
		pE-&gt;keffi=*((float *)pD);
		pD++;
		// rx indx
		APendianConversation32Bit(pD,eAP_littleEndian);
		pE-&gt;indx=*((int32_t *)pD);
		pD++;
		// rx array2
		APendianConversation32Bit(pD,eAP_littleEndian);
		nmax = *((int32_t *) pD);
		// resize parameter
		if (nmax != pE-&gt;num_array2) {
		    if (pE-&gt;pA_array2) free(pE-&gt;pA_array2);
		    pE-&gt;pA_array2 = malloc(sizeof(int32_t)*nmax);
		    if (!pE-&gt;pA_array2) return -2;
		    pE-&gt;num_array2 = nmax;
		}
		
		pD++;
		for (n = 0; n &lt; pE-&gt;num_array2; n++) {
		    APendianConversation32Bit(pD,eAP_littleEndian);
		    pE-&gt;pA_array2[n]=*((int32_t *)pD);
		    pD++;
		}
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_66_create ( unsigned int numberOfElements ) {
 // create a new sixxx vector
	pV = malloc(sizeof(TApVar_vec_sixxx));
	if (!pV) {
	    return -1;
	}
	// create the elements for sixxx
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_sixxx)*numOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return -1;
	}
	pV-&gt;num = numOfElements; 
}
// updates the vars at the other APs
int HALimpl_66_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for sixxx
	TApVar_vec_sixxx * pV =(TApVar_vec_sixxx *) pVarData;
	TApVar_ele_sixxx * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t i;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 4;
	// calc amount of elements from the params
	pE = pV-&gt;pFE;
	for (i = 0; i &lt; pV-&gt;num; i++) {
	    dataAmount += pE-&gt;num_dataL+pE-&gt;num_array2;
	}
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (i = 0; i &lt; pV-&gt;num; i++) {
	    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pE-&gt;num_dataL);
		pMD-&gt;pfkt_sendFloat32(pMD,pE-&gt;num_dataL,pE-&gt;pA_dataL);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;keffi);
		pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pE-&gt;indx);
		pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pE-&gt;num_array2);
		pMD-&gt;pfkt_sendInteger32(pMD,pE-&gt;num_array2,pE-&gt;pA_array2);
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_66_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_66_delete ( void * pVarData ) {
 TApVar_ele_sixxx * pE;
	int32_t i;// frees a sixxx vector
	if (pV) {
	    if (pV-&gt;pFE) {
	        // go over every element and delete the array paramters
			pE = pV-&gt;pFE;
			for (i=0; i&lt;pV-&gt;num;i++) { 
				// delete parameter dataL
				if (pE-&gt;pA_dataL) {
				    free(pE-&gt;pA_dataL);
				    pE-&gt;pA_dataL=NULL;
				    pE-&gt;num_dataL=0;
				}
				
				
				// delete parameter array2
				if (pE-&gt;pA_array2) {
				    free(pE-&gt;pA_array2);
				    pE-&gt;pA_array2=NULL;
				    pE-&gt;num_array2=0;
				}
			    pE++;
			}
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="295">// ===============================
// driver uuid =4
// ===============================

//open an existing driver and bind it to the AP
int drv_4_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_4_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_4_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//sends raw data in uint32_t chunks
int drv_4_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	return 0;
}
//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_4_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	return 0;
}
//sends float data in float chunks
int drv_4_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	return 0;
}
//acknowledge
int drv_4_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_4_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_4_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_4_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	return 0;
}
//sends an instruction
int drv_4_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	return 0;
}
//sings that the program transmission has completed
int drv_4_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_4_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_4_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_4_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_4_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_4_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_4_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="296">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;
// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;PC.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) {
			fprintf(stderr,&quot;load variable failed at position %i\n&quot;, (int)i+1);
			return -10;
		}
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)){
			fprintf(stderr,&quot;load instruction failed at position %i\n&quot;, (int)i+1);
			return -20;
		}
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif


TAPMsgDrv 	gDrvL [1];
TAP 		AP;

void * APIPthread(void * pArgs) {
	APInterpreterProcessState(AP.IP);

	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

int main()
{
	WSADATA			wsaData;
	pthread_t		IPthread;
	pthread_t		MSthread;


	int rc;
	int endianS = eAP_littleEndian;

    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	printf(&quot;WSAStartup failed!&quot;);
    	return -1;
    }

	APdriver_1_init(&amp;gDrvL[0]);

	time_t t;

	time(&amp;t);
	srand((unsigned int)t);              /* Zufallsgenerator initialisieren */

	int uuid = rand();

	printf (&quot;AP uuid %i\n&quot;,uuid);

	// start up gtk+
	APgtk_start ();

	//rc = APinit(&amp;AP,815,gDrvL,1,1000,eAP_littleEndian);
	rc = APinit(&amp;AP,(TAPNodeID)uuid,gDrvL,1,1000,endianS);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
	if (rc) {
		printf(&quot;load programm failed with %i&quot;, rc);
		goto exit;
	}
#endif

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif

	rc = APInterpreterSetState (AP.IP,endianS,eAPInterpreterState_run);

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	printf(&quot;press a key to exit&quot;);
	getch();

	rc = APInterpreterSetState (AP.IP,endianS,eAPInterpreterState_halt);


exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}</Code><Code idCode="297">// ===============================
// AP uuid = 12
// ===============================
asffd
// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

// ================================
// MMU functions
// ================================

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}

// create a mmu
TAPMMU AP_MMU_create (int elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, int elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	// we go for sure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}


// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}

// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}
</Code><Code idCode="298">// ===============================
// driver uuid =4
// ===============================

//open an existing driver and bind it to the AP
int drv_4_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_4_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_4_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//sends raw data in uint32_t chunks
int drv_4_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	return 0;
}
//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_4_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	return 0;
}
//sends float data in float chunks
int drv_4_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	return 0;
}
//acknowledge
int drv_4_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_4_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_4_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_4_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	return 0;
}
//sends an instruction
int drv_4_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	return 0;
}
//sings that the program transmission has completed
int drv_4_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_4_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_4_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_4_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_4_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_4_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_4_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="299">// ===============================
// variable implementation for biquad (varID=10)
// ===============================

// element structure for biquad
typedef struct SApVar_ele_biquad {
	float a0;//enumerator coefficient
	float a1;//enumerator coefficient
	float a2;//enumerator coefficient
	float b0;//numerator coefficient
	float b1;//numerator coefficient
	float b2;//numerator coefficient
} TApVar_ele_biquad;

// vector structure for biquad
typedef struct SApVar_vec_biquad {
    TApVar_ele_biquad * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_biquad;


// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for biquad
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_biquad * pV =(TApVar_vec_biquad *) pVarData;
	TApVar_ele_biquad * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a biquad vector
		TApVar_vec_biquad * pV = (TApVar_vec_biquad *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        // go over every element and delete the array paramters
				pE = pV-&gt;pFE;
				for (i=0; i&lt;pV-&gt;num;i++) { 
					
					
					
					
					
					
				    pE++;
				}
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for biquad
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_biquad)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    // rx a0
		// no endian conversation
		pE-&gt;a0=*((float *)pD);
		pD++;
		// rx a1
		// no endian conversation
		pE-&gt;a1=*((float *)pD);
		pD++;
		// rx a2
		// no endian conversation
		pE-&gt;a2=*((float *)pD);
		pD++;
		// rx b0
		// no endian conversation
		pE-&gt;b0=*((float *)pD);
		pD++;
		// rx b1
		// no endian conversation
		pE-&gt;b1=*((float *)pD);
		pD++;
		// rx b2
		// no endian conversation
		pE-&gt;b2=*((float *)pD);
		pD++;
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 // create a new biquad vector
	TApVar_vec_biquad * pV;
	 
	pV = malloc(sizeof(TApVar_vec_biquad));
	if (!pV) {
	    return NULL;
	}
	// create the elements for biquad
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_biquad)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for biquad
	TApVar_vec_biquad * pV =(TApVar_vec_biquad *) pVarData;
	TApVar_ele_biquad * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 6;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;a0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;a1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;a2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;b0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;b1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;b2);
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
 TApVar_ele_biquad * pE;
	int32_t i;// frees a biquad vector
	TApVar_vec_biquad * pV = (TApVar_vec_biquad *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        // go over every element and delete the array paramters
			pE = pV-&gt;pFE;
			for (i=0; i&lt;pV-&gt;num;i++) { 
				
				
				
				
				
				
			    pE++;
			}
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="300">// ===============================
// variable implementation for biquad (varID=10)
// ===============================

// element structure for biquad
typedef struct SApVar_ele_biquad {
	float n0;//enumerator coefficient
	float n1;//enumerator coefficient
	float n2;//enumerator coefficient
	float d0;//denominator coefficient
	float d1;//denominator coefficient
	float d2;//denominator coefficient
} TApVar_ele_biquad;

// vector structure for biquad
typedef struct SApVar_vec_biquad {
    TApVar_ele_biquad * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_biquad;


// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for biquad
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_biquad * pV =(TApVar_vec_biquad *) pVarData;
	TApVar_ele_biquad * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a biquad vector
		TApVar_vec_biquad * pV = (TApVar_vec_biquad *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        // go over every element and delete the array paramters
				pE = pV-&gt;pFE;
				for (i=0; i&lt;pV-&gt;num;i++) { 
					
					
					
					
					
					
				    pE++;
				}
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for biquad
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_biquad)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    // rx n0
		// no endian conversation
		pE-&gt;n0=*((float *)pD);
		pD++;
		// rx n1
		// no endian conversation
		pE-&gt;n1=*((float *)pD);
		pD++;
		// rx n2
		// no endian conversation
		pE-&gt;n2=*((float *)pD);
		pD++;
		// rx d0
		// no endian conversation
		pE-&gt;d0=*((float *)pD);
		pD++;
		// rx d1
		// no endian conversation
		pE-&gt;d1=*((float *)pD);
		pD++;
		// rx d2
		// no endian conversation
		pE-&gt;d2=*((float *)pD);
		pD++;
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 // create a new biquad vector
	TApVar_vec_biquad * pV;
	 
	pV = malloc(sizeof(TApVar_vec_biquad));
	if (!pV) {
	    return NULL;
	}
	// create the elements for biquad
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_biquad)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for biquad
	TApVar_vec_biquad * pV =(TApVar_vec_biquad *) pVarData;
	TApVar_ele_biquad * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 6;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;n0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;n1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;n2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;d0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;d1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;d2);
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
 TApVar_ele_biquad * pE;
	int32_t i;// frees a biquad vector
	TApVar_vec_biquad * pV = (TApVar_vec_biquad *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        // go over every element and delete the array paramters
			pE = pV-&gt;pFE;
			for (i=0; i&lt;pV-&gt;num;i++) { 
				
				
				
				
				
				
			    pE++;
			}
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="301">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================
void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	void * x = pParams[0].fp_pD;
// parameter bqa descr: biquad cascade
	void * bqa = pParams[1].fp_pD;
// parameter y descr: output
	void * y = pParams[2].fp_pD;
};
</Code><Code idCode="302">// ============================================================================
// generic delay implementation (start)
// ============================================================================

// ============================================================================
// a generic i/o optimized implementation of a delayline
//
// it relies on the idea of a ringbuffer
// it is implemented by the use of read/write pointers
// features:
// - full ANSI C89 compatible
// - it doesn't use memmove, memcpy, malloc, free etc
// - it minimizes the amount of local variables
// - it precalculates wrapings and avoids if clauses (instruction cache friendly)
// - it minimizes read/write operation on the same memory cells and only
//  access the memory cells only once (data cache friendly)
// ============================================================================

// activate pointer check
#define dgenDelay_CheckPointer

//! a delay
typedef struct SgenDelay {
	float * pStart;	//!&lt; starting pointer
	float *	pEnd;	//!&lt; end pointer
	int		amount;	//!&lt; amount of elements
	float * pR;		//!&lt; read pointer
	float * pW;		//!&lt; write pointer
} TgenDelay;

//! a enum type for the read / write flags
typedef enum EgenDelayRWflag {
	EgenDelayRWflag_readPointer = 0,			//!&lt; only read pointer
	EgenDelayRWflag_writePointer = 1,			//!&lt; only write pointer
	EgenDelayRWflag_readAndWritePointer = 2		//!&lt; read &amp; write pointer
} TgenDelayRWflag;

//! inits the delay
void genDelay_init (
		TgenDelay * 	pD,					//!&lt; (in/out) pointer to a delay struct which is filled
		float * 		pStart,				//!&lt; (in) pointer to the memory used to store the values
		int				amount,				//!&lt; (in) amount of elements at the memory
		int				clearBufferFlag		//!&lt; if not zero the buffer get overwritten with 0.0f
	) {
	// set pointers
	pD-&gt;pStart = pStart;
	pD-&gt;amount = amount;
	pD-&gt;pEnd = pStart + amount;
	pD-&gt;pW = pStart;
	pD-&gt;pR = pStart;
	if (clearBufferFlag) {
		// and the buffer to 0.0f
		float * pB = pStart;
		while (amount) {
			*pB = 0.0f;
			pB++;
			amount--;
		}
	}
}

//! creates the structure and the buffer for a delay
TgenDelay * genDelay_create (int amountOfSamples) {
	// malloc structure
	TgenDelay * pD = malloc(sizeof(TgenDelay));
	if (!pD) return NULL;
	if (amountOfSamples &gt; 0) {
		// malloc data buffer
		pD-&gt;pStart = malloc(sizeof(float)*amountOfSamples);
		if (!pD-&gt;pStart) {
			free (pD);
			return NULL;
		}
		// reset structure
		genDelay_init(pD,pD-&gt;pStart,amountOfSamples, 1);
	} else {
		genDelay_init(pD,NULL,0, 0);
	}
	return pD;
}

//! deletes the delay structure and the contained data
void genDelay_delete (TgenDelay * pD) {
	if (!pD) return;
	if (pD-&gt;pStart) free(pD-&gt;pStart);
	free(pD);
}

//!
int genDelay_resize (TgenDelay * pD, int newBufferSize) {
	// null pointer exception
	if (!pD) return -1;
	// have we realy to alloc new memory?
	if (pD-&gt;amount == newBufferSize) goto init;
	// ok lets free the old one
	free (pD-&gt;pStart);
	// and alloc a new one
	pD-&gt;pStart = malloc(sizeof(float)*newBufferSize);
	// check if it worked
	if (!pD-&gt;pStart) {
		// no - ok lets make stable state and report an error
		genDelay_init(pD,NULL,0, 0);
		return -2;
	}
	// it worked lets init
init:
	genDelay_init(pD,pD-&gt;pStart,newBufferSize, 1);
	return 0;

}

// shuffle the read and/or write pointer
void genDelay_shuffle (
		TgenDelay * 	pD,			//!&lt; (in/out) pointer to a delay struct
		TgenDelayRWflag	what,		//!&lt; what defines what pointer is affected
		int				offset		//!&lt; the offset of the R/W pointer
	) {
	int modf = offset % pD-&gt;amount;
	// read pointer
	if ((what == EgenDelayRWflag_readPointer) || (what == EgenDelayRWflag_readAndWritePointer)) {
		pD-&gt;pR += modf;
		if (pD-&gt;pR &gt; pD-&gt;pEnd) {
			pD-&gt;pR = pD-&gt;pStart + (pD-&gt;pR - pD-&gt;pEnd);
		} else {
			if (pD-&gt;pR &lt; pD-&gt;pStart) {
				pD-&gt;pR = pD-&gt;pEnd - (pD-&gt;pStart - pD-&gt;pR);
			}
		}
	}

	// write pointer
	if ((what == EgenDelayRWflag_writePointer) || (what == EgenDelayRWflag_readAndWritePointer)) {
		pD-&gt;pW += modf;
		if (pD-&gt;pW &gt; pD-&gt;pEnd) {
			pD-&gt;pW = pD-&gt;pStart + (pD-&gt;pW - pD-&gt;pEnd);
		} else {
			if (pD-&gt;pW &lt; pD-&gt;pStart) {
				pD-&gt;pW = pD-&gt;pEnd - (pD-&gt;pStart - pD-&gt;pW);
			}
		}
	}

}

//! writes a grain of values to the buffer
void genDelay_write (
		TgenDelay * 	pD,		//!&lt; (in/out) pointer to a delay struct
		float * 		pSrc,	//!&lt; (in) pointer to the values put into the delay
		int				N		//!&lt; (in) amount of values to be stored
	) {
#ifdef dgenDelay_CheckPointer
	if ((!pD) || (!pD-&gt;pW) || (!pSrc)){
		return;
	}
#endif

	while (N) {
		// copy value
		*pD-&gt;pW = *pSrc;
		// inc src pointer
		pSrc++;
		// inc write pointer
		pD-&gt;pW++;
		// does we extends the border?
		if (pD-&gt;pW &gt;= pD-&gt;pEnd) {
			// yes - ok lets wrap
			pD-&gt;pW = pD-&gt;pStart;
		}
		N--;
	}
}

//! reads a grain of values form the buffer
void genDelay_read (
		TgenDelay * 	pD,		//!&lt; (in) pointer to a delay struct
		float * 		pDest,	//!&lt; (in/out) pointer to which the values are stored
		int				N		//!&lt; (in) amount of values to be stored
	) {
#ifdef dgenDelay_CheckPointer
	if ((!pD) || (!pD-&gt;pR) || (!pDest)){
		return;
	}
#endif

	while (N) {
		// copy value
		*pDest = *pD-&gt;pR;
		// inc src pointer
		pDest++;
		// inc read pointer
		pD-&gt;pR++;
		// does we extends the border?
		if (pD-&gt;pR &gt;= pD-&gt;pEnd) {
			// yes - ok lets wrap
			pD-&gt;pR = pD-&gt;pStart;
		}
		N--;
	}
}

//! reads a grain of values form the buffer and copies the same amount into the buffer
void genDelay_readWrite (
		TgenDelay * 	pD,		//!&lt; (in) pointer to a delay struct
		float *			pSrc,	//!&lt; (in) a pointer from which the values should be copied
		float * 		pDest,	//!&lt; (in/out) pointer to which the values are stored
		int				N		//!&lt; (in) amount of values to be stored
	) {
	// 3 state approach to minimize the amount of i/o operations
	// 1st state read till we reach the write pointer or N is 0
	// 2nd state read &amp; write till we read all data needed
	// 3th state write till all data is written

#ifdef dgenDelay_CheckPointer
	if ((!pD) || (!pD-&gt;pR) || (!pD-&gt;pW) || (!pDest) || (!pSrc)){
		return;
	}
#endif


	// wrap counter
	int wc;

	// read number
	int rn, rn2;
	// lets calculate how many read operations are needed to reach the write pointer
	// first check the position of the write pointer
	if (pD-&gt;pW &gt;= pD-&gt;pR) {
		// the write pointer is in front of the read pointer
		rn = pD-&gt;pW - pD-&gt;pR;
	} else {
		// the write pointer stands after the read pointer
		rn = pD-&gt;amount - (pD-&gt;pR - pD-&gt;pW);
	}
	// trim
	if (rn &gt; N) rn = N;
	rn2 = N - rn;

	// 1st state
	// 1.1. read till it wraps
	wc = pD-&gt;pEnd - pD-&gt;pR;
	if (wc &gt; rn) wc = rn;
	rn -= wc;
	while (wc) {
		wc--;
		*pDest = *pD-&gt;pR;
		pDest++;
		pD-&gt;pR++;
	}
	// wrap if needed
	if (pD-&gt;pR &gt;= pD-&gt;pEnd) pD-&gt;pR = pD-&gt;pStart;
	// 1.2 and read on
	while (rn) {
		rn --;
		*pDest = *pD-&gt;pR;
		pDest++;
		pD-&gt;pR++;
	}

	// 2nd state
	// the read/write operation
	// we use only the pD-&gt;pW pointer for the operation and increment the pD-&gt;pR only once
	// in rn2 are the remaining numbers stored
	pD-&gt;pR += rn2;
	N -= rn2;
	// wrap pR if needed
	if (pD-&gt;pR &gt;= pD-&gt;pEnd) pD-&gt;pR = pD-&gt;pStart + (pD-&gt;pR - pD-&gt;pEnd);

	// get the wrap counter
	wc = pD-&gt;pEnd - pD-&gt;pW;
	if (wc &gt; rn2) wc = rn2;

	// get the remaining number
	rn = rn2 - wc;

	// write &amp; read
	while (wc) {
		wc--;
		*pDest = *pD-&gt;pW;
		*pD-&gt;pW = *pSrc;
		pDest++;
		pSrc++;
		pD-&gt;pW++;
	}
	// warp
	if (pD-&gt;pW &gt;= pD-&gt;pEnd) pD-&gt;pW = pD-&gt;pStart;
	// write &amp; read
	while (rn) {
		rn--;
		*pDest = *pD-&gt;pW;
		*pD-&gt;pW = *pSrc;
		pDest++;
		pSrc++;
		pD-&gt;pW++;
	}

	// 3th state
	// write the data
	// at N are the number of the remaining data

	// get the wrap counter
	wc = pD-&gt;pEnd - pD-&gt;pW;
	if (wc &gt; N) wc = N;
	N -= wc;
	// write the data
	while (wc) {
		wc--;
		*pD-&gt;pW = *pSrc;
		pSrc++;
		pD-&gt;pW++;
	}
	// wrap
	if (pD-&gt;pW &gt;= pD-&gt;pEnd) pD-&gt;pW = pD-&gt;pStart;
	// write the remaining data
	while (N) {
		N--;
		*pD-&gt;pW = *pSrc;
		pSrc++;
		pD-&gt;pW++;
	}

}

// ============================================================================
// generic delay implementation (end)
// ============================================================================
</Code><Code idCode="303">// ===============================
// variable implementation for delay (varID=20)
// ===============================

// element structure for delay
typedef struct SApVar_ele_delay {
	int32_t * pA_values;// the values ordered oldest to jungest (array)
	int32_t num_values;// amount of values elements
} TApVar_ele_delay;

// vector structure for delay
typedef struct SApVar_vec_delay {
    TApVar_ele_delay * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_delay;


// updates a variable the AP
int HALimpl_20_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for delay
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_delay * pV =(TApVar_vec_delay *) pVarData;
	TApVar_ele_delay * pE;
	int i, imax;
	int32_t n, nmax;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a delay vector
		TApVar_vec_delay * pV = (TApVar_vec_delay *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        // go over every element and delete the array paramters
				pE = pV-&gt;pFE;
				for (i=0; i&lt;pV-&gt;num;i++) { 
					// delete parameter values
					if (pE-&gt;pA_values) {
					    free(pE-&gt;pA_values);
					    pE-&gt;pA_values=NULL;
					    pE-&gt;num_values=0;
					}
				    pE++;
				}
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for delay
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_delay)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    // rx values
		APendianConversation32Bit(pD,eAP_littleEndian);
		nmax = *((int32_t *) pD);
		// resize parameter
		if (nmax != pE-&gt;num_values) {
		    if (pE-&gt;pA_values) free(pE-&gt;pA_values);
		    pE-&gt;pA_values = malloc(sizeof(int32_t)*nmax);
		    if (!pE-&gt;pA_values) return -2;
		    pE-&gt;num_values = nmax;
		}
		
		pD++;
		for (n = 0; n &lt; pE-&gt;num_values; n++) {
		    APendianConversation32Bit(pD,eAP_littleEndian);
		    pE-&gt;pA_values[n]=*((int32_t *)pD);
		    pD++;
		}
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_20_create ( unsigned int numberOfElements ) {
 // create a new delay vector
	TApVar_vec_delay * pV;
	 
	pV = malloc(sizeof(TApVar_vec_delay));
	if (!pV) {
	    return NULL;
	}
	// create the elements for delay
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_delay)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_20_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for delay
	TApVar_vec_delay * pV =(TApVar_vec_delay *) pVarData;
	TApVar_ele_delay * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 1;
	// calc amount of elements from the params
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    dataAmount += pE-&gt;num_values;
	}
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pE-&gt;num_values);
		pMD-&gt;pfkt_sendInteger32(pMD,pE-&gt;num_values,pE-&gt;pA_values);
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_20_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_20_delete ( void * pVarData ) {
 TApVar_ele_delay * pE;
	int32_t i;// frees a delay vector
	TApVar_vec_delay * pV = (TApVar_vec_delay *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        // go over every element and delete the array paramters
			pE = pV-&gt;pFE;
			for (i=0; i&lt;pV-&gt;num;i++) { 
				// delete parameter values
				if (pE-&gt;pA_values) {
				    free(pE-&gt;pA_values);
				    pE-&gt;pA_values=NULL;
				    pE-&gt;num_values=0;
				}
			    pE++;
			}
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="304">// ===============================
// variable implementation for delay (varID=20)
// ===============================

// updates a variable the AP
int HALimpl_20_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for delay
	uint32_t * pD = (uint32_t *) pMsgData;
	TgenDelay * pV =(TgenDelay *) pVarData;

	int imax, i;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;

	// 1. resize
	if (genDelay_resize(pV, imax)) {
		return -1;
	}
	
	// 2. fill parameters
	for (i = 0; i &lt; pV-&gt;amount; i++) {
		// no endian conversation
		pV-&gt;pStart[i]=*((float *)pD);
		pD++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_20_create ( unsigned int numberOfElements ) {
	// only one element is allowed
	if (numberOfElements != 1) {
		return NULL;
	}
	// cerate with now data inside
 	return genDelay_create(0);
}
// updates the vars at the other APs
int HALimpl_20_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for delay
	TgenDelay * pV =(TgenDelay *) pVarData;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	
	// calc amount of transmission bytes
	// = size of the delay + amount of the elements at the delay
	dataAmount = (int32_t) 1 + pV-&gt;amount;
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send delay
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;amount);
	
	// 2.2 send elements
	pMD-&gt;pfkt_sendFloat32(pMD,pV-&gt;amount,pV-&gt;pStart);
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_20_decodeData ( void * pVarData ) {
 return pVarData;
}
// delete the variable
void HALimpl_20_delete ( void * pVarData ) {
	TgenDelay * pD = (TgenDelay *) pVarData;
	genDelay_delete(pD);
}</Code><Code idCode="305">// ===============================
// function implementation for calcDelay(var id = 150)
// description: shifts the content of the delay
// ===============================
void HALfunc_ID150_calcDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	void * x = pParams[0].fp_pD;
// parameter delay descr: the delay
	TAPInterpreterVariable * delay = pParams[1].fp_pV;
// parameter y descr: output
	void * y = pParams[2].fp_pD;
};
</Code><Code idCode="306">// ===============================
// function implementation for calcDelay(var id = 150)
// description: shifts the content of the delay
// ===============================
void HALfunc_ID150_calcDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	void * x = pParams[0].fp_pD;
// parameter delay descr: the delay
	TAPInterpreterVariable * delay = pParams[1].fp_pV;
// parameter y descr: output
	void * y = pParams[2].fp_pD;
};
</Code><Code idCode="307">// ===============================
// function implementation for calcDelay(var id = 150)
// description: shifts the content of the delay
// ===============================
void HALfunc_ID150_calcDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter delay descr: the delay
	TgenDelay * delay = (TgenDelay *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	genDelay_readWrite(delay, x-&gt;pVal, y-&gt;pVal, y-&gt;num);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="308">// ===============================
// function implementation for initDelay(var id = 151)
// description: inits the delay
// ===============================
void HALfunc_ID151_initDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter d descr: the delay
	TgenDelay * d = (TgenDelay *) pParams[0].fp_pD;
	// parameter N descr: number of samples which correspond to the delay time (Tdelay = N * Ta)
	TAPgenericIntegerVector * pN = (TAPgenericIntegerVector *)pParams[1].fp_pD;
	// parameter Nindex descr: the index at the vector of N
	int Nindex = (int)*((TAPgenericIntegerVector *)pParams[2].fp_pD)-&gt;pVal;

	// resize delay
	if (genDelay_resize(d, pN-&gt;pVal[Nindex])) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}
	// inc IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="309">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================
void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer witch receives the samples
	void * frameBuffer = pParams[1].fp_pD;
// parameter waitForNewFrame descr: if not zero the function waits for a new sample frame
	int32_t waitForNewFrame = pParams[2].fp_integer;
};
</Code><Code idCode="310">// ===============================
// function implementation for initLimiter(var id = 114)
// description: initialize a limiter
// ===============================
void HALfunc_ID114_initLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter lim descr: limiter
	void * lim = pParams[0].fp_pD;
// parameter ATpeak descr: attack value for the peak detection
	float ATpeak = pParams[1].fp_rational;
// parameter RTpeak descr: release value for the peak detection
	float RTpeak = pParams[2].fp_rational;
// parameter ATsmooth descr: attack value for the smoothing
	float ATsmooth = pParams[3].fp_rational;
// parameter RTsmooth descr: release value for the smoothing
	float RTsmooth = pParams[4].fp_rational;
// parameter LT descr: limiter threshold
	float LT = pParams[5].fp_rational;
// parameter LS descr: slope
	float LS = pParams[6].fp_rational;
};
</Code><Code idCode="311">// ===============================
// function implementation for calcLimiter(var id = 118)
// description: sends a stream of samples through a limiter
// ===============================
void HALfunc_ID118_calcLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	void * x = pParams[0].fp_pD;
// parameter lim descr: limiter
	void * lim = pParams[1].fp_pD;
// parameter y descr: output
	void * y = pParams[2].fp_pD;
};
</Code><Code idCode="312">// ===============================
// function implementation for initBiquad(var id = 105)
// description: inits a biquad of h(z) = y(z)/x(z) = (a0*z0 + a1*z-1+ a2*z-2) / (1*z0 + b1*z-1+ b2*z-2)
// ===============================
void HALfunc_ID105_initBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TstjBiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int index = (int)*((TAPgenericIntegerVector *) pParams[1].fp_pD)-&gt;pVal;

// a temporal set of the vector for the numerator / denumerator values
// parameter a0 descr: a0 coefficient
	pbqc-&gt;pB[index].a[0] = (float) *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter a1 descr: a1 coefficient
	pbqc-&gt;pB[index].a[1] = (float) *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter a2 descr: a2 coefficient
	pbqc-&gt;pB[index].a[2] = (float) *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;
// parameter b1 descr: b1 coefficient
	pbqc-&gt;pB[index].b[0] = (float) *((TAPgenericRationalVector *) pParams[5].fp_pD)-&gt;pVal;
// parameter b2 descr: b2 coefficient
	pbqc-&gt;pB[index].b[1] = (float) *((TAPgenericRationalVector *) pParams[6].fp_pD)-&gt;pVal;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="313">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;DAP26_UI.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}


int main()
{
	int rc;
	pthread_t		IPthread;
	pthread_t		MSthread;


	APgtk_start();

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);


	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	APgtk_end ();

	return EXIT_SUCCESS;
}
</Code><Code idCode="314">// ===============================
// variable implementation for biquad (varID=10)
// ===============================

// element structure for biquad
typedef struct SApVar_ele_biquad {
	float n0;//enumerator coefficient
	float n1;//enumerator coefficient
	float n2;//enumerator coefficient
	float d0;//denominator coefficient
	float d1;//denominator coefficient
	float d2;//denominator coefficient
} TApVar_ele_biquad;

// vector structure for biquad
typedef struct SApVar_vec_biquad {
    TApVar_ele_biquad * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_biquad;


// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for biquad
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_biquad * pV =(TApVar_vec_biquad *) pVarData;
	TApVar_ele_biquad * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a biquad vector
		TApVar_vec_biquad * pV = (TApVar_vec_biquad *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        // go over every element and delete the array paramters
				pE = pV-&gt;pFE;
				for (i=0; i&lt;pV-&gt;num;i++) { 
					
					
					
					
					
					
				    pE++;
				}
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for biquad
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_biquad)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    // rx n0
		// no endian conversation
		pE-&gt;n0=*((float *)pD);
		pD++;
		// rx n1
		// no endian conversation
		pE-&gt;n1=*((float *)pD);
		pD++;
		// rx n2
		// no endian conversation
		pE-&gt;n2=*((float *)pD);
		pD++;
		// rx d0
		// no endian conversation
		pE-&gt;d0=*((float *)pD);
		pD++;
		// rx d1
		// no endian conversation
		pE-&gt;d1=*((float *)pD);
		pD++;
		// rx d2
		// no endian conversation
		pE-&gt;d2=*((float *)pD);
		pD++;
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 // create a new biquad vector
	TApVar_vec_biquad * pV;
	 
	pV = malloc(sizeof(TApVar_vec_biquad));
	if (!pV) {
	    return NULL;
	}
	// create the elements for biquad
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_biquad)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for biquad
	TApVar_vec_biquad * pV =(TApVar_vec_biquad *) pVarData;
	TApVar_ele_biquad * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 6;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;n0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;n1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;n2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;d0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;d1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pE-&gt;d2);
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
 TApVar_ele_biquad * pE;
	int32_t i;// frees a biquad vector
	TApVar_vec_biquad * pV = (TApVar_vec_biquad *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        // go over every element and delete the array paramters
			pE = pV-&gt;pFE;
			for (i=0; i&lt;pV-&gt;num;i++) { 
				
				
				
				
				
				
			    pE++;
			}
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="315">// ===============================
// variable implementation for panel (varID=100)
// ===============================

// element structure for panel
typedef struct SApVar_ele_panel {
} TApVar_ele_panel;

// vector structure for panel
typedef struct SApVar_vec_panel {
    TApVar_ele_panel * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_panel;


// updates a variable the AP
int HALimpl_100_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for panel
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_panel * pV =(TApVar_vec_panel *) pVarData;
	TApVar_ele_panel * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a panel vector
		TApVar_vec_panel * pV = (TApVar_vec_panel *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for panel
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_panel)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_100_create ( unsigned int numberOfElements ) {
 // create a new panel vector
	TApVar_vec_panel * pV;
	 
	pV = malloc(sizeof(TApVar_vec_panel));
	if (!pV) {
	    return NULL;
	}
	// create the elements for panel
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_panel)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for panel
	TApVar_vec_panel * pV =(TApVar_vec_panel *) pVarData;
	TApVar_ele_panel * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_100_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_100_delete ( void * pVarData ) {
 // frees a panel vector
	TApVar_vec_panel * pV = (TApVar_vec_panel *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="316">// ===============================
// function implementation for calcLimiter(var id = 118)
// description: sends a stream of samples through a limiter (y = limiter(x))
// ===============================
void HALfunc_ID118_calcLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	void * x = pParams[0].fp_pD;
// parameter lim descr: limiter
	void * lim = pParams[1].fp_pD;
// parameter y descr: output
	void * y = pParams[2].fp_pD;
};
</Code><Code idCode="317">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================
void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: x position
	int32_t x = pParams[0].fp_integer;
// parameter y descr: y position
	int32_t y = pParams[1].fp_integer;
// parameter xle descr: x length
	int32_t xle = pParams[2].fp_integer;
// parameter yle descr: y length
	int32_t yle = pParams[3].fp_integer;
// parameter ui descr: ui
	void * ui = pParams[4].fp_pD;
// parameter uiIndex descr: ui index
	int32_t uiIndex = pParams[5].fp_integer;
};
</Code><Code idCode="318">// ===============================
// driver uuid =4
// ===============================

//open an existing driver and bind it to the AP
int drv_4_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_4_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_4_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//sends raw data in uint32_t chunks
int drv_4_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	return 0;
}
//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_4_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	return 0;
}
//sends float data in float chunks
int drv_4_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	return 0;
}
//acknowledge
int drv_4_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_4_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_4_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_4_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	return 0;
}
//sends an instruction
int drv_4_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	return 0;
}
//sings that the program transmission has completed
int drv_4_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_4_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_4_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_4_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_4_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_4_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_4_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="319">// ===============================
// AP uuid = 12
// ===============================

// the global frame module
TStjFrameWAVmodule gFrameWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	// init wav module
	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;x.wav&quot;,1,48000,1},
			{2,&quot;y.wav&quot;,0,48000,1}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

// ================================
// MMU functions
// ================================

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}

// create a mmu
TAPMMU AP_MMU_create (int elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, int elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
		APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	// we go for sure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}


// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}

// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}
</Code><Code idCode="320">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;DAFx2012.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}


int main()
{
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,gAPendianFlag,eAPInterpreterState_run);

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="321">// ===============================
// AP uuid = 12
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (int elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, int elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);


	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	// we go for shure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="322">// ===============================
// AP uuid = 12
// ===============================

TStjFrameWAVmodule gFrameWAVModule={.pChannels = NULL, .number = 0};

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// init wav module
	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;x.wav&quot;,1,48000,1},
			{2,&quot;y.wav&quot;,0,48000,1}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

// ================================
// MMU functions
// ================================

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}

// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt;= pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;

	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	// we go for sure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}


// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}

// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}
</Code><Code idCode="323">// ===============================================
// Audio Language &amp; Processor Port Audio interface
// ===============================================

// linux package
// sudo apt-get install portaudio19-dev

#include &lt;semaphore.h&gt;

//! a type for the global configuration
// and runtime data
typedef struct SALportAudio {
	float * pOB;

	float * pIB;


	// Semaphore to indicate to main that a block is ready for processing
	sem_t newSamples;

	// port audio stream
	PaStream * as;

	// sample amount
	int samplesAmount;

	// channel amount
	int channelAmount;

	// sample amount per buffer
	int bufferSampleAmount;

	// buffer size
	size_t bufferSize;
} TALportAudio;


TALportAudio gALportAudio = {
	.pOB = NULL,

	.pIB = NULL,

	.as = NULL,

	.samplesAmount = 0,
	.channelAmount = 0,
	.bufferSampleAmount = 0,
	.bufferSize = 0,

};


// the callback if some samples have been received
static int ALportAudio_gotSampelsCB (
		const void *	pIB,
		void *			pOB,
		unsigned long 	framesPerBuffer,
		const PaStreamCallbackTimeInfo* timeInfo,
		PaStreamCallbackFlags statusFlags,
		void *userData
	) {
	// get the inputs
	memcpy(pOB, gALportAudio.pOB, gALportAudio.bufferSize);
	memcpy(gALportAudio.pIB, pIB, gALportAudio.bufferSize);

	sem_post(&amp;gALportAudio.newSamples);

	return paContinue;
}

void ALportAudio_WaitForNewSamples () {
	sem_wait(&amp;gALportAudio.newSamples);
}

//! inits the port audio lib
int ALportAudio_init () {
	PaError err;

	sem_init(&amp;gALportAudio.newSamples, 0, 1);

	err = Pa_Initialize();
	if( err != paNoError ) {
		return -10;
	}

	return 0;
}

int ALportAudio_setupStreams (
		double 			sampleRate,			//!&lt; the desired sample rate
		int 			inputChannels,		//!&lt; the amount of input channels
		PaDeviceIndex	inputDeviceIndx,	//!&lt; the index of the input device (-1 for the default device)
		int 			outputChannels,		//!&lt; the amount of output channels
		PaDeviceIndex	outputDeviceIndx,	//!&lt; the index of the output device (-1 for the default device)
		unsigned long	sampleBlockSize		//!&lt; the size of the samples read per channel
	) {
	PaError err;
	PaStreamParameters inputParameters;
	PaStreamParameters outputParameters;

	int i;

	if (inputChannels != outputChannels) {
		printf(&quot;input channels != output channels&quot;);
		return -10;
	}


	// setup input and output
	// setup input and output
	inputParameters.device = (inputDeviceIndx &lt; 0) ? Pa_GetDefaultInputDevice() : inputDeviceIndx;
	inputParameters.channelCount = inputChannels;
	inputParameters.sampleFormat = paFloat32;
	inputParameters.suggestedLatency = Pa_GetDeviceInfo( inputParameters.device )-&gt;defaultHighInputLatency ;
	inputParameters.hostApiSpecificStreamInfo = NULL;

	outputParameters.device = (outputDeviceIndx &lt; 0) ? Pa_GetDefaultOutputDevice() : outputDeviceIndx;
	outputParameters.channelCount = outputChannels;
	outputParameters.sampleFormat = paFloat32;
	outputParameters.suggestedLatency = Pa_GetDeviceInfo( outputParameters.device )-&gt;defaultHighOutputLatency;
	outputParameters.hostApiSpecificStreamInfo = NULL;

	err = Pa_IsFormatSupported(&amp;inputParameters,&amp;outputParameters,sampleRate);
	if( err != paNoError ) {
		printf( &quot;PortAudio error: %s\n&quot;, Pa_GetErrorText( err ) );
		Pa_Terminate();
		return -20;
	}


	err = Pa_OpenStream(
			&amp;gALportAudio.as,
			&amp;inputParameters,
			&amp;outputParameters,
			sampleRate,
			sampleBlockSize,
			paNoFlag, //flags that can be used to define dither, clip settings and more
			ALportAudio_gotSampelsCB,
			NULL
		); //data to be passed to callback. In C++, it is frequently (void *)this

	if( err != paNoError ) {
		printf( &quot;PortAudio error: %s\n&quot;, Pa_GetErrorText( err ) );
		Pa_Terminate();
		return -30;
	}

	gALportAudio.samplesAmount = sampleBlockSize;

	// channel amount
	gALportAudio.channelAmount = inputChannels;

	// = SamplesAmount * ChannelAmount
	gALportAudio.bufferSampleAmount = gALportAudio.samplesAmount * gALportAudio.channelAmount;
	gALportAudio.bufferSize = gALportAudio.samplesAmount * gALportAudio.channelAmount * sizeof(float);

	gALportAudio.pIB = malloc(gALportAudio.bufferSize);
	gALportAudio.pOB = malloc(gALportAudio.bufferSize);
	for (i = 0; i &lt; gALportAudio.bufferSampleAmount; i++) {
		gALportAudio.pIB[i] = 0.0f;
		gALportAudio.pOB[i] = 0.0f;
	}

	err = Pa_StartStream( gALportAudio.as);
	if( err != paNoError ) {
		return -40;
	}

	return 0;
}

//! closes the port audio lib
int ALportAudio_close () {

	Pa_StopStream( gALportAudio.as);
	Pa_CloseStream( gALportAudio.as);
	Pa_Terminate();

	free(gALportAudio.pIB);
	free(gALportAudio.pOB);

	return 0;
}

//! reads samples
int ALportAudio_readSamples (int channel, float * pB, int amount, int waitForSamples) {
	float * pSrc;
	unsigned int i;

	if (waitForSamples) {
		ALportAudio_WaitForNewSamples();
	}

	// get the inputs
	pSrc = gALportAudio.pIB;
	pSrc += channel;

	if (amount &gt; gALportAudio.samplesAmount) {
		amount = gALportAudio.samplesAmount;
	}

	for (i = 0; i &lt; amount; i++) {
		*pB = *pSrc;
		pB++;
		pSrc += gALportAudio.channelAmount;
	}

	return 0;
}

//! write samples
int ALportAudio_writeSamples (int channel, float * pB, int amount, int waitForSamples) {
	float * pDest;
	unsigned int i;

	if (waitForSamples) {
		ALportAudio_WaitForNewSamples();
	}

	// get the inputs
	pDest = gALportAudio.pOB;
	pDest += channel;

	if (amount &gt; gALportAudio.samplesAmount) {
		amount = gALportAudio.samplesAmount;
	}

	for (i = 0; i &lt; amount; i++) {
		*pDest = *pB;
		pB++;
		pDest += gALportAudio.channelAmount;
	}

	return 0;
}

// prints all devices
void ALportAudio_printDevices () {
	int numDevices, i;
	const PaDeviceInfo *deviceInfo;

	numDevices = Pa_GetDeviceCount();
	if( numDevices &lt; 0 ) {
		return;
	}
	int defInp = Pa_GetDefaultInputDevice();
	int defOutp = Pa_GetDefaultOutputDevice();

	printf(&quot;Port Audio Devices:&quot;);
	for(i=0;i&lt;numDevices; i++) {
		deviceInfo = Pa_GetDeviceInfo(i);
		printf (&quot;\ndevice index: %i\n&quot;, i);
		printf (&quot;- struct version: %i\n&quot;, deviceInfo-&gt;structVersion);
		printf (&quot;- name: \&quot;%s\&quot;\n&quot;, deviceInfo-&gt;name);
		printf (&quot;- host api index: %i\n&quot;, deviceInfo-&gt;hostApi);
		printf (&quot;- max input channels: %i\n&quot;, deviceInfo-&gt;maxInputChannels);
		printf (&quot;- max output channels: %i\n&quot;, deviceInfo-&gt;maxOutputChannels);
		printf (&quot;- default low input latency: %f\n&quot;, deviceInfo-&gt;defaultLowInputLatency);
		printf (&quot;- default low output latency: %f\n&quot;, deviceInfo-&gt;defaultLowOutputLatency);
		printf (&quot;- default high input latency: %f\n&quot;, deviceInfo-&gt;defaultHighInputLatency);
		printf (&quot;- default high output latency: %f\n&quot;, deviceInfo-&gt;defaultHighOutputLatency);
		printf (&quot;- sample rate: %f\n&quot;, deviceInfo-&gt;defaultSampleRate);
		if (i == defInp) {
			printf(&quot;&gt; default input device\n&quot;);
		}
		if (i == defOutp) {
			printf(&quot;&gt; default output device\n&quot;);
		}
	}
}

// finds a device by a given name
int ALportAudio_findDevice (const char * szName) {
	int numDevices, i;
	const PaDeviceInfo *deviceInfo;

	numDevices = Pa_GetDeviceCount();
	if( numDevices &lt; 0 ) {
		return -1;
	}

	for(i=0;i&lt;numDevices; i++) {
		deviceInfo = Pa_GetDeviceInfo(i);
		if (0 == strcmp(szName, deviceInfo-&gt;name)) return i;
	}
	return -2;
}
</Code><Code idCode="324">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================
void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer witch receives the samples
	TAPgenericRationalVector * pRV = (TAPgenericRationalVector *) pParams[1].fp_pD;
// parameter waitForNewFrame descr: if not zero the function waits for a new sample frame
	int waitForNewFrame = (int)pParams[2].fp_integer;

	ALportAudio_readSamples((int)pParams[0].fp_integer, pRV-&gt;pVal,pRV-&gt;num, waitForNewFrame);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="325">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================
void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPgenericRationalVector * pRV = (TAPgenericRationalVector *) pParams[1].fp_pD;

	ALportAudio_writeSamples((int)pParams[0].fp_integer, pRV-&gt;pVal,pRV-&gt;num, 0);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="326">// ===============================
// AP uuid = 13
// ===============================

#define SAMPLE_RATE (44100)
#define dSampleBufferSize (1024)
// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	int r;

	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	// setup the port audio interface
	r =ALportAudio_init();
	if (r) return r;
	r = ALportAudio_setupStreams(SAMPLE_RATE, 2, 2, 2, 2, dSampleBufferSize);
	if (r) return r;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// closes the port audio interface
	ALportAudio_close ();

	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pthread_mutex_init(&amp;pIP-&gt;gM, NULL);

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt;= pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);


	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pthread_mutex_init(&amp;pMS-&gt;gM, NULL);
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	// we go for shure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="327">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;RPi_DSP.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}


int main()
{
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) {
		printf(&quot;load program failed with %i&quot;,(int) rc);
		goto exit;
	}

	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="328">// ==========================================
// PiFace
// ==========================================

// -------------------------------
// I.) I2C Display Interface
// -------------------------------
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;linux/spi/spidev.h&gt;


#define dPiFace_WRITE_CMD 0
#define dPiFace_READ_CMD 1

// Register addresses
#define dPiFace_IODIRA 0x00  // I/O direction A
#define dPiFace_IODIRB 0x01  // I/O direction B
#define dPiFace_IPOLA 0x02  // I/O polarity A
#define dPiFace_IPOLB 0x03  // I/O polarity B
#define dPiFace_GPINTENA 0x04  // Interrupt enable A
#define dPiFace_GPINTENB 0x05  // Interrupt enable B
#define dPiFace_DEFVALA 0x06  // register default value A (interrupts)
#define dPiFace_DEFVALB 0x07  // register default value B (interrupts)
#define dPiFace_INTCONA 0x08  // Interrupt control A
#define dPiFace_INTCONB 0x09  // Interrupt control B
#define dPiFace_IOCON 0x0A  // I/O config (also 0x0B)
#define dPiFace_GPPUA 0x0C  // port A pullups
#define dPiFace_GPPUB 0x0D  // port B pullups
#define dPiFace_INTFA 0x0E  // Interrupt flag A (where the interrupt came from)
#define dPiFace_INTFB 0x0F  // Interrupt flag B
#define dPiFace_INTCAPA 0x10  // Interrupt capture A (value at interrupt is saved here)
#define dPiFace_INTCAPB 0x11  // Interrupt capture B
#define dPiFace_GPIOA 0x12  // port A
#define dPiFace_GPIOB 0x13  // port B
#define dPiFace_OLATA 0x14  // output latch A
#define dPiFace_OLATB 0x15  // output latch B

// I/O config
#define dPiFace_BANK_OFF 0x00  // addressing mode
#define dPiFace_BANK_ON 0x80
#define dPiFace_INT_MIRROR_ON 0x40  // Interrupt mirror (INTa|INTb)
#define dPiFace_INT_MIRROR_OFF 0x00
#define dPiFace_SEQOP_OFF 0x20  // incrementing address pointer
#define dPiFace_SEQOP_ON 0x00
#define dPiFace_DISSLW_ON 0x10  // slew rate
#define dPiFace_DISSLW_OFF 0x00
#define dPiFace_HAEN_ON 0x08  // hardware addressing
#define dPiFace_HAEN_OFF 0x00
#define dPiFace_ODR_ON 0x04  // open drain for interrupts
#define dPiFace_ODR_OFF 0x00
#define dPiFace_INTPOL_HIGH 0x02  // Interrupt polarity
#define dPiFace_INTPOL_LOW 0x00

#define dPiFace_GPIO_INTERRUPT_PIN 25

static const uint8_t PiFace_spi_mode = 0;
static const uint8_t PiFace_spi_bpw = 8; // bits per word
static const uint32_t PiFace_spi_speed = 10000000; // 10MHz
static const uint16_t PiFace_spi_delay = 0;
static const char * PiFace_spidev[2][2] = {
    {&quot;/dev/spidev0.0&quot;, &quot;/dev/spidev0.1&quot;},
    {&quot;/dev/spidev1.0&quot;, &quot;/dev/spidev1.1&quot;},
};

// epoll related vars
// static int epoll_is_initialised = 0;
static int PiFace_gpio_pin_fd = -1;
static int PiFace_epoll_fd = -1;
static struct epoll_event PiFace_epoll_ctl_events;
static struct epoll_event PiFace_mcp23s17_epoll_events;


// prototypes
static uint8_t PiFace_get_spi_control_byte(uint8_t rw_cmd, uint8_t hw_addr);
static int PiFace_init_epoll(void);


int PiFace_mcp23s17_open(int bus, int chip_select)
{
    int fd;
    // open
    if ((fd = open(PiFace_spidev[bus][chip_select], O_RDWR)) &lt; 0) {
        fprintf(stderr,
                &quot;mcp23s17_open: ERROR Could not open SPI device (%s).\n&quot;,
				PiFace_spidev[bus][chip_select]);
        return -1;
    }

    // initialise
    if (ioctl(fd, SPI_IOC_WR_MODE, &amp;PiFace_spi_mode) &lt; 0) {
        fprintf(stderr, &quot;mcp23s17_open: ERROR Could not set SPI mode.\n&quot;);
	close(fd);
        return -1;
    }
    if (ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &amp;PiFace_spi_bpw) &lt; 0) {
        fprintf(stderr,
                &quot;mcp23s17_open: ERROR Could not set SPI bits per word.\n&quot;);
	close(fd);
        return -1;
    }
    if (ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &amp;PiFace_spi_speed) &lt; 0) {
        fprintf(stderr, &quot;mcp23s17_open: ERROR Could not set SPI speed.\n&quot;);
	close(fd);
        return -1;
    }

    return fd;
}

uint8_t PiFace_mcp23s17_read_reg(uint8_t reg, uint8_t hw_addr, int fd)
{
    uint8_t control_byte = PiFace_get_spi_control_byte(dPiFace_READ_CMD, hw_addr);
    uint8_t tx_buf[3] = {control_byte, reg, 0};
    uint8_t rx_buf[sizeof tx_buf];

    struct spi_ioc_transfer spi;
    memset (&amp;spi, 0, sizeof(spi));
    spi.tx_buf = (unsigned long) tx_buf;
    spi.rx_buf = (unsigned long) rx_buf;
    spi.len = sizeof tx_buf;
    spi.delay_usecs = PiFace_spi_delay;
    spi.speed_hz = PiFace_spi_speed;
    spi.bits_per_word = PiFace_spi_bpw;

    // do the SPI transaction
    if ((ioctl(fd, SPI_IOC_MESSAGE(1), &amp;spi) &lt; 0)) {
        fprintf(stderr,
                &quot;mcp23s17_read_reg: There was a error during the SPI &quot;
                &quot;transaction.\n&quot;);
        return -1;
    }

    // return the data
    return rx_buf[2];
}

void PiFace_mcp23s17_write_reg(uint8_t data, uint8_t reg, uint8_t hw_addr, int fd)
{
    uint8_t control_byte = PiFace_get_spi_control_byte(dPiFace_WRITE_CMD, hw_addr);
    uint8_t tx_buf[3] = {control_byte, reg, data};
    uint8_t rx_buf[sizeof tx_buf];

    struct spi_ioc_transfer spi;
    memset (&amp;spi, 0, sizeof(spi));
    spi.tx_buf = (unsigned long) tx_buf;
    spi.rx_buf = (unsigned long) rx_buf;
    spi.len = sizeof tx_buf;
    spi.delay_usecs = PiFace_spi_delay;
    spi.speed_hz = PiFace_spi_speed;
    spi.bits_per_word = PiFace_spi_bpw;

    // do the SPI transaction
    if ((ioctl(fd, SPI_IOC_MESSAGE(1), &amp;spi) &lt; 0)) {
        fprintf(stderr,
                &quot;mcp23s17_write_reg: There was a error during the SPI &quot;
                &quot;transaction.\n&quot;);
    }
}

uint8_t PiFace_mcp23s17_read_bit(uint8_t bit_num,
                          uint8_t reg,
                          uint8_t hw_addr,
                          int fd)
{
    return (PiFace_mcp23s17_read_reg(reg, hw_addr, fd) &gt;&gt; bit_num) &amp; 1;
}

void PiFace_mcp23s17_write_bit(uint8_t data,
                        uint8_t bit_num,
                        uint8_t reg,
                        uint8_t hw_addr,
                        int fd)
{
    uint8_t reg_data = PiFace_mcp23s17_read_reg(reg, hw_addr, fd);
    if (data) {
        reg_data |= 1 &lt;&lt; bit_num; // set
    } else {
        reg_data &amp;= 0xff ^ (1 &lt;&lt; bit_num); // clear
    }
    return PiFace_mcp23s17_write_reg(reg_data, reg, hw_addr, fd);
}




int PiFace_mcp23s17_enable_interrupts()
{
    int fd, len;
    char str_gpio[3];
    char str_filenm[33];

    if ((fd = open(&quot;/sys/class/gpio/export&quot;, O_WRONLY)) &lt; 0)
        return -1;

    len = snprintf(str_gpio, sizeof(str_gpio), &quot;%d&quot;, dPiFace_GPIO_INTERRUPT_PIN);
    write(fd, str_gpio, len);
    close(fd);

    snprintf(str_filenm, sizeof(str_filenm), &quot;/sys/class/gpio/gpio%d/direction&quot;, dPiFace_GPIO_INTERRUPT_PIN);
    if ((fd = open(str_filenm, O_WRONLY)) &lt; 0)
        return -1;

    write(fd, &quot;in&quot;, 3);
    close(fd);

    snprintf(str_filenm, sizeof(str_filenm), &quot;/sys/class/gpio/gpio%d/edge&quot;, dPiFace_GPIO_INTERRUPT_PIN);
    if ((fd = open(str_filenm, O_WRONLY)) &lt; 0)
        return -1;

    write(fd, &quot;falling&quot;, 8);
    close(fd);

    return 0;
}

int PiFace_mcp23s17_disable_interrupts()
{
    int fd, len;
    char str_gpio[3];

    if ((fd = open(&quot;/sys/class/gpio/unexport&quot;, O_WRONLY)) &lt; 0)
        return -1;

    len = snprintf(str_gpio, sizeof(str_gpio), &quot;%d&quot;, dPiFace_GPIO_INTERRUPT_PIN);
    write(fd, str_gpio, len);
    close(fd);

    return 0;
}

int PiFace_mcp23s17_wait_for_interrupt(int timeout)
{
    int num_fds = -1;

    if (PiFace_epoll_fd &lt;= 0) {
        if (PiFace_init_epoll() != 0) {
            return -1;
        }
    }

    // Wait for user event
    num_fds = epoll_wait(PiFace_epoll_fd, &amp;PiFace_mcp23s17_epoll_events, 1, timeout);

    return num_fds;
}

static int PiFace_init_epoll(void)
{
    // calculate the GPIO pin's path
    char gpio_pin_filename[33];
    snprintf(gpio_pin_filename,
             sizeof(gpio_pin_filename),
             &quot;/sys/class/gpio/gpio%d/value&quot;,
			 dPiFace_GPIO_INTERRUPT_PIN);

    // if we haven't already, create the epoll and the GPIO pin fd's
    if(PiFace_epoll_fd &lt;= 0) {
    	PiFace_epoll_fd = epoll_create(1);
        if (PiFace_epoll_fd &lt;= 0) {
            fprintf(stderr,
                    &quot;mcp23s17_wait_for_interrupt: There was a error during &quot;
                    &quot;the epoll_create.\n&quot;
                    &quot;Error is %s (errno=%d)\n&quot;,
                    strerror(errno),
                    errno);
            return -1;
        }
        PiFace_gpio_pin_fd = open(gpio_pin_filename, O_RDONLY | O_NONBLOCK);
    }

    if(PiFace_gpio_pin_fd &lt;= 0) {
        // we haven't successfully opened the GPIO pin fd
        fprintf(stderr,
                &quot;mcp23s17_wait_for_interrupt: Can't open fd &lt;%s&gt; &lt;%d&gt;.\n&quot;
                &quot;Error is %s (errno=%d)\n&quot;,
                gpio_pin_filename,
				PiFace_gpio_pin_fd,
                strerror(errno),
                errno);
        return -1;
    } else {
        PiFace_epoll_ctl_events.events = EPOLLIN | EPOLLET;
        PiFace_epoll_ctl_events.data.fd = PiFace_gpio_pin_fd;

        if(epoll_ctl(PiFace_epoll_fd, EPOLL_CTL_ADD, PiFace_gpio_pin_fd, &amp;PiFace_epoll_ctl_events) != 0) {
            fprintf(stderr,
                    &quot;mcp23s17_wait_for_interrupt: There was a error &quot;
                    &quot;during the epoll_ctl EPOLL_CTL_ADD.\n&quot;);
            fprintf(stderr,
                    &quot;Error is %s (errno=%d)\n&quot;,
                    strerror(errno),
                    errno);
        }
        // Ignore GPIO Initial Event
        epoll_wait(PiFace_epoll_fd, &amp;PiFace_mcp23s17_epoll_events, 1, 10);
        return 0;
    }
}


/**
 * Returns an SPI control byte.
 *
 * The MCP23S17 is a slave SPI device. The slave address contains four
 * fixed bits (0b0100) and three user-defined hardware address bits
 * (if enabled via IOCON.HAEN; pins A2, A1 and A0) with the
 * read/write command bit filling out the rest of the control byte::
 *
 *     +--------------------+
 *     |0|1|0|0|A2|A1|A0|R/W|
 *     +--------------------+
 *     |fixed  |hw_addr |R/W|
 *     +--------------------+
 *     |7|6|5|4|3 |2 |1 | 0 |
 *     +--------------------+
 *
 */
static uint8_t PiFace_get_spi_control_byte(uint8_t rw_cmd, uint8_t hw_addr)
{
    hw_addr = (hw_addr &lt;&lt; 1) &amp; 0xE;
    rw_cmd &amp;= 1; // just 1 bit long
    return 0x40 | hw_addr | rw_cmd;
}


// -------------------------------
// II.) Pi Face Control and Display Interface
// -------------------------------

#define dPiFaceCAD_DELAY_PULSE_NS 1000 // 1us
#define dPiFaceCAD_DELAY_SETTLE_NS 40000 // 40us
#define dPiFaceCAD_DELAY_CLEAR_NS 2600000L // 2.6ms
#define dPiFaceCAD_DELAY_SETUP_0_NS 15000000L // 15ms
#define dPiFaceCAD_DELAY_SETUP_1_NS 5000000L // 5ms
#define dPiFaceCAD_DELAY_SETUP_2_NS 1000000L // 1ms

// mcp23s17 GPIOB to HD44780 pin map
#define dPiFaceCAD_PIN_D4 0
#define dPiFaceCAD_PIN_D5 1
#define dPiFaceCAD_PIN_D6 2
#define dPiFaceCAD_PIN_D7 3
#define dPiFaceCAD_PIN_ENABLE 4
#define dPiFaceCAD_PIN_RW 5
#define dPiFaceCAD_PIN_RS 6
#define dPiFaceCAD_PIN_BACKLIGHT 7

// commands
#define dPiFaceCAD_LCD_CLEARDISPLAY 0x01
#define dPiFaceCAD_LCD_RETURNHOME 0x02
#define dPiFaceCAD_LCD_ENTRYMODESET 0x04
#define dPiFaceCAD_LCD_DISPLAYCONTROL 0x08
#define dPiFaceCAD_LCD_CURSORSHIFT 0x10
#define dPiFaceCAD_LCD_FUNCTIONSET 0x20
#define dPiFaceCAD_LCD_SETCGRAMADDR 0x40
#define dPiFaceCAD_LCD_SETDDRAMADDR 0x80
#define dPiFaceCAD_LCD_NEWLINE 0xC0

// flags for display entry mode
#define dPiFaceCAD_LCD_ENTRYRIGHT 0x00
#define dPiFaceCAD_LCD_ENTRYLEFT 0x02
#define dPiFaceCAD_LCD_ENTRYSHIFTINCREMENT 0x01
#define dPiFaceCAD_LCD_ENTRYSHIFTDECREMENT 0x00

// flags for display on/off control
#define dPiFaceCAD_LCD_DISPLAYON 0x04
#define dPiFaceCAD_LCD_DISPLAYOFF 0x00
#define dPiFaceCAD_LCD_CURSORON 0x02
#define dPiFaceCAD_LCD_CURSOROFF 0x00
#define dPiFaceCAD_LCD_BLINKON 0x01
#define dPiFaceCAD_LCD_BLINKOFF 0x00

// flags for display/cursor shift
#define dPiFaceCAD_LCD_DISPLAYMOVE 0x08
#define dPiFaceCAD_LCD_CURSORMOVE 0x00
#define dPiFaceCAD_LCD_MOVERIGHT 0x04
#define dPiFaceCAD_LCD_MOVELEFT 0x00

// flags for function set
#define dPiFaceCAD_LCD_8BITMODE 0x10
#define dPiFaceCAD_LCD_4BITMODE 0x00
#define dPiFaceCAD_LCD_2LINE 0x08
#define dPiFaceCAD_LCD_1LINE 0x00
#define dPiFaceCAD_LCD_5X10DOTS 0x04
#define dPiFaceCAD_LCD_5X8DOTS 0x00

#define dPiFaceCAD_LCD_MAX_LINES 2
#define dPiFaceCAD_LCD_WIDTH 16
#define dPiFaceCAD_LCD_RAM_WIDTH 80 // RAM is 80 wide, split over two lines

static const uint8_t PiFaceCAD_LCD_ROW_OFFSETS[] = {0, 0x40};

// PiFace Control and Display is always at /dev/spidev0.1, hw_addr = 0
static const int PiFaceCAD_LCD_bus = 0, PiFaceCAD_LCD_chip_select = 1, PiFaceCAD_LCD_hw_addr = 0;
static int PiFaceCAD_LCD_mcp23s17_fd = 0; // MCP23S17 SPI file descriptor

static const int PiFaceCAD_LCD_SWITCH_PORT =  dPiFace_GPIOA;
static const int PiFaceCAD_LCD_PORT = dPiFace_GPIOB;

// current lcd state
// static int curcol = 0, currow = 0;
static uint8_t PiFaceCAD_LCD_cur_address = 0;
static uint8_t PiFaceCAD_LCD_cur_entry_mode = 0;
static uint8_t PiFaceCAD_LCD_cur_function_set = 0;
static uint8_t PiFaceCAD_LCD_cur_display_control = 0;


// static function definitions
uint8_t PiFaceCAD_colrow2address(uint8_t col, uint8_t row);
uint8_t PiFaceCAD_address2col(uint8_t address);
uint8_t PiFaceCAD_address2row(uint8_t address);

static void PiFaceCAD_sleep_ns(long nanoseconds);
static int PiFaceCAD_max(int a, int b);
static int PiFaceCAD_min(int a, int b);

// pre defines
int pifacecad_open(void);
int pifacecad_open_noinit(void);
void pifacecad_close(void);
void pifacecad_lcd_init(void);
uint8_t pifacecad_read_switches(void);
uint8_t pifacecad_read_switch(uint8_t switch_num);
uint8_t pifacecad_lcd_write(const char * message);
uint8_t pifacecad_lcd_set_cursor(uint8_t col, uint8_t row);
void pifacecad_lcd_set_cursor_address(uint8_t address);
uint8_t pifacecad_lcd_get_cursor_address(void);
void pifacecad_lcd_clear(void);
void pifacecad_lcd_home(void);
void pifacecad_lcd_display_on(void);
void pifacecad_lcd_display_off(void);
void pifacecad_lcd_blink_on(void);
void pifacecad_lcd_blink_off(void);
void pifacecad_lcd_cursor_on(void);
void pifacecad_lcd_cursor_off(void);
void pifacecad_lcd_backlight_on(void);
void pifacecad_lcd_backlight_off(void);
void pifacecad_lcd_move_left(void);
void pifacecad_lcd_move_right(void);
void pifacecad_lcd_left_to_right(void);
void pifacecad_lcd_right_to_left(void);
void pifacecad_lcd_autoscroll_on(void);
void pifacecad_lcd_autoscroll_off(void);
void pifacecad_lcd_write_custom_bitmap(uint8_t location);
void pifacecad_lcd_store_custom_bitmap(uint8_t location, uint8_t bitmap[]);
void pifacecad_lcd_send_command(uint8_t command);
void pifacecad_lcd_send_data(uint8_t data);
void pifacecad_lcd_send_byte(uint8_t byte);
void pifacecad_lcd_set_rs(uint8_t state);
void pifacecad_lcd_set_rw(uint8_t state);
void pifacecad_lcd_set_enable(uint8_t state);
void pifacecad_lcd_set_backlight(uint8_t state);
void pifacecad_lcd_pulse_enable(void);

// functions

int pifacecad_open_noinit(void)
{
    // All PiFace Digital are connected to the same SPI bus, only need 1 fd.
    if ((PiFaceCAD_LCD_mcp23s17_fd = PiFace_mcp23s17_open(PiFaceCAD_LCD_bus, PiFaceCAD_LCD_chip_select)) &lt; 0) {
        return -1;
    }
    return PiFaceCAD_LCD_mcp23s17_fd; // returns the fd in case user wants to use it
}

int pifacecad_open(void)
{
    pifacecad_open_noinit();

    // Set IO config
    const uint8_t ioconfig = dPiFace_BANK_OFF | \
    						dPiFace_INT_MIRROR_OFF | \
							dPiFace_SEQOP_OFF | \
							dPiFace_DISSLW_OFF | \
							dPiFace_HAEN_ON | \
							dPiFace_ODR_OFF | \
							dPiFace_INTPOL_LOW;
    PiFace_mcp23s17_write_reg(ioconfig, dPiFace_IOCON, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);

    // Set GPIO Port A as inputs (switches)
    PiFace_mcp23s17_write_reg(0xff, dPiFace_IODIRA, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    PiFace_mcp23s17_write_reg(0xff, dPiFace_GPPUA, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);

    // Set GPIO Port B as outputs (connected to HD44780)
    PiFace_mcp23s17_write_reg(0x00, dPiFace_IODIRB, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);

    // enable interrupts
    PiFace_mcp23s17_write_reg(0xFF, dPiFace_GPINTENA, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);

    pifacecad_lcd_init();

    return PiFaceCAD_LCD_mcp23s17_fd;
}

void pifacecad_close(void)
{
    // disable interrupts if enabled
    const uint8_t intenb = PiFace_mcp23s17_read_reg(dPiFace_GPINTENA, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    if (intenb) {
        PiFace_mcp23s17_write_reg(0, dPiFace_GPINTENA, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
        // now do some other interrupt stuff...
        // TODO
    }
    close(PiFaceCAD_LCD_mcp23s17_fd);
}

void pifacecad_lcd_init(void)
{
    // setup sequence
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_SETUP_0_NS);
    PiFace_mcp23s17_write_reg(0x3, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    pifacecad_lcd_pulse_enable();

    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_SETUP_1_NS);
    PiFace_mcp23s17_write_reg(0x3, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    pifacecad_lcd_pulse_enable();

    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_SETUP_2_NS);
    PiFace_mcp23s17_write_reg(0x3, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    pifacecad_lcd_pulse_enable();

    PiFace_mcp23s17_write_reg(0x2, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    pifacecad_lcd_pulse_enable();

    PiFaceCAD_LCD_cur_function_set |= dPiFaceCAD_LCD_4BITMODE | dPiFaceCAD_LCD_2LINE | dPiFaceCAD_LCD_5X8DOTS;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_FUNCTIONSET |  PiFaceCAD_LCD_cur_function_set);

    PiFaceCAD_LCD_cur_display_control |= dPiFaceCAD_LCD_DISPLAYOFF | dPiFaceCAD_LCD_CURSOROFF | dPiFaceCAD_LCD_BLINKOFF;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);

    pifacecad_lcd_clear();

    PiFaceCAD_LCD_cur_entry_mode |= dPiFaceCAD_LCD_ENTRYLEFT | dPiFaceCAD_LCD_ENTRYSHIFTDECREMENT;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_ENTRYMODESET | PiFaceCAD_LCD_cur_entry_mode);

    PiFaceCAD_LCD_cur_display_control |= dPiFaceCAD_LCD_DISPLAYON | dPiFaceCAD_LCD_CURSORON | dPiFaceCAD_LCD_BLINKON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}


uint8_t pifacecad_read_switches(void)
{
    return PiFace_mcp23s17_read_reg(PiFaceCAD_LCD_SWITCH_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
}

uint8_t pifacecad_read_switch(uint8_t switch_num)
{
    return (PiFace_mcp23s17_read_reg(PiFaceCAD_LCD_SWITCH_PORT,
                              PiFaceCAD_LCD_hw_addr,
                              PiFaceCAD_LCD_mcp23s17_fd) &gt;&gt; switch_num) &amp; 1;
}


uint8_t pifacecad_lcd_write(const char * message)
{
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_SETDDRAMADDR | PiFaceCAD_LCD_cur_address);

    // for each character in the message
    while (*message) {
        if (*message == '\n') {
            pifacecad_lcd_set_cursor(0, 1);
        } else {
            pifacecad_lcd_send_data(*message);
            PiFaceCAD_LCD_cur_address++;
        }
        message++;
    }
    return PiFaceCAD_LCD_cur_address;
}

uint8_t pifacecad_lcd_set_cursor(uint8_t col, uint8_t row)
{
    col = PiFaceCAD_max(0, PiFaceCAD_min(col, (dPiFaceCAD_LCD_RAM_WIDTH / 2) - 1));
    row = PiFaceCAD_max(0, PiFaceCAD_min(row, dPiFaceCAD_LCD_MAX_LINES - 1));
    pifacecad_lcd_set_cursor_address(PiFaceCAD_colrow2address(col, row));
    return PiFaceCAD_LCD_cur_address;
}

void pifacecad_lcd_set_cursor_address(uint8_t address)
{
    PiFaceCAD_LCD_cur_address = address % dPiFaceCAD_LCD_RAM_WIDTH;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_SETDDRAMADDR | PiFaceCAD_LCD_cur_address);
}

uint8_t pifacecad_lcd_get_cursor_address(void)
{
    return PiFaceCAD_LCD_cur_address;
}

/********************************************************************
 *  Modified 2014/06/26 John Wulff &lt;immediatec@gmail.com&gt;
 *  2.6 ms delay after LCD_CLEARDISPLAY
 *
 *  Execution time of the &quot;Clear display&quot; command is not specified
 *  in the HITACHI date sheet HD44780U, page 24. (Probably a misprint)
 *  It was measured and found to be 1.6 to 2.4 ms +- 0.2 ms
 *******************************************************************/

void pifacecad_lcd_clear(void)
{
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_CLEARDISPLAY);
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_CLEAR_NS);		/* 2.6 ms  - added JW 2014/06/26 */
    PiFaceCAD_LCD_cur_address = 0;
}

/********************************************************************
 *  2.6 ms delay after LCD_RETURNHOME
 *
 *  Execution time of the &quot;Return home&quot; command is specified as 1.52 ms
 *  in the HITACHI date sheet HD44780U, page 24. (Probably meant for
 *  &quot;Clear display&quot;)
 *  It was measured and found to be less than 0.8 ms and is probably
 *  37 us like all other commands.  To be safe the delay was added here
 *  also as it hardly influences performance.
 *******************************************************************/

void pifacecad_lcd_home(void)
{
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_RETURNHOME);
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_CLEAR_NS);		/* 2.6 ms  - added JW 2014/06/26 */
    PiFaceCAD_LCD_cur_address = 0;
}


void pifacecad_lcd_display_on(void)
{
    PiFaceCAD_LCD_cur_display_control |= dPiFaceCAD_LCD_DISPLAYON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_display_off(void)
{
    PiFaceCAD_LCD_cur_display_control &amp;= 0xff ^ dPiFaceCAD_LCD_DISPLAYON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_blink_on(void)
{
    PiFaceCAD_LCD_cur_display_control |= dPiFaceCAD_LCD_BLINKON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_blink_off(void)
{
    PiFaceCAD_LCD_cur_display_control &amp;= 0xff ^ dPiFaceCAD_LCD_BLINKON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_cursor_on(void)
{
    PiFaceCAD_LCD_cur_display_control |= dPiFaceCAD_LCD_CURSORON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_cursor_off(void)
{
    PiFaceCAD_LCD_cur_display_control &amp;= 0xff ^ dPiFaceCAD_LCD_CURSORON;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_DISPLAYCONTROL | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_backlight_on(void)
{
    pifacecad_lcd_set_backlight(1);
}

void pifacecad_lcd_backlight_off(void)
{
    pifacecad_lcd_set_backlight(0);
}

void pifacecad_lcd_move_left(void)
{
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_CURSORSHIFT | \
                               dPiFaceCAD_LCD_DISPLAYMOVE | \
                               dPiFaceCAD_LCD_MOVELEFT);
}

void pifacecad_lcd_move_right(void)
{
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_CURSORSHIFT | \
                               dPiFaceCAD_LCD_DISPLAYMOVE | \
                               dPiFaceCAD_LCD_MOVERIGHT);
}

void pifacecad_lcd_left_to_right(void)
{
    PiFaceCAD_LCD_cur_entry_mode |= dPiFaceCAD_LCD_ENTRYLEFT;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_ENTRYMODESET | PiFaceCAD_LCD_cur_entry_mode);
}

void pifacecad_lcd_right_to_left(void)
{
    PiFaceCAD_LCD_cur_entry_mode &amp;= 0xff ^ dPiFaceCAD_LCD_ENTRYLEFT;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_ENTRYMODESET | PiFaceCAD_LCD_cur_entry_mode);
}

// This will 'right justify' text from the cursor
void pifacecad_lcd_autoscroll_on(void)
{
    PiFaceCAD_LCD_cur_display_control |= dPiFaceCAD_LCD_ENTRYSHIFTINCREMENT;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_ENTRYMODESET | PiFaceCAD_LCD_cur_display_control);
}

// This will 'left justify' text from the cursor
void pifacecad_lcd_autoscroll_off(void)
{
    PiFaceCAD_LCD_cur_display_control &amp;= 0xff ^ dPiFaceCAD_LCD_ENTRYSHIFTINCREMENT;
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_ENTRYMODESET | PiFaceCAD_LCD_cur_display_control);
}

void pifacecad_lcd_write_custom_bitmap(uint8_t location)
{
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_SETDDRAMADDR | PiFaceCAD_LCD_cur_address);
    pifacecad_lcd_send_data(location);
    PiFaceCAD_LCD_cur_address++;
}

void pifacecad_lcd_store_custom_bitmap(uint8_t location, uint8_t bitmap[])
{
    location &amp;= 0x7; // we only have 8 locations 0-7
    pifacecad_lcd_send_command(dPiFaceCAD_LCD_SETCGRAMADDR | (location &lt;&lt; 3));
    int i;
    for (i = 0; i &lt; 8; i++) {
        pifacecad_lcd_send_data(bitmap[i]);
    }
}

void pifacecad_lcd_send_command(uint8_t command)
{
    pifacecad_lcd_set_rs(0);
    pifacecad_lcd_send_byte(command);
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_SETTLE_NS);
}

void pifacecad_lcd_send_data(uint8_t data)
{
    pifacecad_lcd_set_rs(1);
    pifacecad_lcd_send_byte(data);
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_SETTLE_NS);
}

void pifacecad_lcd_send_byte(uint8_t b)
{
    // get current lcd port state and clear the data bits
    uint8_t current_state = PiFace_mcp23s17_read_reg(PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    current_state &amp;= 0xF0; // clear the data bits

    // send first nibble (0bXXXX0000)
    uint8_t new_byte = current_state | ((b &gt;&gt; 4) &amp; 0xF);  // set nibble
    PiFace_mcp23s17_write_reg(new_byte, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    pifacecad_lcd_pulse_enable();

    // send second nibble (0b0000XXXX)
    new_byte = current_state | (b &amp; 0xF);  // set nibble
    PiFace_mcp23s17_write_reg(new_byte, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
    pifacecad_lcd_pulse_enable();
}

void pifacecad_lcd_set_rs(uint8_t state)
{
    PiFace_mcp23s17_write_bit(state, dPiFaceCAD_PIN_RS, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
}

void pifacecad_lcd_set_rw(uint8_t state)
{
    PiFace_mcp23s17_write_bit(state, dPiFaceCAD_PIN_RW, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
}

void pifacecad_lcd_set_enable(uint8_t state)
{
    PiFace_mcp23s17_write_bit(state, dPiFaceCAD_PIN_ENABLE, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
}

void pifacecad_lcd_set_backlight(uint8_t state)
{
    PiFace_mcp23s17_write_bit(state, dPiFaceCAD_PIN_BACKLIGHT, PiFaceCAD_LCD_PORT, PiFaceCAD_LCD_hw_addr, PiFaceCAD_LCD_mcp23s17_fd);
}

/* pulse the enable pin */
void pifacecad_lcd_pulse_enable(void)
{
    pifacecad_lcd_set_enable(1);
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_PULSE_NS);
    pifacecad_lcd_set_enable(0);
    PiFaceCAD_sleep_ns(dPiFaceCAD_DELAY_PULSE_NS);
}

// Helper

uint8_t PiFaceCAD_colrow2address(uint8_t col, uint8_t row)
{
    return col + PiFaceCAD_LCD_ROW_OFFSETS[row];
}

uint8_t PiFaceCAD_address2col(uint8_t address)
{
    return address % PiFaceCAD_LCD_ROW_OFFSETS[1];
}

uint8_t PiFaceCAD_address2row(uint8_t address)
{
    return address &gt; PiFaceCAD_LCD_ROW_OFFSETS[1] ? 1 : 0;
}

static void PiFaceCAD_sleep_ns(long nanoseconds)
{
    struct timespec time0, time1;
    time0.tv_sec = 0;
    time0.tv_nsec = nanoseconds;
    nanosleep(&amp;time0 , &amp;time1);
}

static int PiFaceCAD_max(int a, int b)
{
    return a &gt; b ? a : b;
}

static int PiFaceCAD_min(int a, int b)
{
    return a &lt; b ? a : b;
}

// ------------------------------------------
// high level functions
// ------------------------------------------

enum ePiFaceButtonState {
	ePiFaceButtonState_up	= 0,
	ePiFaceButtonState_down = 1
};

#define gPiFaceButtonAmount (8)
#define gPiFaceWaitTime (200)

volatile int gPiFaceButtonPressCounter[gPiFaceButtonAmount];
volatile int gPiFaceExitFlag = 0;
pthread_t	gPiFaceThreadHandle;


void * PiFaceButtonChecker(void * pParams) {
	int buttons, mask;
	int input[gPiFaceButtonAmount];
	int inputOld[gPiFaceButtonAmount];
	int i;

	memset(input, 0, sizeof(input));
	memset(inputOld, 0, sizeof(inputOld));

	for (;;) {
		buttons = (int) pifacecad_read_switches();
		mask = 1;
		for (i = 0; i &lt; gPiFaceButtonAmount; i++) {
			input[i] = (0 == (buttons &amp; mask)) ? 0 : 1;
			if ((inputOld[i] == 0) &amp;&amp; (input[i] == 1)) {
				gPiFaceButtonPressCounter[i]++;
			}
			mask &lt;&lt;= 1;
		}
		memcpy(inputOld,input, sizeof(inputOld));
		usleep(gPiFaceWaitTime);
		if (gPiFaceExitFlag) {
			return NULL;
		}
	}
	return NULL;
}

int PiFace_init() {
	int i;

	for (i = 0; i &lt; gPiFaceButtonAmount; i++) {
		gPiFaceButtonPressCounter[i] = 0;
	}

	pifacecad_open();
	pifacecad_lcd_backlight_on();
	return pthread_create(&amp;gPiFaceThreadHandle, NULL, PiFaceButtonChecker, NULL);
}

void PiFace_close() {
	pifacecad_close();
	gPiFaceExitFlag = 1;
	pthread_join(gPiFaceThreadHandle, NULL);
}

int PiFace_isButtonDown (int indx) {
	if (gPiFaceButtonPressCounter[indx] &gt; 0) {
		gPiFaceButtonPressCounter[indx]--;
		return 1;
	}
	return 0;
}
</Code><Code idCode="329">// ===============================
// variable implementation for panel (varID=100)
// ===============================

// element structure for panel
typedef struct SApVar_ele_panel {
} TApVar_ele_panel;

// vector structure for panel
typedef struct SApVar_vec_panel {
    TApVar_ele_panel * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_panel;


// updates a variable the AP
int HALimpl_100_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for panel
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_panel * pV =(TApVar_vec_panel *) pVarData;
	TApVar_ele_panel * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a panel vector
		TApVar_vec_panel * pV = (TApVar_vec_panel *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for panel
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_panel)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_100_create ( unsigned int numberOfElements ) {
 // create a new panel vector
	TApVar_vec_panel * pV;
	 
	pV = malloc(sizeof(TApVar_vec_panel));
	if (!pV) {
	    return NULL;
	}
	// create the elements for panel
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_panel)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for panel
	TApVar_vec_panel * pV =(TApVar_vec_panel *) pVarData;
	TApVar_ele_panel * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_100_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_100_delete ( void * pVarData ) {
 // frees a panel vector
	TApVar_vec_panel * pV = (TApVar_vec_panel *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="330">// ===============================
// variable implementation for button (varID=101)
// ===============================

// element structure for button
typedef struct SApVar_ele_button {
	int index;
} TApVar_ele_button;

// vector structure for button
typedef struct SApVar_vec_button {
    TApVar_ele_button * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_button;


// updates a variable the AP
int HALimpl_101_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for button
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_button * pV =(TApVar_vec_button *) pVarData;
	TApVar_ele_button * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a button vector
		TApVar_vec_button * pV = (TApVar_vec_button *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for button
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_button)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_101_create ( unsigned int numberOfElements ) {
 // create a new button vector
	TApVar_vec_button * pV;
	 
	pV = malloc(sizeof(TApVar_vec_button));
	if (!pV) {
	    return NULL;
	}
	// create the elements for button
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_button)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_101_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for button
	TApVar_vec_button * pV =(TApVar_vec_button *) pVarData;
	TApVar_ele_button * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_101_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_101_delete ( void * pVarData ) {
 // frees a button vector
	TApVar_vec_button * pV = (TApVar_vec_button *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="331">// ===============================
// variable implementation for led (varID=102)
// ===============================

// element structure for led
typedef struct SApVar_ele_led {
} TApVar_ele_led;

// vector structure for led
typedef struct SApVar_vec_led {
    TApVar_ele_led * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_led;


// updates a variable the AP
int HALimpl_102_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for led
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_led * pV =(TApVar_vec_led *) pVarData;
	TApVar_ele_led * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a led vector
		TApVar_vec_led * pV = (TApVar_vec_led *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for led
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_led)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_102_create ( unsigned int numberOfElements ) {
 // create a new led vector
	TApVar_vec_led * pV;
	 
	pV = malloc(sizeof(TApVar_vec_led));
	if (!pV) {
	    return NULL;
	}
	// create the elements for led
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_led)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for led
	TApVar_vec_led * pV =(TApVar_vec_led *) pVarData;
	TApVar_ele_led * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_102_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_102_delete ( void * pVarData ) {
 // frees a led vector
	TApVar_vec_led * pV = (TApVar_vec_led *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="332">// ===============================
// variable implementation for display (varID=103)
// ===============================

// element structure for display
typedef struct SApVar_ele_display {
} TApVar_ele_display;

// vector structure for display
typedef struct SApVar_vec_display {
    TApVar_ele_display * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_display;


// updates a variable the AP
int HALimpl_103_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for display
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_display * pV =(TApVar_vec_display *) pVarData;
	TApVar_ele_display * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a display vector
		TApVar_vec_display * pV = (TApVar_vec_display *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for display
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_display)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_103_create ( unsigned int numberOfElements ) {
 // create a new display vector
	TApVar_vec_display * pV;
	 
	pV = malloc(sizeof(TApVar_vec_display));
	if (!pV) {
	    return NULL;
	}
	// create the elements for display
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_display)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for display
	TApVar_vec_display * pV =(TApVar_vec_display *) pVarData;
	TApVar_ele_display * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_103_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_103_delete ( void * pVarData ) {
 // frees a display vector
	TApVar_vec_display * pV = (TApVar_vec_display *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="333">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================
void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="334">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================
void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="335">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================
void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int uiUUID = (int) pParams[0].fp_integer;
// parameter b descr: button
	TApVar_vec_button * pVB = pParams[1].fp_pD;
// parameter bIndex descr: button index
	int bIndex = (int) pParams[2].fp_integer;

	if ((uiUUID &lt; 1) || (uiUUID &gt; 8)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -202;
		return;
	}
	pVB-&gt;pFE[bIndex].index = uiUUID-1;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="336">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================
void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t uiUUID = pParams[0].fp_integer;
// parameter d descr: display
	void * d = pParams[1].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[2].fp_integer;
// parameter p descr: panel
	void * p = pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="337">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================
void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t uiUUID = pParams[0].fp_integer;
// parameter l descr: LED
	void * l = pParams[1].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[2].fp_integer;
// parameter p descr: panel
	void * p = pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="338">// ===============================
// function implementation for uiCheckButtonPressed(var id = 210)
// description: if the button was pressed the CF is set
// ===============================
void HALfunc_ID210_uiCheckButtonPressed(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter b descr: button
	TApVar_vec_button * vb = pParams[0].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[1].fp_integer;
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;CF =  PiFace_isButtonDown(vb-&gt;pFE[bIndex].index);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="339">// ===============================
// function implementation for uiSetLED(var id = 211)
// description: set the LED state
// ===============================
void HALfunc_ID211_uiSetLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter l descr: LED
	void * l = pParams[0].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[1].fp_integer;
// parameter onFlag descr: if the flag is not zero the LED is turned on
	int32_t onFlag = pParams[2].fp_integer;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="340">// ===============================
// function implementation for uiSetDisplay(var id = 212)
// description: set the text of a display
// ===============================
void HALfunc_ID212_uiSetDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	void * d = pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter s descr: the string
	TAPstringVector * pSV = pParams[2].fp_pD;
// parameter iString descr: index of the string at the array
	int32_t iString = pParams[3].fp_integer;

	pifacecad_lcd_clear();
	pifacecad_lcd_write(pSV-&gt;sv[iString].szTxt);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="341">// ===============================
// AP uuid = 14
// ===============================


// the include for sem_t
#include &lt;semaphore.h&gt;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	PiFace_init();

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);

	PiFace_close();
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pthread_mutex_init(&amp;pIP-&gt;gM, NULL);

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt;= pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);


	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pthread_mutex_init(&amp;pMS-&gt;gM, NULL);
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	// we go for shure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="342">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dWithDebugInterface
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;RPi_UI.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface

#include &quot;RPi_UI_VarInfo.h&quot;
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

void printCPUregisters() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	printf (&quot;\tCF = %i\n\tEF = %i&quot;,(int)pCPU-&gt;CF,(int)pCPU-&gt;EF);
}

#endif

void ui () {
	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}



int main()
{
	pthread_t		IPthread;
	pthread_t		MSthread;

	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	if (rc) goto exit;

	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="343">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;ALstringTest.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface

// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}



int main()
{
	pthread_t		IPthread;
	pthread_t		MSthread;

	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	if (rc) goto exit;

	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="344">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================
void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	void * s = pParams[0].fp_pD;
// parameter i descr: index of the string at the array
	int32_t i = pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int32_t p = pParams[2].fp_integer;
// parameter v1 descr: chars coded as 4 byte integer
	uint32_t v1 = pParams[3].fp_raw;
// parameter v2 descr: chars coded as 4 byte integer
	uint32_t v2 = pParams[4].fp_raw;
// parameter v3 descr: chars coded as 4 byte integer
	uint32_t v3 = pParams[5].fp_raw;
// parameter v4 descr: chars coded as 4 byte integer
	uint32_t v4 = pParams[6].fp_raw;
};
</Code><Code idCode="345">// ===============================
// AP uuid = 15
// ===============================

#define SAMPLE_RATE (44100)
#define dSampleBufferSize (1024)

// the include for sem_t
#include &lt;semaphore.h&gt;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	int r, idDev;

	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	// setup the port audio interface
	r =ALportAudio_init();
	if (r) return r;

	// show the availble devices
	ALportAudio_printDevices();

	// looking for the USB sound card
	printf(&quot;looking for device \&quot;USB Audio CODEC: USB Audio (hw:1,0)\&quot;...&quot;);
	idDev = ALportAudio_findDevice(&quot;USB Audio CODEC: USB Audio (hw:1,0)&quot;);

	r = ALportAudio_setupStreams(SAMPLE_RATE, 2, idDev, 2, idDev, dSampleBufferSize);
	if (r) return r;
	
	// setup the pi face
	PiFace_init();

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	TX_logout(pAP);
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);

	// closes the port audio
	ALportAudio_close ();
	// closes the PIFace
	PiFace_close();
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pthread_mutex_init(&amp;pIP-&gt;gM, NULL);

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt;= pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// get interpreter state
int32_t APInterpreterGetState (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	return (int32_t) pIP-&gt;state;
}


// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;numberOfElements, msgEndian);


	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// gets the CPU from the IP
TAPInterpreterCPU * APInterpreterGetCPUref (TAPInterpreter IP) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;cpu);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pthread_mutex_init(&amp;pMS-&gt;gM, NULL);
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	// we go for shure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="346">// ===============================
// startup code for the audio processor
// ===============================

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;RPi.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	TAPNode * pN;

	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'p':
				printf(&quot;own node id: %i\nnode list:\n&quot;, (int) AP.nodeID);
				pN = AP.pNodeList;
				while(pN) {
					printf(&quot;%i\n&quot;, (int)pN-&gt;nodeID);
					pN = pN-&gt;pNext;
				}
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\np-show nodes\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}



int main()
{
	pthread_t		IPthread;
	pthread_t		MSthread;

	enum eMsgDrvIDs {
		eMsgDrvID_TCP = 0,
		eMsgDrvID_amount = 1
	};

	TAPMsgDrv		msgSysDrv[eMsgDrvID_amount];
	int rc;

	// =======================
	// TCP
	// =======================
	
	extern int drv_6_feedRecvStateM (uint8_t * pData, size_t amount);

	if (TCPcontrolInitFromStdIn(drv_6_feedRecvStateM, 4096, 500)) {
		fprintf(stderr, &quot;init TCVP driver failed!\n&quot;);
		return EXIT_FAILURE;
	}
	APdriver_6_init (&amp;(msgSysDrv[eMsgDrvID_TCP]));

	// =======================
	srand(time(NULL));

	rc = APinit(&amp;AP,(TAPNodeID)rand(),msgSysDrv,eMsgDrvID_amount,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	if (rc) {
		fprintf(stderr, &quot;loading program failed with code %i\n&quot;, rc);
		goto exit;
	}

	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:

	APdelete(&amp;AP);

	TCPcontrolClose();

	return EXIT_SUCCESS;
}
</Code><Code idCode="347">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================
void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	void * x = pParams[0].fp_pD;
// parameter bqa descr: biquad cascade
	void * bqa = pParams[1].fp_pD;
// parameter y descr: output
	void * y = pParams[2].fp_pD;
};
</Code><Code idCode="348">// ===============================
// function implementation for initDelay(var id = 151)
// description: inits the delay
// ===============================
void HALfunc_ID151_initDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: the delay
	void * d = pParams[0].fp_pD;
// parameter N descr: number of samples which correspond to the delay time (Tdelay = N * Ta)
	void * N = pParams[1].fp_pD;
// parameter Nindex descr: the index at the vector of N
	TAPInterpreterVariable * Nindex = pParams[2].fp_pV;
};
</Code><Code idCode="349">// ===============================
// function implementation for initDelay(var id = 151)
// description: inits the delay
// ===============================
void HALfunc_ID151_initDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: the delay
	void * d = pParams[0].fp_pD;
// parameter N descr: number of samples which correspond to the delay time (Tdelay = N * Ta)
	void * N = pParams[1].fp_pD;
// parameter Nindex descr: the index at the vector of N
	void * Nindex = pParams[2].fp_pD;
};
</Code><Code idCode="350">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================
void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	void * frameBuffer = pParams[1].fp_pD;
};
</Code><Code idCode="351">// ===============================
// driver uuid =5
// ===============================

// sockets
#ifdef WIN32
	#ifndef WINVER
		// set min win version to Win XP
		#define WINVER 0x0501
	#endif
	//use lib: ws2_32
	#include &lt;winsock2.h&gt;
	#include &lt;ws2tcpip.h&gt;
#else

	#include &lt;sys/types.h&gt;
	#include &lt;sys/socket.h&gt;
	#include &lt;netinet/in.h&gt;
	#include &lt;netdb.h&gt;

	#include &lt;sys/un.h&gt;
	#include &lt;unistd.h&gt;
	#include &lt;arpa/inet.h&gt;

	#define ADDR_ANY	INADDR_ANY
	#define SOCKET_ERROR	(-1)
	#define INVALID_SOCKET (SOCKET)(~0)
	#define closesocket(x) (close(x))

	typedef int	SOCKET;
	typedef struct sockaddr_in SOCKADDR_IN;
	typedef struct sockaddr SOCKADDR;

#endif


// ===========================================================
// socket functions to communicate via UDP
// ===========================================================
// written by Stefan Jaritz -&gt; prefix stj

typedef int (* TfkpUDPcallback) (uint8_t * pData, size_t amount);

// gets the local Name and IP
int stjUDPSocket_getLocalSocketAddress (
		char * szName, 	//!&lt; (out) name of the socket szName[maxChars]
		char * szIP,	//!&lt; (out) IP of the socket szIP[maxChars]
		size_t maxChars //!&lt; (in) amount of chars at the output strings
	);

// gets the name from a IP
int stjUDPSocket_getIPfromName (
		char * szName, 	//!&lt; (in) name of the socket szName[maxChars]
		char * szIP,	//!&lt; (out) IP of the socket szIP[maxChars]
		size_t maxChars //!&lt; (in) amount of chars at the output strings
	);


// the IP address
typedef struct SstjUDPSocket_addr {
	struct sockaddr_in	Addr;
	int					len;
} TstjUDPSocket_addr;

typedef struct SstjUDPSocketControl {
	pthread_t			srvThr;
	SOCKET 				Sclient;
	SOCKET 				Ssrv;
	TstjUDPSocket_addr	AIclient;
	TstjUDPSocket_addr	AIsrv;
	uint8_t *			pRXBuffer;
	size_t				rxBufferSize;
	sem_t 				semSrvIsRunning;
	TfkpUDPcallback		rxCB;
} TstjUDPSocketControl;

TstjUDPSocketControl gUDPcontrol = {
	.Sclient = 0,
	.Ssrv = 0,
	.pRXBuffer = NULL,
	.rxBufferSize = 0
};


// creates a UPD server
int stjUDPSocket_createServer (
		uint16_t 			port	//!&lt;(in) port
	);


// creates a UDP client witch connects to a local server
int stjUDPSocket_createClient (
		const char *		szIP,	//!&lt;(in) ip string
		uint16_t 			port	//!&lt;(in) port
	);

// closes socket &amp; address
void stjUDPSocket_close ();

// sends some data to an address
int stjUDPSocket_send (
		void *				pData,		//!&lt; data to send
		size_t				dataSize	//!&lt; amount of bytes
	);

// receives some data and filles the address with the sender
int stjUDPSocket_recv (
		void *				pData,		//!&lt; data to send
		size_t				dataSize	//!&lt; amount of bytes
	);

// inits the socket system
int stjUDPSocket_SysInit();

// closes the socket system
void stjUDPSocket_SysClose();

// ===========================================================
// socket functions to communicate via UDP
// ===========================================================
// written by Stefan Jaritz -&gt; prefix stj
// part II: implementation

// gets the local Name and IP
 int stjUDPSocket_getLocalSocketAddress (
	char * szName, 	//!&lt; (out) name of the socket szName[maxChars]
	char * szIP,	//!&lt; (out) IP of the socket szIP[maxChars]
	size_t maxChars //!&lt; (in) amount of chars at the output strings
 ) {
	struct hostent *	pHostInfo;
	struct in_addr **	addr_list;
	int i;

	// resolve hostname

	if (gethostname(szName,(int) maxChars)) {
		return -1;
	}

	pHostInfo = gethostbyname( szName );
	if(!pHostInfo) {
		return -2;
	}

	// search list
	addr_list = (struct in_addr **) pHostInfo-&gt;h_addr_list;

	for(i = 0; addr_list[i] != NULL; i++) {
		//Return the first one;
		strncpy(szIP , inet_ntoa(*addr_list[i]), maxChars);
		return 0;
	}

	return -3;
}

 // gets the name from a IP
 int stjUDPSocket_getIPfromName (
 		char * szName, 	//!&lt; (in) name of the socket szName[maxChars]
 		char * szIP,	//!&lt; (out) IP of the socket szIP[maxChars]
 		size_t maxChars //!&lt; (in) amount of chars at the output strings
 	) {
	struct hostent *he;
	struct in_addr **addr_list;
	int i;

	if ( (he = gethostbyname( szName ) ) == NULL) {
		return -1;
	}

	addr_list = (struct in_addr **) he-&gt;h_addr_list;

	for(i = 0; addr_list[i] != NULL; i++)  {
		//Return the first one;
		strncpy(szIP , inet_ntoa(*addr_list[i]), maxChars);
		return 0;
	}
	return -2;
}


// creates a UPD server
int stjUDPSocket_createServer (
		uint16_t 			port	//!&lt;(in) port
	) {
	// create socket
	gUDPcontrol.Ssrv =socket(AF_INET,SOCK_DGRAM,0);
	if (!gUDPcontrol.Ssrv) goto mainErrorWithMsg;

	// create address
	gUDPcontrol.AIsrv.Addr.sin_family=AF_INET; // AF_UNSPEC
	gUDPcontrol.AIsrv.Addr.sin_port=htons(port);
	gUDPcontrol.AIsrv.Addr.sin_addr.s_addr=ADDR_ANY;
	gUDPcontrol.AIsrv.len = sizeof(SOCKADDR_IN);

	// bind socket to adress
	if (SOCKET_ERROR == bind(gUDPcontrol.Ssrv,(SOCKADDR*)&amp;gUDPcontrol.AIsrv.Addr,gUDPcontrol.AIsrv.len)) goto mainErrorWithMsg;
    return 0;
mainErrorWithMsg:
   	perror (&quot;create server error&quot;);
   	return -1;
}

// creates a UDP client witch connects to a local server
int stjUDPSocket_createClient (
		const char *		szNameOrIP,	//!&lt;(in) ip string
		uint16_t 			port	//!&lt;(in) port
	) {

	// create socket
	gUDPcontrol.Sclient=socket(AF_INET,SOCK_DGRAM,0);
	if (!gUDPcontrol.Sclient) goto mainErrorWithMsg;

	// try to get an valid address
	// assume the string contains an ip address aka &quot;123.23.234.56&quot;
	unsigned long addr = inet_addr(szNameOrIP);
	if ((INADDR_NONE == addr) || (INADDR_ANY == addr)) {
		// no?
		// maybee a name
		struct hostent *he;
		struct in_addr **addr_list;
		int i;
		if ( (he = gethostbyname( szNameOrIP ) ) == NULL) {
			return -1;
		}
		// search for the ip address
		addr_list = (struct in_addr **) he-&gt;h_addr_list;
		for(i = 0; addr_list[i] != NULL; i++)  {
			addr = inet_addr(inet_ntoa(*addr_list[i]));
			goto isworking;
		}

		closesocket(gUDPcontrol.Sclient);
		perror (&quot;unknown address or name&quot;);
		return -2;
	}
isworking:
	// create address
	gUDPcontrol.AIclient.Addr.sin_family=AF_INET; // AF_UNSPEC
	gUDPcontrol.AIclient.Addr.sin_port=htons(port);
	gUDPcontrol.AIclient.Addr.sin_addr.s_addr= addr;
	gUDPcontrol.AIclient.len = sizeof(SOCKADDR_IN);

    return 0;
mainErrorWithMsg:
   	perror (&quot;error&quot;);
   	return -1;
}

// closes socket &amp; address
void stjUDPSocket_close () {
	// pAI is self build so we don't need a free call
	//freeaddrinfo(gMsgServer.aiAdmin);
	closesocket(gUDPcontrol.Ssrv);
	closesocket(gUDPcontrol.Sclient);

	gUDPcontrol.Ssrv = 0;
	gUDPcontrol.Sclient = 0;
}

// sends some data to an address
int stjUDPSocket_send (
		void *				pData,		//!&lt; data to send
		size_t				dataSize	//!&lt; amount of bytes
	) {
	int n;
	n = sendto (gUDPcontrol.Sclient, (const char *) pData, dataSize, 0,(struct sockaddr *)&amp;(gUDPcontrol.AIclient.Addr), gUDPcontrol.AIclient.len);
	if (n != dataSize) {
		perror (&quot;sending data failed!&quot;);
		return -1;
	}
	return 0;
}

// receives some data and filles the address with the sender
int stjUDPSocket_recv (
		void *				pData,		//!&lt; data to receive
		size_t				dataSize	//!&lt; amount of bytes
	) {
	int n;
	n = recvfrom(gUDPcontrol.Ssrv, (char *) pData, dataSize, 0,(struct sockaddr *)&amp;(gUDPcontrol.AIsrv.Addr), &amp;gUDPcontrol.AIsrv.len);
	if ((n == 0) || (n == SOCKET_ERROR)) {
		perror (&quot;receiving data failed!&quot;);
		return -1;
	}
	return n;
}

// inits the socket system
int stjUDPSocket_SysInit() {
#ifdef WIN32
	// local data
	WSADATA		wsaData;

	// start sockets
    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	perror(&quot;WSAStartup failed!&quot;);
        return -1;
    }
#else

#endif
    return 0;
}

// closes the socket system
void stjUDPSocket_SysClose() {
#ifdef WIN32
	WSACleanup();
#else

#endif

}

// ===========================================================
// msg pump
// ===========================================================

void * UDPcontrolMsgPump(void * pParams) {
	int am;
	// signal that the server message pump is running
	sem_post(&amp;gUDPcontrol.semSrvIsRunning);
	// run the pump
	for (;;) {
		am = stjUDPSocket_recv(gUDPcontrol.pRXBuffer, gUDPcontrol.rxBufferSize);
		if (am &lt;= 0) {
			return (void *) -1;
		}
		if (gUDPcontrol.rxCB(gUDPcontrol.pRXBuffer, (size_t)am)) {
			return (void *) -2;
		}
	}
	return 0;
}

int UDPcontrolInit (size_t rxBufferSize, uint16_t srv_port, uint16_t cli_port, char * szOtherServer, TfkpUDPcallback rxCB) {

	gUDPcontrol.rxCB = rxCB;

	gUDPcontrol.pRXBuffer = malloc(rxBufferSize);
	if (!gUDPcontrol.pRXBuffer) {
		return -1;
	}
	gUDPcontrol.rxBufferSize = rxBufferSize;

	// open server
	if (stjUDPSocket_createServer(srv_port)) {
		return -2;
	}

	// create server thread
	sem_init(&amp;gUDPcontrol.semSrvIsRunning, 0, 0);

	if(pthread_create(&amp;gUDPcontrol.srvThr , NULL, UDPcontrolMsgPump, NULL)) {
		return -2;
	}
	// wait till rx server is running
	sem_wait(&amp;gUDPcontrol.semSrvIsRunning);

	// create client
	// assume that the string contains a IP string
	if (stjUDPSocket_createClient(szOtherServer, cli_port) != 0) {
		return -2;
	}

	return 0;
}

void UDPcontrolClose() {
	stjUDPSocket_close();
	pthread_join(gUDPcontrol.srvThr, NULL);
	free(gUDPcontrol.pRXBuffer);
	sem_destroy(&amp;gUDPcontrol.semSrvIsRunning);
}

// =====================
// udp drv starts here
// =====================


// struct for the drv data
typedef struct SUDPsockDrv {
	TAPMsgHeader				h;			//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TUDPsockDrv;

TUDPsockDrv gUDPsockDrv;

// ------------------------------
// drv own functions
// ------------------------------

void drv_5_sendHeader (
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	gUDPsockDrv.h[eAPMsgHeaderPosition_msgTypeID] = msgId;
	gUDPsockDrv.h[eAPMsgHeaderPosition_msgNumber] = num;
	gUDPsockDrv.h[eAPMsgHeaderPosition_receiver] = recv;
	gUDPsockDrv.h[eAPMsgHeaderPosition_length] = length;
	stjUDPSocket_send((void *)gUDPsockDrv.h,sizeof(TAPMsgHeader));
}


// function for feeding the recv state machine
int drv_5_feedRecvStateM (uint8_t * pData, size_t amount) {
	gUDPsockDrv.rxSM.state (&amp;(gUDPsockDrv.rxSM), pData, (amount / 4));
	return 0;
}
//open an existing driver and bind it to the AP
int drv_5_open (void * pAP, struct SAPMsgDrv *pDrv) {
	// init header
	gUDPsockDrv.h[eAPMsgHeaderPosition_endian] = gAPendianFlag;
	gUDPsockDrv.h[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	gUDPsockDrv.h[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	gUDPsockDrv.h[eAPMsgHeaderPosition_msgTypeID] = 0;
	gUDPsockDrv.h[eAPMsgHeaderPosition_msgNumber] = 0;
	gUDPsockDrv.h[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = &amp;gUDPsockDrv;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;gUDPsockDrv.rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}

//close the driver
int drv_5_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_5_destroy (struct SAPMsgDrv *pDrv) {
	UDPcontrolClose();
	return 0;
}

//sends raw data in uint32_t chunks
int drv_5_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	stjUDPSocket_send((void *)pData,amount*sizeof(uint32_t));
	return 0;
}
//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_5_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	stjUDPSocket_send((void *)pData,amount*sizeof(uint32_t));
	return 0;
}
//sends float data in float chunks
int drv_5_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	stjUDPSocket_send((void *)pData,amount*sizeof(uint32_t));
	return 0;
}

//acknowledge
int drv_5_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_ACK, receiver, mNum, 0);
	return 0;
}
//not acknowledge
int drv_5_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_NACK, receiver, mNum, 0);
	return 0;
}
//start sending a program
int drv_5_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	drv_5_sendHeader(eAPMsgTypes_startPrg, receiver, mNum, 0);
	stjUDPSocket_send((void *)&amp;globalVariableNumber,sizeof(int32_t));
	stjUDPSocket_send((void *)&amp;localVariableNumber,sizeof(int32_t));
	stjUDPSocket_send((void *)&amp;instructionNumber,sizeof(int32_t));
	return 0;
}

//sends a variable
int drv_5_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	drv_5_sendHeader(eAPMsgTypes_sendVariable, receiver, mNum, 3);
	stjUDPSocket_send((void *)&amp;index,sizeof(int32_t));
	stjUDPSocket_send((void *)&amp;varTypeID,sizeof(int32_t));
	stjUDPSocket_send((void *)&amp;num,sizeof(int32_t));
	return 0;
}
//sends an instruction
int drv_5_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	drv_5_sendHeader(eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1);
	stjUDPSocket_send((void *)&amp;index,sizeof(int32_t));
	stjUDPSocket_send((void *)fbc,sizeof(int32_t) * (dAPInterpreterFuncMaxParams+1));
	return 0;
}
//sings that the program transmission has completed
int drv_5_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_endPrg, receiver, mNum, 0);
	return 0;
}
//stops the AP
int drv_5_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_stop, receiver, mNum, 0);
	return 0;
}
//the AP executes one instruction
int drv_5_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_step, receiver, mNum, 0);
	return 0;
}
//the AP runs the program
int drv_5_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_run, receiver, mNum, 0);
	return 0;
}
//a variable going to be updated
int drv_5_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	drv_5_sendHeader(eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1);
	stjUDPSocket_send((void *)&amp;gIndex,sizeof(int32_t));
	return 0;
}
//a AP is going to be logged in to the system
int drv_5_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_login, receiver, mNum, 0);
	return 0;
}
//a AP is going to be logged out of the system
int drv_5_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_5_sendHeader(eAPMsgTypes_logout, receiver, mNum, 0);
	return 0;
}
</Code><Code idCode="352">// ===============================
// startup code for the audio processor
// ===============================

/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;PC.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	TAPNode * pN;

	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'p':
				printf(&quot;own node id: %i\nnode list:\n&quot;, (int) AP.nodeID);
				pN = AP.pNodeList;
				while(pN) {
					printf(&quot;%i\n&quot;, (int)pN-&gt;nodeID);
					pN = pN-&gt;pNext;
				}
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\np-show nodes\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

extern int drv_6_feedRecvStateM (uint8_t * pData, size_t amount);

int main()
{
	pthread_t		IPthread;
	pthread_t		MSthread;

	enum eMsgDrvIDs {
		eMsgDrvID_TCP = 0,
		eMsgDrvID_amount = 1
	};

	TAPMsgDrv		msgSysDrv[eMsgDrvID_amount];
	int rc;

	// =======================
	// TCP
	// =======================

	if (TCPcontrolInitFromStdIn(drv_6_feedRecvStateM, 4096, 500)) {
		fprintf(stderr, &quot;init TCVP driver failed!\n&quot;);
		return EXIT_FAILURE;
	}
	APdriver_6_init (&amp;(msgSysDrv[eMsgDrvID_TCP]));

	// =======================
	// gtk
	// =======================

	APgtk_start ();

	// =======================
	srand(time(NULL));

	rc = APinit(&amp;AP,(TAPNodeID)rand(),msgSysDrv,eMsgDrvID_amount,1000,eAP_littleEndian);
	if (rc) {
		fprintf(stderr, &quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	if (rc) goto exit;

	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	APgtk_end ();

	return EXIT_SUCCESS;
}
</Code><Code idCode="353">// ===============================
// function implementation for uiSetDisplayTextDim(var id = 213)
// description: sets the dimension of the text display
// ===============================
void HALfunc_ID213_uiSetDisplayTextDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter charsPerLine descr: amount of characters per line
	int32_t charsPerLine = pParams[2].fp_integer;
// parameter lines descr: amout of characters-lines
	int32_t lines = pParams[3].fp_integer;

	gtkAP_local_DisplaySetTextDim (
			&amp;(puiD-&gt;pUI[dIndex].ui.display),
			(int) charsPerLine,
			(int) lines
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="354">// ===============================
// function implementation for uiSetDisplayTextDim(var id = 213)
// description: sets the dimension of the text display
// ===============================
void HALfunc_ID213_uiSetDisplayTextDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	void * d = pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter charsPerLine descr: amount of characters per line
	int32_t charsPerLine = pParams[2].fp_integer;
// parameter lines descr: amout of characters-lines
	int32_t lines = pParams[3].fp_integer;

	// the UI setting ist static 16chars at 2 lines
	// nop


	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="355">// ===============================
// driver uuid =6
// ===============================

// sockets
#ifdef WIN32
	#ifndef WINVER
		// set min win version to Win XP
		#define WINVER 0x0501
	#endif
	//use lib: ws2_32
	#include &lt;winsock2.h&gt;
	#include &lt;ws2tcpip.h&gt;
#else

	#include &lt;sys/types.h&gt;
	#include &lt;sys/socket.h&gt;
	#include &lt;netinet/in.h&gt;
	#include &lt;netdb.h&gt;

	#include &lt;sys/un.h&gt;
	#include &lt;unistd.h&gt;
	#include &lt;arpa/inet.h&gt;

	#define ADDR_ANY	INADDR_ANY
	#define SOCKET_ERROR	(-1)
	#define INVALID_SOCKET (SOCKET)(~0)
	#define closesocket(x) (close(x))

	typedef int	SOCKET;
	typedef struct sockaddr_in SOCKADDR_IN;
	typedef struct sockaddr SOCKADDR;

#endif


typedef int (* TfkpTCPcallback) (uint8_t * pData, size_t amount);

// size of the header
#define dStjTCPSocketControlMsg (sizeof(uint_32))

// start data msg struct
// &lt;uint_32&gt; id = 's'
// &lt;uint_32&gt; len

// res struct
// &lt;uint_32&gt; id = 'r'
// &lt;uint_32&gt; error code (0 = no error)

enum eStjTCPSocketControlMsgIDs {
	eStjTCPSocketControlMsgID_start = 's',
	eStjTCPSocketControlMsgID_packet = 'p',
	eStjTCPSocketControlMsgID_result = 'r'
};

enum eStjTCPSocketControlMsgErrorIDs {
	eStjTCPSocketControlMsgErrorID_noError = 0,
	eStjTCPSocketControlMsgErrorID_otherError,
	eStjTCPSocketControlMsgErrorID_socket,
	eStjTCPSocketControlMsgErrorID_msgID,
	eStjTCPSocketControlMsgErrorID_realloc,
	eStjTCPSocketControlMsgErrorID_amount,
	eStjTCPSocketControlMsgErrorID_wrongPacket,

};

//! type to control a udp socket based message communication
typedef struct SstjTCPSocketControl {
	pthread_t			srvThr;

	SOCKET 				sCli;	//!&lt; socket for the input
	SOCKET 				sSrv;	//!&lt; socket for the output

	struct sockaddr_in 	sAddrCli; //!&lt; client address
	int					cliConnectedFlag; //!&lt; &lt;&gt;0 if the client is connected

	uint8_t *			pMsgBuffer;
	size_t				msgBufferSize;

	sem_t 				serverSign;
	TfkpTCPcallback		rxCB;

	int					maxTXsize;
} TstjTCPSocketControl;

//! a global variable to control a udp message based communication
TstjTCPSocketControl gTCPsocketControl = {
	.srvThr = NULL,
	.sCli = -1,
	.sSrv = -1,
	.cliConnectedFlag = 0,
	.pMsgBuffer = NULL,
	.msgBufferSize = 0,
};

static inline int _TCPcontrolRecvResult(SOCKET s) {
	int r;
	uint32_t contrlMsg[2];

	// recv that the server is ready to transmit
	r = recv(s , (char *)contrlMsg , sizeof(contrlMsg) , 0);
	if(r &lt; 0) {
		return eStjTCPSocketControlMsgErrorID_socket;
	}
	if (r != sizeof(contrlMsg)) {
		return eStjTCPSocketControlMsgErrorID_amount;
	}
	if (contrlMsg[0] != eStjTCPSocketControlMsgID_result) {
		return eStjTCPSocketControlMsgErrorID_msgID;
	}

	return contrlMsg[1];
}

static inline int _TCPcontrolSendResult(SOCKET s, uint32_t errorCode) {
	uint32_t contrlMsg[2];
	int r;

	contrlMsg[0] = eStjTCPSocketControlMsgID_result;
	contrlMsg[1] = errorCode;
	r = send(s , (char *)contrlMsg , sizeof(contrlMsg) , 0);
	if (r &lt; 0) return eStjTCPSocketControlMsgErrorID_socket;
	return eStjTCPSocketControlMsgErrorID_noError;
}

//! sends a block of data
int TCPcontrolSend(uint8_t * pD, size_t dataSize) {
	int r;
	uint32_t contrlMsg[2];
	uint32_t p;
	uint32_t packets;
	uint8_t * pB;
	size_t	am, amTotal;

	// check if we have to connect
	if (!gTCPsocketControl.cliConnectedFlag) {
		if (connect(gTCPsocketControl.sCli , (struct sockaddr *)&amp;gTCPsocketControl.sAddrCli , sizeof(gTCPsocketControl.sAddrCli)) &lt; 0){
			gTCPsocketControl.cliConnectedFlag = 0;
			return -1;
		} else {
			gTCPsocketControl.cliConnectedFlag = 1;
		}

	}
	//  ok we are connected - lets send the data
	start:

	contrlMsg[0] = eStjTCPSocketControlMsgID_start;
	contrlMsg[1] = dataSize;
	// send that we what to transmit some data
	r = send(gTCPsocketControl.sCli , (char *)contrlMsg , sizeof(contrlMsg) , 0);
	if(r &lt; 0) {
		return -2;
	}
	// recv that the server is ready to transmit
	r = _TCPcontrolRecvResult(gTCPsocketControl.sCli);
	if (eStjTCPSocketControlMsgErrorID_socket == r) return -3;
	if (eStjTCPSocketControlMsgErrorID_amount == r) goto start;

	// ok let's send
	packets = dataSize / gTCPsocketControl.maxTXsize;
	if (dataSize % gTCPsocketControl.maxTXsize) packets++;
	pB = pD;
	amTotal = dataSize;

	for (p = 0; p &lt; packets; p++) {
		// send packet pre header
		contrlMsg[0] = eStjTCPSocketControlMsgID_packet;
		contrlMsg[1] = p;
		r = send(gTCPsocketControl.sCli , (char *)contrlMsg , sizeof(contrlMsg) , 0);
		if(r &lt; 0) {
			return -4;
		}
		r = _TCPcontrolRecvResult(gTCPsocketControl.sCli);
		if (eStjTCPSocketControlMsgErrorID_socket == r) return -5;
		if (eStjTCPSocketControlMsgErrorID_amount == r) goto start;

		am = (amTotal &gt; gTCPsocketControl.maxTXsize) ? gTCPsocketControl.maxTXsize : amTotal;

sendPacket:
		r = send(gTCPsocketControl.sCli ,(char *) pB ,am , 0);
		if(r &lt; 0) {
			return -5;
		}

		// get ack from the server
		r = _TCPcontrolRecvResult(gTCPsocketControl.sCli);
		if (eStjTCPSocketControlMsgErrorID_socket == r) return -3;
		if (eStjTCPSocketControlMsgErrorID_amount == r) goto sendPacket;

		pB += am;
		amTotal -= am;
	}
	return r;
}


//! the message pump
void * TCPcontrolMsgPump (void *pParams) {
	int 				r;
	uint32_t 			contrlMsg[2];
	struct sockaddr_in 	cliAddr;
	SOCKET 				sCli;
	uint32_t			dataSize;
	socklen_t			cliAddrSize;
	uint32_t 			packets;
	uint8_t * 			pB;
	size_t				am, amTotal;
	uint32_t			p;


	sem_post(&amp;gTCPsocketControl.serverSign);

	//accept connection from an incoming client
	cliAddrSize = sizeof(struct sockaddr_in);
	sCli = accept(gTCPsocketControl.sSrv, (struct sockaddr *)&amp;cliAddr, (socklen_t*)&amp;cliAddrSize);
	if (sCli &lt; 0) goto end;

	// run the pump
	for (;;) {
		// ok we are connected
		// read start message
		r = recv(sCli , (char *)contrlMsg , sizeof(contrlMsg), 0);
		if (r &lt; 0) goto end;
		if (r != sizeof(contrlMsg)) {
			_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_amount);
			continue;
		}
		if (contrlMsg[0] != eStjTCPSocketControlMsgID_start) {
			_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_msgID);
			continue;
		}

		dataSize = contrlMsg[1];
		// check if we have to realloc the rx buffer
		if (gTCPsocketControl.msgBufferSize &lt; dataSize) {
			 uint8_t *pNB = realloc(gTCPsocketControl.pMsgBuffer, dataSize);
			 if (!pNB) {
				 _TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_realloc);
				 continue;
			 }
			 gTCPsocketControl.pMsgBuffer = pNB;
			 gTCPsocketControl.msgBufferSize = dataSize;
		}

		_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_noError);

		// recv data
		packets = dataSize / gTCPsocketControl.maxTXsize;
		if (dataSize % gTCPsocketControl.maxTXsize) packets++;
		pB = gTCPsocketControl.pMsgBuffer;
		amTotal = dataSize;

		for (p = 0; p &lt; packets; p++) {
			// receive packet header
			r = recv(sCli , (char *)contrlMsg , sizeof(contrlMsg), 0);
			if (r &lt; 0) goto end;
			if (r != sizeof(contrlMsg)) {
				_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_amount);
				continue;
			}
			if (contrlMsg[0] != eStjTCPSocketControlMsgID_packet) {
				_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_msgID);
				continue;
			}
			if (contrlMsg[1] != p) {
				_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_wrongPacket);
				continue;
			}
			_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_noError);

			am = (amTotal &gt; gTCPsocketControl.maxTXsize) ? gTCPsocketControl.maxTXsize : amTotal;

			// ok the next message will contain the data
recvPacket:
			r = recv(sCli , (char *)pB , am, 0);
			if (r &lt; 0) goto end;
			if (r != am) {
				_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_amount);
				goto recvPacket;
			}

			_TCPcontrolSendResult(sCli, eStjTCPSocketControlMsgErrorID_noError);
			pB += am;
			amTotal -= am;
		}

		// handle message
		gTCPsocketControl.rxCB(gTCPsocketControl.pMsgBuffer , dataSize);
		continue;
	}
end:
	sem_post(&amp;gTCPsocketControl.serverSign);
	return (void *) -1;
}

//! init
int TCPcontrolInit (
		int 			serverPort,		//!&lt; server tx port number - best over 1000
		const char * 	szClient,		//!&lt; &quot;family-PC&quot; or &quot;192.168.1.3&quot;
		int				clientPort,		//!&lt; client tx port number
		TfkpTCPcallback rxCB,			//!&lt; the rx data callback
		size_t			rxBufferSize,	//!&lt; the size of the rx buffer
		size_t			maxTCPdataSize 	//!&lt; maximum size of a TCP datagram (400 Bytes seems a good size)
	) {
#ifdef WIN32
	// local data
	WSADATA		wsaData;

	// start sockets
    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	perror(&quot;WSAStartup failed!&quot;);
        return -1;
    }
#endif
    char *				szIPserver;
    char *				szIPclient;
    struct hostent *	pHostDescr;
    struct sockaddr_in 	sAddr;

    // -----------------
    // get ip strings

    // get ip of the server
	pHostDescr = gethostbyname(&quot;localhost&quot;);
	// check if found a host
	if (!pHostDescr) {
		return -11;
	}
	szIPserver = inet_ntoa(*(struct in_addr*)*pHostDescr-&gt;h_addr_list);

    // get ip of the client
    if (strcmp(szClient, &quot;&quot;)) {
    	pHostDescr = gethostbyname(szClient);
    } else {
    	pHostDescr = gethostbyname(&quot;localhost&quot;);
    }
    // check if found a host
	if (!pHostDescr) {
		return -12;
	}
	szIPclient = inet_ntoa(*(struct in_addr*)*pHostDescr-&gt;h_addr_list);


    // -----------------
    // try to create sockets

	// try to create socket for the server
	gTCPsocketControl.sSrv = socket(PF_INET , SOCK_STREAM, IPPROTO_TCP);
	if (-1 == gTCPsocketControl.sSrv) return -21;
	// try to create socket for the client
	gTCPsocketControl.sCli = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (-1 == gTCPsocketControl.sCli) return -22;

    // -----------------
    // bind input to IP and port
	memset(&amp;sAddr,0,sizeof(sAddr));
	sAddr.sin_family = PF_INET;
	sAddr.sin_addr.s_addr = INADDR_ANY;
	sAddr.sin_port = htons( serverPort );

	// bind server socket to address
	if (bind(gTCPsocketControl.sSrv, (SOCKADDR *)&amp;sAddr, sizeof(SOCKADDR_IN))) {
		return -31;
    }
	// and listen for incoming connections
	if (listen(gTCPsocketControl.sSrv , 3)) {
		return -32;
	}

	// -----------------
	// connect output to IP and port
	memset(&amp;gTCPsocketControl.sAddrCli,0,sizeof(sAddr));
	gTCPsocketControl.sAddrCli.sin_family = PF_INET;
	gTCPsocketControl.sAddrCli.sin_addr.s_addr = inet_addr(szIPclient);
	gTCPsocketControl.sAddrCli.sin_port = htons( clientPort );

	if (connect(gTCPsocketControl.sCli , (struct sockaddr *)&amp;gTCPsocketControl.sAddrCli , sizeof(gTCPsocketControl.sAddrCli)) &lt; 0){
		gTCPsocketControl.cliConnectedFlag = 0;
	} else {
		gTCPsocketControl.cliConnectedFlag = 1;
	}


	// create sign semaphore
	sem_init(&amp;gTCPsocketControl.serverSign, 0, 0);

	// create buffers
	gTCPsocketControl.pMsgBuffer = malloc(rxBufferSize);
	if (!gTCPsocketControl.pMsgBuffer) {
		return -32;
	}
	gTCPsocketControl.msgBufferSize = rxBufferSize;

	// set callback
	gTCPsocketControl.rxCB = rxCB;

	gTCPsocketControl.maxTXsize = maxTCPdataSize;

	// start rx thread
	if(pthread_create(&amp;gTCPsocketControl.srvThr , NULL, TCPcontrolMsgPump, NULL)) {
		return -40;
	}
	// wait till rx server is running
	sem_wait(&amp;gTCPsocketControl.serverSign);

	return 0;
}

//! closes the TCP server and client
void TCPcontrolClose () {
	closesocket (gTCPsocketControl.sSrv);
	closesocket (gTCPsocketControl.sCli);

	free(gTCPsocketControl.pMsgBuffer);

	memset(&amp;gTCPsocketControl, 0, sizeof(TstjTCPSocketControl));

#ifdef WIN32
	WSACleanup();
#endif
}


//! inits the TCP control via stdin inputs
int TCPcontrolInitFromStdIn (
		TfkpTCPcallback rxCB,			//!&lt; the rx data callback
		size_t			rxBufferSize,	//!&lt; the size of the rx buffer
		size_t			maxTCPdataSize 	//!&lt; maximum size of a TCP datagram (400 Bytes seems a good size)
	) {
	int srvPort;
	int clientPort;
	const size_t ipLen = 256;
	char szIP[ipLen];
	const size_t dummyStrLen = 100;
	char szDummy[dummyStrLen];

	int r;

	printf(&quot;====| TCP client/server setup |====\n&quot;);
	printf(&quot;server listen port: &quot;);
	fgets(szDummy, dummyStrLen, stdin);
	szDummy[strcspn(szDummy, &quot;\r\n&quot;)] = 0;
	srvPort = atoi(szDummy);

	printf(&quot;client send IP address or name: &quot;);
	fgets(szIP, 255, stdin);
	szIP[strcspn(szIP, &quot;\r\n&quot;)] = 0;

	printf(&quot;client port: &quot;);
	fgets(szDummy, dummyStrLen, stdin);
	szDummy[strcspn(szDummy, &quot;\r\n&quot;)] = 0;
	clientPort = atoi(szDummy);

	r = TCPcontrolInit (
			srvPort,		//!&lt; server port number - best over 1000
			szIP,			//!&lt; &quot;family-PC&quot; or &quot;192.168.1.3&quot;
			clientPort,		//!&lt; client port number
			rxCB,			//!&lt; the rx data callback
			rxBufferSize,	//!&lt; the size of the rx buffer
			maxTCPdataSize 	//!&lt; maximum size of a TCP datagram (400 Bytes seems a good size)
		);

	if (!r) {
		printf(&quot;setup finished successfully!\n&quot;);
		printf(&quot;===================================\n&quot;);
	} else {
		printf(&quot;setup error: %i \n&quot;, r);
		printf(&quot;===================================\n&quot;);
	}
	return r;
}
// -----------------------------------------

// struct for the drv data
typedef struct STCPsockDrv {
	TAPMsgHeader				h;			//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TTCPsockDrv;

TTCPsockDrv gTCPsockDrv;

// ------------------------------
// drv own functions
// ------------------------------

void drv_6_sendHeader (
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	gTCPsockDrv.h[eAPMsgHeaderPosition_msgTypeID] = msgId;
	gTCPsockDrv.h[eAPMsgHeaderPosition_msgNumber] = num;
	gTCPsockDrv.h[eAPMsgHeaderPosition_receiver] = recv;
	gTCPsockDrv.h[eAPMsgHeaderPosition_length] = length;
	TCPcontrolSend((void *)gTCPsockDrv.h,sizeof(TAPMsgHeader));
}


// function for feeding the recv state machine
int drv_6_feedRecvStateM (uint8_t * pData, size_t amount) {
	gTCPsockDrv.rxSM.state (&amp;(gTCPsockDrv.rxSM), pData, (amount / 4));
	return 0;
}
//open an existing driver and bind it to the AP
int drv_6_open (void * pAP, struct SAPMsgDrv *pDrv) {
	
	// init header
	gTCPsockDrv.h[eAPMsgHeaderPosition_endian] = gAPendianFlag;
	gTCPsockDrv.h[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	gTCPsockDrv.h[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	gTCPsockDrv.h[eAPMsgHeaderPosition_msgTypeID] = 0;
	gTCPsockDrv.h[eAPMsgHeaderPosition_msgNumber] = 0;
	gTCPsockDrv.h[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = &amp;gTCPsockDrv;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;gTCPsockDrv.rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}

//close the driver
int drv_6_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_6_destroy (struct SAPMsgDrv *pDrv) {
	TCPcontrolClose();
	return 0;
}

//sends raw data in uint32_t chunks
int drv_6_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	TCPcontrolSend((void *)pData,amount*sizeof(uint32_t));
	return 0;
}
//sends integer data in int32_t chunks in the sequence (LB0,HB0,LB1,HB1,LB2,HB2,LB3,HB3)
int drv_6_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	TCPcontrolSend((void *)pData,amount*sizeof(uint32_t));
	return 0;
}
//sends float data in float chunks
int drv_6_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	TCPcontrolSend((void *)pData,amount*sizeof(uint32_t));
	return 0;
}

//acknowledge
int drv_6_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_ACK, receiver, mNum, 0);
	return 0;
}
//not acknowledge
int drv_6_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_NACK, receiver, mNum, 0);
	return 0;
}
//start sending a program
int drv_6_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	drv_6_sendHeader(eAPMsgTypes_startPrg, receiver, mNum, 0);
	TCPcontrolSend((void *)&amp;globalVariableNumber,sizeof(int32_t));
	TCPcontrolSend((void *)&amp;localVariableNumber,sizeof(int32_t));
	TCPcontrolSend((void *)&amp;instructionNumber,sizeof(int32_t));
	return 0;
}

//sends a variable
int drv_6_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	drv_6_sendHeader(eAPMsgTypes_sendVariable, receiver, mNum, 3);
	TCPcontrolSend((void *)&amp;index,sizeof(int32_t));
	TCPcontrolSend((void *)&amp;varTypeID,sizeof(int32_t));
	TCPcontrolSend((void *)&amp;num,sizeof(int32_t));
	return 0;
}
//sends an instruction
int drv_6_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	drv_6_sendHeader(eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1);
	TCPcontrolSend((void *)&amp;index,sizeof(int32_t));
	TCPcontrolSend((void *)fbc,sizeof(int32_t) * (dAPInterpreterFuncMaxParams+1));
	return 0;
}
//sings that the program transmission has completed
int drv_6_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_endPrg, receiver, mNum, 0);
	return 0;
}
//stops the AP
int drv_6_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_stop, receiver, mNum, 0);
	return 0;
}
//the AP executes one instruction
int drv_6_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_step, receiver, mNum, 0);
	return 0;
}
//the AP runs the program
int drv_6_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_run, receiver, mNum, 0);
	return 0;
}
//a variable going to be updated
int drv_6_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	drv_6_sendHeader(eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1);
	TCPcontrolSend((void *)&amp;gIndex,sizeof(int32_t));
	return 0;
}
//a AP is going to be logged in to the system
int drv_6_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_login, receiver, mNum, 0);
	return 0;
}
//a AP is going to be logged out of the system
int drv_6_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_6_sendHeader(eAPMsgTypes_logout, receiver, mNum, 0);
	return 0;
}
</Code><Code idCode="356">// ===============================
// startup code for the audio processor
// ===============================



/*
 /*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

#include &quot;PC.h&quot;

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {
	if (dALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gAPendianFlag,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gAPendianFlag,dALCdumpInstrCount,dALCdumpVarCount);

	int32_t i;
	for (i = 0; i &lt; dALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gAPendianFlag,i,gALCvars[i].type,gALCvars[i].amount)) return -100-i;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	for (i = 0; i &lt; dALCdumpInstrCount;i++) {
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gAPendianFlag,i,(int32_t *) &amp;gcInstructions[i])) return -1000-i;
	}
	return 0;
}


#endif


TAP AP;

#ifdef dWithDebugInterface
// ======================
// debug functions
// ======================

// finds a function name by the function call
const char * getFuncName (TAPInterpreterFuncCall * pFC) {
	// first get the fid
	const THALFunction * pHF = gHALFunctionList.pL;
	const TAPFuncDebugInfo * pDI = gDebugInfo_HALFunctionList.pFI;
	int i;
	for (i = 0; i&lt; gHALFunctionList.number; i++) {
		if (pHF-&gt;pfktHAL == pFC-&gt;pHALFkt) goto findName;
		pHF++;
	}
	return NULL;
findName:
	for (i = 0; i&lt; gDebugInfo_HALFunctionList.num; i++) {
		if (pHF-&gt;fid == pDI-&gt;fid) {
			return pDI-&gt;szName;
		}
		pDI++;
	}
	return NULL;
}

void printCode() {
	TAPInterpreterCPU * pCPU = APInterpreterGetCPUref(AP.IP);
	TAPInterpreterFuncCall * pFC = pCPU-&gt;pCodeStart;
	const char * szFname;
	while (pFC &lt; pCPU-&gt;pCodeEnd) {
		if (pCPU-&gt;pIP == pFC) {
			printf (&quot;&gt;\t&quot;);
		} else {
			printf (&quot;\t&quot;);
		}
		szFname = getFuncName(pFC);
		if (szFname) {
			printf(szFname);
		} else {
			printf(&quot;unknown function&quot;);
		}
		printf(&quot;\n&quot;);
		pFC++;
	}
	fflush(stdout);
}

#endif

void ui () {
	TAPNode * pN;

	for (;;) {
		printf(&quot;command: &quot;);
		fflush(stdout);
		switch (tolower(getc(stdin))) {
			case 'x':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_halt);
				break;
			case 'e':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_exit);
				return;
			case 'r' :
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_run);
				break;
			case 's':
				APInterpreterSetState (AP.IP,eAP_littleEndian,eAPInterpreterState_oneStep);
				break;
			case 'c':
				printf(&quot;code:\n&quot;);
#ifdef dWithDebugInterface
				printCode();
#else
				printf(&quot;debug is disabled&quot;);
#endif
				break;
			case 'p':
				printf(&quot;own node id: %i\nnode list:\n&quot;, (int) AP.nodeID);
				pN = AP.pNodeList;
				while(pN) {
					printf(&quot;%i\n&quot;, (int)pN-&gt;nodeID);
					pN = pN-&gt;pNext;
				}
				break;
			case 'h':
				printf(&quot;commands:\nx-halt\nr-run\ns-step\nc-show code\np-show nodes\ne-exit&quot;);
				break;
		}
		printf(&quot;\n&quot;);
		fflush(stdout);
	}
}

void * APIPthread(void * pArgs) {
	int rc;
	while (APInterpreterGetState(AP.IP) != eAPInterpreterState_exit) {
		rc = APInterpreterProcessState(AP.IP);
		if (rc != 0) {
			fprintf(stdout,&quot;\ninterpreter processing ended with code=%i&quot;,rc);
#ifdef dWithDebugInterface
			fprintf(stdout,&quot;\nCPU registers:\n&quot;);
			printCPUregisters();
#endif
			fflush(stdout);
		}
		usleep(0);
	}
	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

extern int drv_1_feedRecvStateM (uint8_t * pData, size_t amount);

int main()
{

	pthread_t		IPthread;
	pthread_t		MSthread;

	WSADATA		wsaData;

	enum eMsgDrvIDs {
		eMsgDrvID_UART = 0,
		eMsgDrvID_amount = 1
	};

	TAPMsgDrv		msgSysDrv[eMsgDrvID_amount];
	int rc;

	// =======================
	// TCP
	// =======================
	if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    		printf(&quot;WSAStartup failed!&quot;);
	    	return -1;
	}

	APdriver_1_init (&amp;(msgSysDrv[eMsgDrvID_UART]));

	// =======================
	// GTK++
	// =======================
	rc = APgtk_start ();
	if (rc &lt; 0) {
		printf(&quot;GTK init failed\n&quot;);
		return -2;
	}

	// =======================
	srand(time(NULL));

	rc = APinit(&amp;AP,(TAPNodeID)rand(),msgSysDrv,eMsgDrvID_amount,1000,eAP_littleEndian);
	if (rc) {
		fprintf(stderr, &quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	if (rc) goto exit;

	ui();

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}
</Code><Code idCode="357"></Code><Code idCode="358">// ===============================
// variable implementation for panel (varID=100)
// ===============================

// element structure for panel
typedef struct SApVar_ele_panel {
} TApVar_ele_panel;

// vector structure for panel
typedef struct SApVar_vec_panel {
    TApVar_ele_panel * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_panel;


// updates a variable the AP
int HALimpl_100_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for panel
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_panel * pV =(TApVar_vec_panel *) pVarData;
	TApVar_ele_panel * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a panel vector
		TApVar_vec_panel * pV = (TApVar_vec_panel *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for panel
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_panel)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_100_create ( unsigned int numberOfElements ) {
 // create a new panel vector
	TApVar_vec_panel * pV;
	 
	pV = malloc(sizeof(TApVar_vec_panel));
	if (!pV) {
	    return NULL;
	}
	// create the elements for panel
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_panel)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for panel
	TApVar_vec_panel * pV =(TApVar_vec_panel *) pVarData;
	TApVar_ele_panel * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_100_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_100_delete ( void * pVarData ) {
 // frees a panel vector
	TApVar_vec_panel * pV = (TApVar_vec_panel *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="359">// ===============================
// variable implementation for button (varID=101)
// ===============================

// element structure for button
typedef struct SApVar_ele_button {
} TApVar_ele_button;

// vector structure for button
typedef struct SApVar_vec_button {
    TApVar_ele_button * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_button;


// updates a variable the AP
int HALimpl_101_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for button
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_button * pV =(TApVar_vec_button *) pVarData;
	TApVar_ele_button * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a button vector
		TApVar_vec_button * pV = (TApVar_vec_button *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for button
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_button)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_101_create ( unsigned int numberOfElements ) {
 // create a new button vector
	TApVar_vec_button * pV;
	 
	pV = malloc(sizeof(TApVar_vec_button));
	if (!pV) {
	    return NULL;
	}
	// create the elements for button
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_button)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_101_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for button
	TApVar_vec_button * pV =(TApVar_vec_button *) pVarData;
	TApVar_ele_button * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_101_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_101_delete ( void * pVarData ) {
 // frees a button vector
	TApVar_vec_button * pV = (TApVar_vec_button *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="360">// ===============================
// variable implementation for led (varID=102)
// ===============================

// element structure for led
typedef struct SApVar_ele_led {
} TApVar_ele_led;

// vector structure for led
typedef struct SApVar_vec_led {
    TApVar_ele_led * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_led;


// updates a variable the AP
int HALimpl_102_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for led
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_led * pV =(TApVar_vec_led *) pVarData;
	TApVar_ele_led * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a led vector
		TApVar_vec_led * pV = (TApVar_vec_led *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for led
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_led)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_102_create ( unsigned int numberOfElements ) {
 // create a new led vector
	TApVar_vec_led * pV;
	 
	pV = malloc(sizeof(TApVar_vec_led));
	if (!pV) {
	    return NULL;
	}
	// create the elements for led
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_led)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for led
	TApVar_vec_led * pV =(TApVar_vec_led *) pVarData;
	TApVar_ele_led * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_102_decodeData ( void * pVarData ) {
 return pVarData; 
}
// delete the variable
void HALimpl_102_delete ( void * pVarData ) {
 // frees a led vector
	TApVar_vec_led * pV = (TApVar_vec_led *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code><Code idCode="361">// ===============================
// variable implementation for display (varID=103)
// ===============================

// element structure for display
typedef struct SApVar_ele_display {
} TApVar_ele_display;

// vector structure for display
typedef struct SApVar_vec_display {
    TApVar_ele_display * pFE; // first element at the vector
    int32_t num; // amount of elements at the vector
} TApVar_vec_display;


// updates a variable the AP
int HALimpl_103_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function for display
	uint32_t * pD = (uint32_t *) pMsgData;
	TApVar_vec_display * pV =(TApVar_vec_display *) pVarData;
	TApVar_ele_display * pE;
	int i, imax;
	
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	imax = (int) *((int32_t *)pD);
	pD++;
	// 1. resize vector if needed
	if (pV-&gt;num != imax) {
	    // frees a display vector
		TApVar_vec_display * pV = (TApVar_vec_display *) pVarData;
		
		if (pV) {
		    if (pV-&gt;pFE) {
		        
		        free(pV-&gt;pFE);
		        pV-&gt;pFE = NULL;
		        pV-&gt;num = 0;
		    }
		}
	    // create the elements for display
		pV-&gt;pFE = malloc(sizeof(TApVar_ele_display)*imax);
		if (!pV-&gt;pFE) {
		    free(pV);
		    return -1;
		}
		pV-&gt;num = imax;
	}
	
	// 2. fill parameters
	pE = pV-&gt;pFE;
	
	for (i = 0; i &lt; imax; i++) {
	    
	    // goto next element
	    pE++;
	}
	return 0; 
}
// create a new variable
void * HALimpl_103_create ( unsigned int numberOfElements ) {
 // create a new display vector
	TApVar_vec_display * pV;
	 
	pV = malloc(sizeof(TApVar_vec_display));
	if (!pV) {
	    return NULL;
	}
	// create the elements for display
	pV-&gt;pFE = malloc(sizeof(TApVar_ele_display)*numberOfElements);
	if (!pV-&gt;pFE) {
	    free(pV);
	    return NULL;
	}
	pV-&gt;num = numberOfElements;
	return pV; 
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
  // tx function for display
	TApVar_vec_display * pV =(TApVar_vec_display *) pVarData;
	TApVar_ele_display * pE;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	
	int32_t dataAmount;
	int32_t n;
	
	// calc ammount of transmission bytes 
	dataAmount = (int32_t) 1 + pV-&gt;num * 0;
	
	    
	// 1 send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	        
	// 2 send vector elementwise
	
	// 2.1 send amount of elements at the vector
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pV-&gt;num);
	
	// 2.2 send element
	pE = pV-&gt;pFE;
	for (n = 0; n &lt; pV-&gt;num; n++) {
	    
	    // inc
	    pE++;
	}
	return 0; 
}
// decode data for the HAL functions
void * HALimpl_103_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_103_delete ( void * pVarData ) {
 // frees a display vector
	TApVar_vec_display * pV = (TApVar_vec_display *) pVarData;
	
	if (pV) {
	    if (pV-&gt;pFE) {
	        
	        free(pV-&gt;pFE);
	        }
	    free(pV);
	} 
}
</Code></Code_List><Compiler_List><Compiler AR="ar" ASM="as" CC="gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="" CXX="g++" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="" LINK="$SMARTLINK" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="$__RPATH" OBJSUFFIX=".o" OperatingSystem="windows" description="the gcc toolchain" idCompiler="1" name="gcc for Windows"/><Compiler AR="elfar" ASM="easm21k" CC="cc21k" CCCOM="$CC $CFLAGS $CCFLAGS $_CCCOMCOM -O0 -g -c -structs-do-not-overlap -no-multiline -double-size-32 -warn-protos -si-revision 0.1 -proc ADSP-21369 -o $TARGET $SOURCES" CCFLAGS="" CXX="cc21k" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="" LINK="$SMARTLINK" LINKCOM="$LINK -T ../libs/main.ldf -flags-link $SOURCES -o $TARGET -proc ADSP-21369 -si-revision 0.1 -flags-link" LINKFLAGS="$__RPATH" OBJSUFFIX=".o" OperatingSystem="ADSP" description="the ADSP toolchain" idCompiler="2" name="ADSP 21369"/><Compiler AR="msp430-ar" ASM="msp430-as" CC="msp430-gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="-mmcu=msp430f169" CXX="msp430-g++" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="-mmcu=msp430f169" LINK="$SMARTLINK" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="$__RPATH -mmcu=msp430f169" OBJSUFFIX=".o" OperatingSystem="windows &amp; linux" description="the msp430-gcc toolchain" idCompiler="3" name="msp430-gcc for msp430169F"/><Compiler AR="ar" ASM="as" CC="gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="" CXX="g++" CXXCOM="" CXXFLAGS="" LINK="gcc" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="" OBJSUFFIX=".o" OperatingSystem="linux" description="linux gcc" idCompiler="4" name="LinuxGCC"/></Compiler_List><CompilerLib_List/><CompilerLibPath_List><CompilerLibPath idCompiler="1" idCompilerLibPath="1" path="D:\Promotion\python\APgen\libs"/><CompilerLibPath idCompiler="2" idCompilerLibPath="2" path="C:\Program Files\Analog Devices\VisualDSP 5.0\213xx\lib"/></CompilerLibPath_List><CompilerIncludePath_List><CompilerIncludePath idCompiler="1" idCompilerIncludePath="1" path="D:\Promotion\python\APgen\includes"/><CompilerIncludePath idCompiler="2" idCompilerIncludePath="2" path="C:\Program Files\Analog Devices\VisualDSP 5.0\213xx\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="3" path="C:\MinGW\include\gtk-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="4" path="C:\MinGW\include\atk-1.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="5" path="C:\MinGW\include\gdk-pixbuf-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="6" path="C:\MinGW\lib\gtk-2.0\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="7" path="C:\MinGW\include\pango-1.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="8" path="C:\MinGW\include\glib-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="9" path="C:\MinGW\include\glib-2.0\glib"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="10" path="C:\MinGW\lib\glib-2.0\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="11" path="C:\MinGW\include\cairo"/><CompilerIncludePath idCompiler="3" idCompilerIncludePath="12" path="C:\MinGW\msp430\include"/></CompilerIncludePath_List><ImplHALFunction_List><ImplHALFunction descr="increment / decrement instruction pointer" fid="50" idCode="56" idImplGroup="0" idImplHALFunction="9"/><ImplHALFunction descr="reads a sample form a wav file" fid="60" idCode="81" idImplGroup="3" idImplHALFunction="14"/><ImplHALFunction descr="writes a sample to a wav file" fid="61" idCode="82" idImplGroup="3" idImplHALFunction="15"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="114" idImplGroup="5" idImplHALFunction="32"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="115" idImplGroup="5" idImplHALFunction="33"/><ImplHALFunction descr="processes the IFFT" fid="133" idCode="120" idImplGroup="4" idImplHALFunction="37"/><ImplHALFunction descr="inits the fft structure as real input fft" fid="130" idCode="121" idImplGroup="4" idImplHALFunction="38"/><ImplHALFunction descr="inits the fft structure as ifft" fid="131" idCode="122" idImplGroup="4" idImplHALFunction="39"/><ImplHALFunction descr="processes the FFT" fid="132" idCode="123" idImplGroup="4" idImplHALFunction="40"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="127" idImplGroup="6" idImplHALFunction="41"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="137" idImplGroup="6" idImplHALFunction="46"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="141" idImplGroup="7" idImplHALFunction="48"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="142" idImplGroup="7" idImplHALFunction="49"/><ImplHALFunction descr="sets the dimension of the UI" fid="200" idCode="172" idImplGroup="11" idImplHALFunction="59"/><ImplHALFunction descr="inits a panel" fid="201" idCode="177" idImplGroup="11" idImplHALFunction="64"/><ImplHALFunction descr="inits a button" fid="202" idCode="178" idImplGroup="11" idImplHALFunction="65"/><ImplHALFunction descr="inits a display" fid="203" idCode="179" idImplGroup="11" idImplHALFunction="66"/><ImplHALFunction descr="inits a LED" fid="204" idCode="180" idImplGroup="11" idImplHALFunction="67"/><ImplHALFunction descr="check button state" fid="210" idCode="182" idImplGroup="11" idImplHALFunction="68"/><ImplHALFunction descr="set LED state" fid="211" idCode="183" idImplGroup="11" idImplHALFunction="69"/><ImplHALFunction descr="increment / decrement instruction pointer if the CF is set" fid="51" idCode="184" idImplGroup="0" idImplHALFunction="70"/><ImplHALFunction descr="increment / decrement instruction pointer if the CF is not set" fid="52" idCode="185" idImplGroup="0" idImplHALFunction="71"/><ImplHALFunction descr="sets the CF" fid="55" idCode="186" idImplGroup="0" idImplHALFunction="72"/><ImplHALFunction descr="setup string" fid="5" idCode="189" idImplGroup="12" idImplHALFunction="73"/><ImplHALFunction descr="set string chars" fid="6" idCode="190" idImplGroup="12" idImplHALFunction="74"/><ImplHALFunction descr="set display text" fid="212" idCode="191" idImplGroup="11" idImplHALFunction="75"/><ImplHALFunction descr="a = const val" fid="20" idCode="197" idImplGroup="1" idImplHALFunction="76"/><ImplHALFunction descr="a = b" fid="21" idCode="198" idImplGroup="1" idImplHALFunction="77"/><ImplHALFunction descr="c = a + b" fid="22" idCode="199" idImplGroup="1" idImplHALFunction="78"/><ImplHALFunction descr="c = a - b" fid="23" idCode="200" idImplGroup="1" idImplHALFunction="79"/><ImplHALFunction descr="c = a * b" fid="24" idCode="201" idImplGroup="1" idImplHALFunction="80"/><ImplHALFunction descr="c = a / b" fid="25" idCode="202" idImplGroup="1" idImplHALFunction="81"/><ImplHALFunction descr="c = modulo(a ,b)" fid="26" idCode="203" idImplGroup="1" idImplHALFunction="82"/><ImplHALFunction descr="a&lt;b" fid="40" idCode="211" idImplGroup="1" idImplHALFunction="83"/><ImplHALFunction descr="a&gt;b" fid="41" idCode="212" idImplGroup="1" idImplHALFunction="84"/><ImplHALFunction descr="a==b" fid="42" idCode="213" idImplGroup="1" idImplHALFunction="85"/><ImplHALFunction descr="a&lt;&gt;b" fid="43" idCode="214" idImplGroup="1" idImplHALFunction="86"/><ImplHALFunction descr="a&lt;=b" fid="44" idCode="215" idImplGroup="1" idImplHALFunction="87"/><ImplHALFunction descr="a=&gt;b" fid="45" idCode="216" idImplGroup="1" idImplHALFunction="88"/><ImplHALFunction descr="updates a variable" fid="56" idCode="220" idImplGroup="0" idImplHALFunction="89"/><ImplHALFunction descr="sets the dimension of the UI (emty because of real hardware)" fid="200" idCode="241" idImplGroup="8" idImplHALFunction="90"/><ImplHALFunction descr="inits the panel for MSP430-169STK eval board" fid="201" idCode="242" idImplGroup="8" idImplHALFunction="91"/><ImplHALFunction descr="inits the button for MSP430-169STK eval board" fid="202" idCode="243" idImplGroup="8" idImplHALFunction="92"/><ImplHALFunction descr="inits the display for MSP430-169STK eval board" fid="203" idCode="244" idImplGroup="8" idImplHALFunction="93"/><ImplHALFunction descr="inits the LED for MSP430-169STK eval board" fid="204" idCode="245" idImplGroup="8" idImplHALFunction="94"/><ImplHALFunction descr="checks a button at the MSP430-169STK eval board" fid="210" idCode="246" idImplGroup="8" idImplHALFunction="95"/><ImplHALFunction descr="sets a LED at the MSP430-169STK eval board" fid="211" idCode="247" idImplGroup="8" idImplHALFunction="96"/><ImplHALFunction descr="sets a display text at the MSP430-169STK eval board" fid="212" idCode="248" idImplGroup="8" idImplHALFunction="97"/><ImplHALFunction descr="inits a biquad at the cascade as high pass filter" fid="100" idCode="251" idImplGroup="13" idImplHALFunction="98"/><ImplHALFunction descr="inits a biquad at the cascade as low pass filter" fid="101" idCode="253" idImplGroup="13" idImplHALFunction="99"/><ImplHALFunction descr="inits a biquad at the cascade as boost/cut peak filter" fid="102" idCode="254" idImplGroup="13" idImplHALFunction="100"/><ImplHALFunction descr="inits a biquad at the cascade as low frequency boost/cut shelving filter" fid="103" idCode="255" idImplGroup="13" idImplHALFunction="101"/><ImplHALFunction descr="inits a biquad at the cascade as low frequency boost/cut shelving filter" fid="104" idCode="256" idImplGroup="13" idImplHALFunction="102"/><ImplHALFunction descr="convolutes a vector of samples with a biquad cascade" fid="110" idCode="257" idImplGroup="13" idImplHALFunction="103"/><ImplHALFunction descr="a = const val" fid="27" idCode="259" idImplGroup="1" idImplHALFunction="104"/><ImplHALFunction descr="a = b" fid="28" idCode="260" idImplGroup="1" idImplHALFunction="105"/><ImplHALFunction descr="c = a + b" fid="29" idCode="261" idImplGroup="1" idImplHALFunction="106"/><ImplHALFunction descr="c = a - b" fid="30" idCode="262" idImplGroup="1" idImplHALFunction="107"/><ImplHALFunction descr="c = a * b" fid="31" idCode="263" idImplGroup="1" idImplHALFunction="108"/><ImplHALFunction descr="c = a / b" fid="32" idCode="264" idImplGroup="1" idImplHALFunction="109"/><ImplHALFunction descr="c = modulo(a ,b)" fid="33" idCode="265" idImplGroup="1" idImplHALFunction="110"/><ImplHALFunction descr="a&lt;b" fid="34" idCode="266" idImplGroup="1" idImplHALFunction="111"/><ImplHALFunction descr="a&gt;b" fid="35" idCode="267" idImplGroup="1" idImplHALFunction="112"/><ImplHALFunction descr="a==b" fid="36" idCode="268" idImplGroup="1" idImplHALFunction="113"/><ImplHALFunction descr="a&lt;&gt;b" fid="37" idCode="269" idImplGroup="1" idImplHALFunction="114"/><ImplHALFunction descr="a&lt;=b" fid="38" idCode="270" idImplGroup="1" idImplHALFunction="115"/><ImplHALFunction descr="a=&gt;b" fid="39" idCode="271" idImplGroup="1" idImplHALFunction="116"/><ImplHALFunction descr="inits a noisegate" fid="111" idCode="273" idImplGroup="14" idImplHALFunction="117"/><ImplHALFunction descr="inits a expander" fid="112" idCode="274" idImplGroup="14" idImplHALFunction="118"/><ImplHALFunction descr="inits a compressor" fid="113" idCode="275" idImplGroup="14" idImplHALFunction="119"/><ImplHALFunction descr="inits a limiter" fid="114" idCode="276" idImplGroup="14" idImplHALFunction="120"/><ImplHALFunction descr="stream samples through a noisegate" fid="115" idCode="277" idImplGroup="14" idImplHALFunction="121"/><ImplHALFunction descr="stream samples through a expander" fid="116" idCode="278" idImplGroup="14" idImplHALFunction="122"/><ImplHALFunction descr="stream samples through a compressor" fid="117" idCode="279" idImplGroup="14" idImplHALFunction="123"/><ImplHALFunction descr="stream samples through a limiter" fid="118" idCode="280" idImplGroup="14" idImplHALFunction="124"/><ImplHALFunction descr="concat two strings s1 &amp; s2 -&gt; s1" fid="7" idCode="285" idImplGroup="12" idImplHALFunction="125"/><ImplHALFunction descr="converts a rational to a string(size of the string is keept untouched)" fid="8" idCode="286" idImplGroup="12" idImplHALFunction="126"/><ImplHALFunction descr="converts a integer to a string(size of the string is keept untouched)" fid="9" idCode="287" idImplGroup="12" idImplHALFunction="127"/><ImplHALFunction descr="assigns a string to an other" fid="10" idCode="288" idImplGroup="12" idImplHALFunction="128"/><ImplHALFunction descr="sends a stream of values into the delay and reads them out of it" fid="150" idCode="307" idImplGroup="15" idImplHALFunction="129"/><ImplHALFunction descr="inits the delay" fid="151" idCode="308" idImplGroup="15" idImplHALFunction="130"/><ImplHALFunction descr="inits a generic biquad with it coefficients" fid="105" idCode="312" idImplGroup="13" idImplHALFunction="131"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="324" idImplGroup="16" idImplHALFunction="133"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="325" idImplGroup="16" idImplHALFunction="134"/><ImplHALFunction descr="sets the dimension of the UI (emty because of real hardware)" fid="200" idCode="333" idImplGroup="17" idImplHALFunction="135"/><ImplHALFunction descr="inits the panel for PiFace" fid="201" idCode="334" idImplGroup="17" idImplHALFunction="136"/><ImplHALFunction descr="inits the button for the PiFace" fid="202" idCode="335" idImplGroup="17" idImplHALFunction="137"/><ImplHALFunction descr="inits the display for the PiFace" fid="203" idCode="336" idImplGroup="17" idImplHALFunction="138"/><ImplHALFunction descr="inits a LED for the PiFace" fid="204" idCode="337" idImplGroup="17" idImplHALFunction="139"/><ImplHALFunction descr="checks a button at the PiFace" fid="210" idCode="338" idImplGroup="17" idImplHALFunction="140"/><ImplHALFunction descr="sets a LED at the PiFace" fid="211" idCode="339" idImplGroup="17" idImplHALFunction="141"/><ImplHALFunction descr="sets a display text at the PiFace" fid="212" idCode="340" idImplGroup="17" idImplHALFunction="142"/><ImplHALFunction descr="set string chars2" fid="6" idCode="344" idImplGroup="12" idImplHALFunction="143"/><ImplHALFunction descr="set display text dimenions" fid="213" idCode="353" idImplGroup="11" idImplHALFunction="144"/><ImplHALFunction descr="set display text dimenions for the PiFace" fid="213" idCode="354" idImplGroup="17" idImplHALFunction="145"/></ImplHALFunction_List><ImplHALVariable_List><ImplHALVariable VariableID="4" descr="complex number used/defined at the fftw3 libary" idCode="99" idImplGroup="4" idImplHALVariable="9"/><ImplHALVariable VariableID="30" descr="FFT / IFFT structure for performing ffts and iffts" idCode="116" idImplGroup="4" idImplHALVariable="10"/><ImplHALVariable VariableID="3" descr="string based on stdlib" idCode="192" idImplGroup="12" idImplHALVariable="17"/><ImplHALVariable VariableID="100" descr="panel type in gtk+ style" idCode="193" idImplGroup="11" idImplHALVariable="18"/><ImplHALVariable VariableID="101" descr="button type in gtk+ style" idCode="194" idImplGroup="11" idImplHALVariable="19"/><ImplHALVariable VariableID="102" descr="LED type in gtk+ style" idCode="195" idImplGroup="11" idImplHALVariable="20"/><ImplHALVariable VariableID="103" descr="display type in gtk+ style" idCode="196" idImplGroup="11" idImplHALVariable="21"/><ImplHALVariable VariableID="2" descr="super generic integer" idCode="210" idImplGroup="1" idImplHALVariable="22"/><ImplHALVariable VariableID="1" descr="super generic rational" idCode="228" idImplGroup="1" idImplHALVariable="23"/><ImplHALVariable VariableID="100" descr="panel type for MSP430-169STK eval board" idCode="237" idImplGroup="8" idImplHALVariable="24"/><ImplHALVariable VariableID="101" descr="button type for MSP430-169STK eval board" idCode="238" idImplGroup="8" idImplHALVariable="25"/><ImplHALVariable VariableID="102" descr="LED type for MSP430-169STK eval board" idCode="239" idImplGroup="8" idImplHALVariable="26"/><ImplHALVariable VariableID="103" descr="display type for MSP430-169STK eval board" idCode="240" idImplGroup="8" idImplHALVariable="27"/><ImplHALVariable VariableID="10" descr="super generic biquad" idCode="252" idImplGroup="13" idImplHALVariable="28"/><ImplHALVariable VariableID="11" descr="generic noisegate" idCode="281" idImplGroup="14" idImplHALVariable="29"/><ImplHALVariable VariableID="12" descr="generic expander" idCode="282" idImplGroup="14" idImplHALVariable="30"/><ImplHALVariable VariableID="13" descr="generic compressor" idCode="283" idImplGroup="14" idImplHALVariable="31"/><ImplHALVariable VariableID="14" descr="generic limiter" idCode="284" idImplGroup="14" idImplHALVariable="32"/><ImplHALVariable VariableID="20" descr="a generic delay" idCode="304" idImplGroup="15" idImplHALVariable="33"/><ImplHALVariable VariableID="10" descr="test biquad" idCode="314" idImplGroup="0" idImplHALVariable="34"/><ImplHALVariable VariableID="100" descr="panel type for PiFace" idCode="329" idImplGroup="17" idImplHALVariable="35"/><ImplHALVariable VariableID="101" descr="button type for PiFace" idCode="330" idImplGroup="17" idImplHALVariable="36"/><ImplHALVariable VariableID="102" descr="led type for PiFace" idCode="331" idImplGroup="17" idImplHALVariable="37"/><ImplHALVariable VariableID="103" descr="display type for PiFace" idCode="332" idImplGroup="17" idImplHALVariable="38"/><ImplHALVariable VariableID="100" descr="panel type dummy implementation" idCode="358" idImplGroup="18" idImplHALVariable="39"/><ImplHALVariable VariableID="101" descr="button type dummy implementation" idCode="359" idImplGroup="18" idImplHALVariable="40"/><ImplHALVariable VariableID="102" descr="LED type dummy implementation" idCode="360" idImplGroup="18" idImplHALVariable="41"/><ImplHALVariable VariableID="103" descr="display type dummy implementation" idCode="361" idImplGroup="18" idImplHALVariable="42"/></ImplHALVariable_List><ImplMsgDriver_List><ImplMsgDriver descr="winAPdrv" idCode="223" idImplGroup="9" idImplMsgDriver="1"/><ImplMsgDriver descr="ADSPuartDRV" idCode="232" idImplGroup="6" idImplMsgDriver="2"/><ImplMsgDriver descr="MSP430uartDRV" idCode="235" idImplGroup="8" idImplMsgDriver="3"/><ImplMsgDriver descr="test code gen" idCode="318" idImplGroup="0" idImplMsgDriver="4"/><ImplMsgDriver descr="UDPsocketDRV" idCode="351" idImplGroup="0" idImplMsgDriver="5"/><ImplMsgDriver descr="TCPsocketDRV" idCode="355" idImplGroup="0" idImplMsgDriver="6"/></ImplMsgDriver_List><ImplAP_List><ImplAP descr="a overlapped frame based wavfile processing AP" idCode="102" idImplAP="4" idImplGroup="5"/><ImplAP descr="a wavfile processing AP" idCode="132" idImplAP="6" idImplGroup="3"/><ImplAP descr="a ADSP AP" idCode="135" idImplAP="7" idImplGroup="6"/><ImplAP descr="a block based wavfile processing AP, x.wav in, y.wav out; both @48000kHz" idCode="143" idImplAP="8" idImplGroup="7"/><ImplAP descr="a super generic AP with multiple threads" idCode="226" idImplAP="10" idImplGroup="10"/><ImplAP descr="a audio processor for the MSP430" idCode="234" idImplAP="11" idImplGroup="8"/><ImplAP descr="(diss) a blockbased wavfile proc. AP" idCode="322" idImplAP="12" idImplGroup="7"/><ImplAP descr="a Port Audio AP 2xinput 2xoutput @44100kHz &amp; 1024Samples" idCode="326" idImplAP="13" idImplGroup="16"/><ImplAP descr="a PiFace RPi GUI audio processor" idCode="341" idImplAP="14" idImplGroup="17"/><ImplAP descr="RPi PortAudio based AP with PiFace UI @44.1kHz and 1024Samples per Channel" idCode="345" idImplAP="15" idImplGroup="16"/></ImplAP_List><ImplGroup_List><ImplGroup idCode="1" idImplGroup="1" name="rational and integer generic"/><ImplGroup idCode="9" idImplGroup="2" name="boost"/><ImplGroup idCode="66" idImplGroup="3" name="libsndfile sample based"/><ImplGroup idCode="98" idImplGroup="4" name="fftw3 &amp; complex"/><ImplGroup idCode="101" idImplGroup="5" name="libsndfile overlapped frame based"/><ImplGroup idCode="124" idImplGroup="6" name="ADSP 21369 blockbased, ADC in, DAC3 &amp; DAC4 out, UART @9600,n,8,1"/><ImplGroup idCode="140" idImplGroup="7" name="libsndfile frame based"/><ImplGroup idCode="145" idImplGroup="8" name="MSP430-169STK"/><ImplGroup idCode="155" idImplGroup="9" name="AP client interface useing stjSocket and APclient functions"/><ImplGroup idCode="161" idImplGroup="10" name="pthreads and semaphores"/><ImplGroup idCode="162" idImplGroup="11" name="gtk+ for Windows"/><ImplGroup idCode="187" idImplGroup="12" name="ANSI C strings"/><ImplGroup idCode="250" idImplGroup="13" name="biquad filters (generic)"/><ImplGroup idCode="272" idImplGroup="14" name="audio dynamic processing (generic)"/><ImplGroup idCode="302" idImplGroup="15" name="delay (generic)"/><ImplGroup idCode="323" idImplGroup="16" name="portAudio frame based"/><ImplGroup idCode="328" idImplGroup="17" name="PiFace"/><ImplGroup idCode="357" idImplGroup="18" name="GUI dummy"/></ImplGroup_List><AP_List><AP descr="a audio processor witch processes wavfiles" idAP="5" idCodeStartup="134" idCompiler="1" name="wavFileAP"/><AP descr="the generic AP for ADSP devices" idAP="6" idCodeStartup="138" idCompiler="2" name="asdp21369gen"/><AP descr="framebased AP fs=48000kHz, in=x.wav, out=y.wav" idAP="7" idCodeStartup="144" idCompiler="1" name="wavFileAPframebased"/><AP descr="generic multi thread AP for testing" idAP="9" idCodeStartup="152" idCompiler="1" name="AP test"/><AP descr="ADSP with UART driver" idAP="10" idCodeStartup="227" idCompiler="2" name="ADSP AP"/><AP descr="a AP for the MSP430-169STK" idAP="11" idCodeStartup="236" idCompiler="3" name="MSP430"/><AP descr="generic multi thread AP for testing" idAP="12" idCodeStartup="258" idCompiler="1" name="APdummy"/><AP descr="generic multi thread AP for testing" idAP="13" idCodeStartup="296" idCompiler="1" name="PC_RC_AP"/><AP descr="dissertation UI PC frontend" idAP="14" idCodeStartup="313" idCompiler="1" name="dissPCui"/><AP descr="framebased AP fs=48000kHz, in=x.wav, out=y.wav" idAP="15" idCodeStartup="320" idCompiler="1" name="dissWavFileAPframebased"/><AP descr="framebased AP fs=441000kHz@1024Samples" idAP="16" idCodeStartup="327" idCompiler="4" name="PortAudioAP"/><AP descr="a UI controller based on the PiFace for the RPi" idAP="17" idCodeStartup="342" idCompiler="4" name="RPi_PiFace"/><AP descr="single thread genric gcc AP" idAP="18" idCodeStartup="343" idCompiler="1" name="AP generic test"/><AP descr="RPi2 with PiFace and PortAudio + TCP driver" idAP="19" idCodeStartup="346" idCompiler="4" name="RPi2"/><AP descr="Win GTK+ TCP AP" idAP="20" idCodeStartup="352" idCompiler="1" name="winGUItcpAP"/><AP descr="gtk+ UART AP" idAP="21" idCodeStartup="356" idCompiler="1" name="winGUIserialAP"/></AP_List><FunctionList_List><FunctionList idAP="5" idFunctionList="38" idImplHALFunction="9"/><FunctionList idAP="5" idFunctionList="39" idImplHALFunction="14"/><FunctionList idAP="5" idFunctionList="40" idImplHALFunction="15"/><FunctionList idAP="6" idFunctionList="47" idImplHALFunction="9"/><FunctionList idAP="6" idFunctionList="54" idImplHALFunction="41"/><FunctionList idAP="6" idFunctionList="55" idImplHALFunction="46"/><FunctionList idAP="7" idFunctionList="58" idImplHALFunction="9"/><FunctionList idAP="7" idFunctionList="62" idImplHALFunction="48"/><FunctionList idAP="7" idFunctionList="63" idImplHALFunction="49"/><FunctionList idAP="10" idFunctionList="101" idImplHALFunction="41"/><FunctionList idAP="10" idFunctionList="102" idImplHALFunction="46"/><FunctionList idAP="10" idFunctionList="103" idImplHALFunction="9"/><FunctionList idAP="10" idFunctionList="104" idImplHALFunction="70"/><FunctionList idAP="10" idFunctionList="105" idImplHALFunction="71"/><FunctionList idAP="10" idFunctionList="106" idImplHALFunction="72"/><FunctionList idAP="10" idFunctionList="107" idImplHALFunction="89"/><FunctionList idAP="11" idFunctionList="108" idImplHALFunction="73"/><FunctionList idAP="11" idFunctionList="109" idImplHALFunction="74"/><FunctionList idAP="11" idFunctionList="110" idImplHALFunction="9"/><FunctionList idAP="11" idFunctionList="111" idImplHALFunction="70"/><FunctionList idAP="11" idFunctionList="112" idImplHALFunction="71"/><FunctionList idAP="11" idFunctionList="113" idImplHALFunction="72"/><FunctionList idAP="11" idFunctionList="114" idImplHALFunction="89"/><FunctionList idAP="11" idFunctionList="115" idImplHALFunction="90"/><FunctionList idAP="11" idFunctionList="116" idImplHALFunction="91"/><FunctionList idAP="11" idFunctionList="117" idImplHALFunction="92"/><FunctionList idAP="11" idFunctionList="118" idImplHALFunction="93"/><FunctionList idAP="11" idFunctionList="119" idImplHALFunction="94"/><FunctionList idAP="11" idFunctionList="120" idImplHALFunction="95"/><FunctionList idAP="11" idFunctionList="121" idImplHALFunction="96"/><FunctionList idAP="11" idFunctionList="122" idImplHALFunction="97"/><FunctionList idAP="11" idFunctionList="129" idImplHALFunction="76"/><FunctionList idAP="11" idFunctionList="130" idImplHALFunction="77"/><FunctionList idAP="11" idFunctionList="131" idImplHALFunction="78"/><FunctionList idAP="11" idFunctionList="132" idImplHALFunction="79"/><FunctionList idAP="11" idFunctionList="133" idImplHALFunction="80"/><FunctionList idAP="11" idFunctionList="134" idImplHALFunction="81"/><FunctionList idAP="11" idFunctionList="135" idImplHALFunction="82"/><FunctionList idAP="11" idFunctionList="136" idImplHALFunction="83"/><FunctionList idAP="11" idFunctionList="137" idImplHALFunction="84"/><FunctionList idAP="11" idFunctionList="138" idImplHALFunction="85"/><FunctionList idAP="11" idFunctionList="139" idImplHALFunction="86"/><FunctionList idAP="11" idFunctionList="140" idImplHALFunction="87"/><FunctionList idAP="11" idFunctionList="141" idImplHALFunction="88"/><FunctionList idAP="12" idFunctionList="142" idImplHALFunction="9"/><FunctionList idAP="12" idFunctionList="143" idImplHALFunction="70"/><FunctionList idAP="12" idFunctionList="144" idImplHALFunction="71"/><FunctionList idAP="12" idFunctionList="145" idImplHALFunction="72"/><FunctionList idAP="12" idFunctionList="146" idImplHALFunction="89"/><FunctionList idAP="12" idFunctionList="147" idImplHALFunction="98"/><FunctionList idAP="12" idFunctionList="148" idImplHALFunction="99"/><FunctionList idAP="12" idFunctionList="149" idImplHALFunction="100"/><FunctionList idAP="12" idFunctionList="150" idImplHALFunction="101"/><FunctionList idAP="12" idFunctionList="151" idImplHALFunction="102"/><FunctionList idAP="12" idFunctionList="152" idImplHALFunction="103"/><FunctionList idAP="12" idFunctionList="153" idImplHALFunction="117"/><FunctionList idAP="12" idFunctionList="154" idImplHALFunction="118"/><FunctionList idAP="12" idFunctionList="155" idImplHALFunction="119"/><FunctionList idAP="12" idFunctionList="156" idImplHALFunction="120"/><FunctionList idAP="12" idFunctionList="157" idImplHALFunction="121"/><FunctionList idAP="12" idFunctionList="158" idImplHALFunction="122"/><FunctionList idAP="12" idFunctionList="159" idImplHALFunction="123"/><FunctionList idAP="12" idFunctionList="160" idImplHALFunction="124"/><FunctionList idAP="9" idFunctionList="161" idImplHALFunction="73"/><FunctionList idAP="9" idFunctionList="162" idImplHALFunction="74"/><FunctionList idAP="9" idFunctionList="163" idImplHALFunction="76"/><FunctionList idAP="9" idFunctionList="164" idImplHALFunction="77"/><FunctionList idAP="9" idFunctionList="165" idImplHALFunction="78"/><FunctionList idAP="9" idFunctionList="166" idImplHALFunction="79"/><FunctionList idAP="9" idFunctionList="167" idImplHALFunction="80"/><FunctionList idAP="9" idFunctionList="168" idImplHALFunction="81"/><FunctionList idAP="9" idFunctionList="169" idImplHALFunction="82"/><FunctionList idAP="9" idFunctionList="170" idImplHALFunction="83"/><FunctionList idAP="9" idFunctionList="171" idImplHALFunction="84"/><FunctionList idAP="9" idFunctionList="172" idImplHALFunction="85"/><FunctionList idAP="9" idFunctionList="173" idImplHALFunction="86"/><FunctionList idAP="9" idFunctionList="174" idImplHALFunction="87"/><FunctionList idAP="9" idFunctionList="175" idImplHALFunction="88"/><FunctionList idAP="9" idFunctionList="176" idImplHALFunction="104"/><FunctionList idAP="9" idFunctionList="177" idImplHALFunction="105"/><FunctionList idAP="9" idFunctionList="178" idImplHALFunction="106"/><FunctionList idAP="9" idFunctionList="179" idImplHALFunction="107"/><FunctionList idAP="9" idFunctionList="180" idImplHALFunction="108"/><FunctionList idAP="9" idFunctionList="181" idImplHALFunction="109"/><FunctionList idAP="9" idFunctionList="182" idImplHALFunction="110"/><FunctionList idAP="9" idFunctionList="183" idImplHALFunction="111"/><FunctionList idAP="9" idFunctionList="184" idImplHALFunction="112"/><FunctionList idAP="9" idFunctionList="185" idImplHALFunction="113"/><FunctionList idAP="9" idFunctionList="186" idImplHALFunction="114"/><FunctionList idAP="9" idFunctionList="187" idImplHALFunction="115"/><FunctionList idAP="9" idFunctionList="188" idImplHALFunction="116"/><FunctionList idAP="9" idFunctionList="189" idImplHALFunction="9"/><FunctionList idAP="9" idFunctionList="190" idImplHALFunction="70"/><FunctionList idAP="9" idFunctionList="191" idImplHALFunction="71"/><FunctionList idAP="9" idFunctionList="192" idImplHALFunction="72"/><FunctionList idAP="9" idFunctionList="193" idImplHALFunction="89"/><FunctionList idAP="9" idFunctionList="194" idImplHALFunction="98"/><FunctionList idAP="9" idFunctionList="195" idImplHALFunction="99"/><FunctionList idAP="9" idFunctionList="196" idImplHALFunction="100"/><FunctionList idAP="9" idFunctionList="197" idImplHALFunction="101"/><FunctionList idAP="9" idFunctionList="198" idImplHALFunction="102"/><FunctionList idAP="9" idFunctionList="199" idImplHALFunction="103"/><FunctionList idAP="9" idFunctionList="200" idImplHALFunction="117"/><FunctionList idAP="9" idFunctionList="201" idImplHALFunction="118"/><FunctionList idAP="9" idFunctionList="202" idImplHALFunction="119"/><FunctionList idAP="9" idFunctionList="203" idImplHALFunction="120"/><FunctionList idAP="9" idFunctionList="204" idImplHALFunction="121"/><FunctionList idAP="9" idFunctionList="205" idImplHALFunction="122"/><FunctionList idAP="9" idFunctionList="206" idImplHALFunction="123"/><FunctionList idAP="9" idFunctionList="207" idImplHALFunction="124"/><FunctionList idAP="9" idFunctionList="208" idImplHALFunction="59"/><FunctionList idAP="9" idFunctionList="209" idImplHALFunction="64"/><FunctionList idAP="9" idFunctionList="210" idImplHALFunction="65"/><FunctionList idAP="9" idFunctionList="211" idImplHALFunction="66"/><FunctionList idAP="9" idFunctionList="212" idImplHALFunction="67"/><FunctionList idAP="9" idFunctionList="213" idImplHALFunction="68"/><FunctionList idAP="9" idFunctionList="214" idImplHALFunction="69"/><FunctionList idAP="9" idFunctionList="215" idImplHALFunction="75"/><FunctionList idAP="12" idFunctionList="216" idImplHALFunction="73"/><FunctionList idAP="12" idFunctionList="217" idImplHALFunction="74"/><FunctionList idAP="12" idFunctionList="218" idImplHALFunction="76"/><FunctionList idAP="12" idFunctionList="219" idImplHALFunction="77"/><FunctionList idAP="12" idFunctionList="220" idImplHALFunction="78"/><FunctionList idAP="12" idFunctionList="221" idImplHALFunction="79"/><FunctionList idAP="12" idFunctionList="222" idImplHALFunction="80"/><FunctionList idAP="12" idFunctionList="223" idImplHALFunction="81"/><FunctionList idAP="12" idFunctionList="224" idImplHALFunction="82"/><FunctionList idAP="12" idFunctionList="225" idImplHALFunction="83"/><FunctionList idAP="12" idFunctionList="226" idImplHALFunction="84"/><FunctionList idAP="12" idFunctionList="227" idImplHALFunction="85"/><FunctionList idAP="12" idFunctionList="228" idImplHALFunction="86"/><FunctionList idAP="12" idFunctionList="229" idImplHALFunction="87"/><FunctionList idAP="12" idFunctionList="230" idImplHALFunction="88"/><FunctionList idAP="12" idFunctionList="231" idImplHALFunction="104"/><FunctionList idAP="12" idFunctionList="232" idImplHALFunction="105"/><FunctionList idAP="12" idFunctionList="233" idImplHALFunction="106"/><FunctionList idAP="12" idFunctionList="234" idImplHALFunction="107"/><FunctionList idAP="12" idFunctionList="235" idImplHALFunction="108"/><FunctionList idAP="12" idFunctionList="236" idImplHALFunction="109"/><FunctionList idAP="12" idFunctionList="237" idImplHALFunction="110"/><FunctionList idAP="12" idFunctionList="238" idImplHALFunction="111"/><FunctionList idAP="12" idFunctionList="239" idImplHALFunction="112"/><FunctionList idAP="12" idFunctionList="240" idImplHALFunction="113"/><FunctionList idAP="12" idFunctionList="241" idImplHALFunction="114"/><FunctionList idAP="12" idFunctionList="242" idImplHALFunction="115"/><FunctionList idAP="12" idFunctionList="243" idImplHALFunction="116"/><FunctionList idAP="12" idFunctionList="244" idImplHALFunction="59"/><FunctionList idAP="12" idFunctionList="245" idImplHALFunction="64"/><FunctionList idAP="12" idFunctionList="246" idImplHALFunction="65"/><FunctionList idAP="12" idFunctionList="247" idImplHALFunction="66"/><FunctionList idAP="12" idFunctionList="248" idImplHALFunction="67"/><FunctionList idAP="12" idFunctionList="249" idImplHALFunction="68"/><FunctionList idAP="12" idFunctionList="250" idImplHALFunction="69"/><FunctionList idAP="12" idFunctionList="251" idImplHALFunction="75"/><FunctionList idAP="12" idFunctionList="252" idImplHALFunction="125"/><FunctionList idAP="12" idFunctionList="253" idImplHALFunction="126"/><FunctionList idAP="12" idFunctionList="254" idImplHALFunction="127"/><FunctionList idAP="12" idFunctionList="255" idImplHALFunction="128"/><FunctionList idAP="9" idFunctionList="256" idImplHALFunction="125"/><FunctionList idAP="9" idFunctionList="257" idImplHALFunction="126"/><FunctionList idAP="9" idFunctionList="258" idImplHALFunction="127"/><FunctionList idAP="9" idFunctionList="259" idImplHALFunction="128"/><FunctionList idAP="10" idFunctionList="260" idImplHALFunction="76"/><FunctionList idAP="10" idFunctionList="261" idImplHALFunction="77"/><FunctionList idAP="10" idFunctionList="262" idImplHALFunction="78"/><FunctionList idAP="10" idFunctionList="263" idImplHALFunction="79"/><FunctionList idAP="10" idFunctionList="264" idImplHALFunction="80"/><FunctionList idAP="10" idFunctionList="265" idImplHALFunction="81"/><FunctionList idAP="10" idFunctionList="266" idImplHALFunction="82"/><FunctionList idAP="10" idFunctionList="267" idImplHALFunction="83"/><FunctionList idAP="10" idFunctionList="268" idImplHALFunction="84"/><FunctionList idAP="10" idFunctionList="269" idImplHALFunction="85"/><FunctionList idAP="10" idFunctionList="270" idImplHALFunction="86"/><FunctionList idAP="10" idFunctionList="271" idImplHALFunction="87"/><FunctionList idAP="10" idFunctionList="272" idImplHALFunction="88"/><FunctionList idAP="10" idFunctionList="273" idImplHALFunction="104"/><FunctionList idAP="10" idFunctionList="274" idImplHALFunction="105"/><FunctionList idAP="10" idFunctionList="275" idImplHALFunction="106"/><FunctionList idAP="10" idFunctionList="276" idImplHALFunction="107"/><FunctionList idAP="10" idFunctionList="277" idImplHALFunction="108"/><FunctionList idAP="10" idFunctionList="278" idImplHALFunction="109"/><FunctionList idAP="10" idFunctionList="279" idImplHALFunction="110"/><FunctionList idAP="10" idFunctionList="280" idImplHALFunction="111"/><FunctionList idAP="10" idFunctionList="281" idImplHALFunction="112"/><FunctionList idAP="10" idFunctionList="282" idImplHALFunction="113"/><FunctionList idAP="10" idFunctionList="283" idImplHALFunction="114"/><FunctionList idAP="10" idFunctionList="284" idImplHALFunction="115"/><FunctionList idAP="10" idFunctionList="285" idImplHALFunction="116"/><FunctionList idAP="10" idFunctionList="286" idImplHALFunction="98"/><FunctionList idAP="10" idFunctionList="287" idImplHALFunction="99"/><FunctionList idAP="10" idFunctionList="288" idImplHALFunction="100"/><FunctionList idAP="10" idFunctionList="289" idImplHALFunction="101"/><FunctionList idAP="10" idFunctionList="290" idImplHALFunction="102"/><FunctionList idAP="10" idFunctionList="291" idImplHALFunction="103"/><FunctionList idAP="13" idFunctionList="292" idImplHALFunction="73"/><FunctionList idAP="13" idFunctionList="293" idImplHALFunction="74"/><FunctionList idAP="13" idFunctionList="294" idImplHALFunction="125"/><FunctionList idAP="13" idFunctionList="295" idImplHALFunction="126"/><FunctionList idAP="13" idFunctionList="296" idImplHALFunction="127"/><FunctionList idAP="13" idFunctionList="297" idImplHALFunction="128"/><FunctionList idAP="13" idFunctionList="298" idImplHALFunction="76"/><FunctionList idAP="13" idFunctionList="299" idImplHALFunction="77"/><FunctionList idAP="13" idFunctionList="300" idImplHALFunction="78"/><FunctionList idAP="13" idFunctionList="301" idImplHALFunction="79"/><FunctionList idAP="13" idFunctionList="302" idImplHALFunction="80"/><FunctionList idAP="13" idFunctionList="303" idImplHALFunction="81"/><FunctionList idAP="13" idFunctionList="304" idImplHALFunction="82"/><FunctionList idAP="13" idFunctionList="305" idImplHALFunction="83"/><FunctionList idAP="13" idFunctionList="306" idImplHALFunction="84"/><FunctionList idAP="13" idFunctionList="307" idImplHALFunction="85"/><FunctionList idAP="13" idFunctionList="308" idImplHALFunction="86"/><FunctionList idAP="13" idFunctionList="309" idImplHALFunction="87"/><FunctionList idAP="13" idFunctionList="310" idImplHALFunction="88"/><FunctionList idAP="13" idFunctionList="311" idImplHALFunction="104"/><FunctionList idAP="13" idFunctionList="312" idImplHALFunction="105"/><FunctionList idAP="13" idFunctionList="313" idImplHALFunction="106"/><FunctionList idAP="13" idFunctionList="314" idImplHALFunction="107"/><FunctionList idAP="13" idFunctionList="315" idImplHALFunction="108"/><FunctionList idAP="13" idFunctionList="316" idImplHALFunction="109"/><FunctionList idAP="13" idFunctionList="317" idImplHALFunction="110"/><FunctionList idAP="13" idFunctionList="318" idImplHALFunction="111"/><FunctionList idAP="13" idFunctionList="319" idImplHALFunction="112"/><FunctionList idAP="13" idFunctionList="320" idImplHALFunction="113"/><FunctionList idAP="13" idFunctionList="321" idImplHALFunction="114"/><FunctionList idAP="13" idFunctionList="322" idImplHALFunction="115"/><FunctionList idAP="13" idFunctionList="323" idImplHALFunction="116"/><FunctionList idAP="13" idFunctionList="324" idImplHALFunction="9"/><FunctionList idAP="13" idFunctionList="325" idImplHALFunction="70"/><FunctionList idAP="13" idFunctionList="326" idImplHALFunction="71"/><FunctionList idAP="13" idFunctionList="327" idImplHALFunction="72"/><FunctionList idAP="13" idFunctionList="328" idImplHALFunction="89"/><FunctionList idAP="13" idFunctionList="329" idImplHALFunction="98"/><FunctionList idAP="13" idFunctionList="330" idImplHALFunction="99"/><FunctionList idAP="13" idFunctionList="331" idImplHALFunction="100"/><FunctionList idAP="13" idFunctionList="332" idImplHALFunction="101"/><FunctionList idAP="13" idFunctionList="333" idImplHALFunction="102"/><FunctionList idAP="13" idFunctionList="334" idImplHALFunction="103"/><FunctionList idAP="13" idFunctionList="335" idImplHALFunction="59"/><FunctionList idAP="13" idFunctionList="336" idImplHALFunction="64"/><FunctionList idAP="13" idFunctionList="337" idImplHALFunction="65"/><FunctionList idAP="13" idFunctionList="338" idImplHALFunction="66"/><FunctionList idAP="13" idFunctionList="339" idImplHALFunction="67"/><FunctionList idAP="13" idFunctionList="340" idImplHALFunction="68"/><FunctionList idAP="13" idFunctionList="341" idImplHALFunction="69"/><FunctionList idAP="13" idFunctionList="342" idImplHALFunction="75"/><FunctionList idAP="11" idFunctionList="343" idImplHALFunction="105"/><FunctionList idAP="11" idFunctionList="344" idImplHALFunction="104"/><FunctionList idAP="11" idFunctionList="345" idImplHALFunction="106"/><FunctionList idAP="11" idFunctionList="346" idImplHALFunction="107"/><FunctionList idAP="11" idFunctionList="347" idImplHALFunction="108"/><FunctionList idAP="11" idFunctionList="348" idImplHALFunction="109"/><FunctionList idAP="11" idFunctionList="349" idImplHALFunction="110"/><FunctionList idAP="11" idFunctionList="350" idImplHALFunction="111"/><FunctionList idAP="11" idFunctionList="351" idImplHALFunction="112"/><FunctionList idAP="11" idFunctionList="352" idImplHALFunction="113"/><FunctionList idAP="11" idFunctionList="353" idImplHALFunction="114"/><FunctionList idAP="11" idFunctionList="354" idImplHALFunction="115"/><FunctionList idAP="11" idFunctionList="355" idImplHALFunction="116"/><FunctionList idAP="11" idFunctionList="356" idImplHALFunction="98"/><FunctionList idAP="11" idFunctionList="357" idImplHALFunction="99"/><FunctionList idAP="11" idFunctionList="358" idImplHALFunction="100"/><FunctionList idAP="11" idFunctionList="359" idImplHALFunction="101"/><FunctionList idAP="11" idFunctionList="360" idImplHALFunction="102"/><FunctionList idAP="11" idFunctionList="361" idImplHALFunction="103"/><FunctionList idAP="12" idFunctionList="362" idImplHALFunction="129"/><FunctionList idAP="12" idFunctionList="363" idImplHALFunction="130"/><FunctionList idAP="6" idFunctionList="364" idImplHALFunction="76"/><FunctionList idAP="6" idFunctionList="365" idImplHALFunction="77"/><FunctionList idAP="6" idFunctionList="366" idImplHALFunction="78"/><FunctionList idAP="6" idFunctionList="367" idImplHALFunction="79"/><FunctionList idAP="6" idFunctionList="368" idImplHALFunction="80"/><FunctionList idAP="6" idFunctionList="369" idImplHALFunction="81"/><FunctionList idAP="6" idFunctionList="370" idImplHALFunction="82"/><FunctionList idAP="6" idFunctionList="371" idImplHALFunction="83"/><FunctionList idAP="6" idFunctionList="372" idImplHALFunction="84"/><FunctionList idAP="6" idFunctionList="373" idImplHALFunction="85"/><FunctionList idAP="6" idFunctionList="374" idImplHALFunction="86"/><FunctionList idAP="6" idFunctionList="375" idImplHALFunction="87"/><FunctionList idAP="6" idFunctionList="376" idImplHALFunction="88"/><FunctionList idAP="6" idFunctionList="377" idImplHALFunction="104"/><FunctionList idAP="6" idFunctionList="378" idImplHALFunction="105"/><FunctionList idAP="6" idFunctionList="379" idImplHALFunction="106"/><FunctionList idAP="6" idFunctionList="380" idImplHALFunction="107"/><FunctionList idAP="6" idFunctionList="381" idImplHALFunction="108"/><FunctionList idAP="6" idFunctionList="382" idImplHALFunction="109"/><FunctionList idAP="6" idFunctionList="383" idImplHALFunction="110"/><FunctionList idAP="6" idFunctionList="384" idImplHALFunction="111"/><FunctionList idAP="6" idFunctionList="385" idImplHALFunction="112"/><FunctionList idAP="6" idFunctionList="386" idImplHALFunction="113"/><FunctionList idAP="6" idFunctionList="387" idImplHALFunction="114"/><FunctionList idAP="6" idFunctionList="388" idImplHALFunction="115"/><FunctionList idAP="6" idFunctionList="389" idImplHALFunction="116"/><FunctionList idAP="6" idFunctionList="390" idImplHALFunction="70"/><FunctionList idAP="6" idFunctionList="391" idImplHALFunction="71"/><FunctionList idAP="6" idFunctionList="392" idImplHALFunction="72"/><FunctionList idAP="6" idFunctionList="393" idImplHALFunction="89"/><FunctionList idAP="6" idFunctionList="394" idImplHALFunction="117"/><FunctionList idAP="6" idFunctionList="395" idImplHALFunction="118"/><FunctionList idAP="6" idFunctionList="396" idImplHALFunction="119"/><FunctionList idAP="6" idFunctionList="397" idImplHALFunction="120"/><FunctionList idAP="6" idFunctionList="398" idImplHALFunction="121"/><FunctionList idAP="6" idFunctionList="399" idImplHALFunction="122"/><FunctionList idAP="6" idFunctionList="400" idImplHALFunction="123"/><FunctionList idAP="6" idFunctionList="401" idImplHALFunction="124"/><FunctionList idAP="6" idFunctionList="402" idImplHALFunction="129"/><FunctionList idAP="6" idFunctionList="403" idImplHALFunction="130"/><FunctionList idAP="6" idFunctionList="404" idImplHALFunction="98"/><FunctionList idAP="6" idFunctionList="405" idImplHALFunction="99"/><FunctionList idAP="6" idFunctionList="406" idImplHALFunction="100"/><FunctionList idAP="6" idFunctionList="407" idImplHALFunction="101"/><FunctionList idAP="6" idFunctionList="408" idImplHALFunction="102"/><FunctionList idAP="6" idFunctionList="409" idImplHALFunction="103"/><FunctionList idAP="6" idFunctionList="410" idImplHALFunction="131"/><FunctionList idAP="14" idFunctionList="411" idImplHALFunction="73"/><FunctionList idAP="14" idFunctionList="412" idImplHALFunction="74"/><FunctionList idAP="14" idFunctionList="413" idImplHALFunction="125"/><FunctionList idAP="14" idFunctionList="414" idImplHALFunction="126"/><FunctionList idAP="14" idFunctionList="415" idImplHALFunction="127"/><FunctionList idAP="14" idFunctionList="416" idImplHALFunction="128"/><FunctionList idAP="14" idFunctionList="417" idImplHALFunction="76"/><FunctionList idAP="14" idFunctionList="418" idImplHALFunction="77"/><FunctionList idAP="14" idFunctionList="419" idImplHALFunction="78"/><FunctionList idAP="14" idFunctionList="420" idImplHALFunction="79"/><FunctionList idAP="14" idFunctionList="421" idImplHALFunction="80"/><FunctionList idAP="14" idFunctionList="422" idImplHALFunction="81"/><FunctionList idAP="14" idFunctionList="423" idImplHALFunction="82"/><FunctionList idAP="14" idFunctionList="424" idImplHALFunction="83"/><FunctionList idAP="14" idFunctionList="425" idImplHALFunction="84"/><FunctionList idAP="14" idFunctionList="426" idImplHALFunction="85"/><FunctionList idAP="14" idFunctionList="427" idImplHALFunction="86"/><FunctionList idAP="14" idFunctionList="428" idImplHALFunction="87"/><FunctionList idAP="14" idFunctionList="429" idImplHALFunction="88"/><FunctionList idAP="14" idFunctionList="430" idImplHALFunction="104"/><FunctionList idAP="14" idFunctionList="431" idImplHALFunction="105"/><FunctionList idAP="14" idFunctionList="432" idImplHALFunction="106"/><FunctionList idAP="14" idFunctionList="433" idImplHALFunction="107"/><FunctionList idAP="14" idFunctionList="434" idImplHALFunction="108"/><FunctionList idAP="14" idFunctionList="435" idImplHALFunction="109"/><FunctionList idAP="14" idFunctionList="436" idImplHALFunction="110"/><FunctionList idAP="14" idFunctionList="437" idImplHALFunction="111"/><FunctionList idAP="14" idFunctionList="438" idImplHALFunction="112"/><FunctionList idAP="14" idFunctionList="439" idImplHALFunction="113"/><FunctionList idAP="14" idFunctionList="440" idImplHALFunction="114"/><FunctionList idAP="14" idFunctionList="441" idImplHALFunction="115"/><FunctionList idAP="14" idFunctionList="442" idImplHALFunction="116"/><FunctionList idAP="14" idFunctionList="443" idImplHALFunction="9"/><FunctionList idAP="14" idFunctionList="444" idImplHALFunction="70"/><FunctionList idAP="14" idFunctionList="445" idImplHALFunction="71"/><FunctionList idAP="14" idFunctionList="446" idImplHALFunction="72"/><FunctionList idAP="14" idFunctionList="447" idImplHALFunction="89"/><FunctionList idAP="14" idFunctionList="448" idImplHALFunction="98"/><FunctionList idAP="14" idFunctionList="449" idImplHALFunction="99"/><FunctionList idAP="14" idFunctionList="450" idImplHALFunction="100"/><FunctionList idAP="14" idFunctionList="451" idImplHALFunction="101"/><FunctionList idAP="14" idFunctionList="452" idImplHALFunction="102"/><FunctionList idAP="14" idFunctionList="453" idImplHALFunction="103"/><FunctionList idAP="14" idFunctionList="454" idImplHALFunction="131"/><FunctionList idAP="14" idFunctionList="455" idImplHALFunction="117"/><FunctionList idAP="14" idFunctionList="456" idImplHALFunction="118"/><FunctionList idAP="14" idFunctionList="457" idImplHALFunction="119"/><FunctionList idAP="14" idFunctionList="458" idImplHALFunction="120"/><FunctionList idAP="14" idFunctionList="459" idImplHALFunction="121"/><FunctionList idAP="14" idFunctionList="460" idImplHALFunction="122"/><FunctionList idAP="14" idFunctionList="461" idImplHALFunction="123"/><FunctionList idAP="14" idFunctionList="462" idImplHALFunction="124"/><FunctionList idAP="14" idFunctionList="463" idImplHALFunction="129"/><FunctionList idAP="14" idFunctionList="464" idImplHALFunction="130"/><FunctionList idAP="14" idFunctionList="465" idImplHALFunction="59"/><FunctionList idAP="14" idFunctionList="466" idImplHALFunction="64"/><FunctionList idAP="14" idFunctionList="467" idImplHALFunction="65"/><FunctionList idAP="14" idFunctionList="468" idImplHALFunction="66"/><FunctionList idAP="14" idFunctionList="469" idImplHALFunction="67"/><FunctionList idAP="14" idFunctionList="470" idImplHALFunction="68"/><FunctionList idAP="14" idFunctionList="471" idImplHALFunction="69"/><FunctionList idAP="14" idFunctionList="472" idImplHALFunction="75"/><FunctionList idAP="9" idFunctionList="473" idImplHALFunction="129"/><FunctionList idAP="9" idFunctionList="474" idImplHALFunction="130"/><FunctionList idAP="15" idFunctionList="475" idImplHALFunction="76"/><FunctionList idAP="15" idFunctionList="476" idImplHALFunction="77"/><FunctionList idAP="15" idFunctionList="477" idImplHALFunction="78"/><FunctionList idAP="15" idFunctionList="478" idImplHALFunction="79"/><FunctionList idAP="15" idFunctionList="479" idImplHALFunction="80"/><FunctionList idAP="15" idFunctionList="480" idImplHALFunction="81"/><FunctionList idAP="15" idFunctionList="481" idImplHALFunction="82"/><FunctionList idAP="15" idFunctionList="482" idImplHALFunction="83"/><FunctionList idAP="15" idFunctionList="483" idImplHALFunction="84"/><FunctionList idAP="15" idFunctionList="484" idImplHALFunction="85"/><FunctionList idAP="15" idFunctionList="485" idImplHALFunction="86"/><FunctionList idAP="15" idFunctionList="486" idImplHALFunction="87"/><FunctionList idAP="15" idFunctionList="487" idImplHALFunction="88"/><FunctionList idAP="15" idFunctionList="488" idImplHALFunction="104"/><FunctionList idAP="15" idFunctionList="489" idImplHALFunction="105"/><FunctionList idAP="15" idFunctionList="490" idImplHALFunction="106"/><FunctionList idAP="15" idFunctionList="491" idImplHALFunction="107"/><FunctionList idAP="15" idFunctionList="492" idImplHALFunction="108"/><FunctionList idAP="15" idFunctionList="493" idImplHALFunction="109"/><FunctionList idAP="15" idFunctionList="494" idImplHALFunction="110"/><FunctionList idAP="15" idFunctionList="495" idImplHALFunction="111"/><FunctionList idAP="15" idFunctionList="496" idImplHALFunction="112"/><FunctionList idAP="15" idFunctionList="497" idImplHALFunction="113"/><FunctionList idAP="15" idFunctionList="498" idImplHALFunction="114"/><FunctionList idAP="15" idFunctionList="499" idImplHALFunction="115"/><FunctionList idAP="15" idFunctionList="500" idImplHALFunction="116"/><FunctionList idAP="15" idFunctionList="501" idImplHALFunction="9"/><FunctionList idAP="15" idFunctionList="502" idImplHALFunction="70"/><FunctionList idAP="15" idFunctionList="503" idImplHALFunction="71"/><FunctionList idAP="15" idFunctionList="504" idImplHALFunction="72"/><FunctionList idAP="15" idFunctionList="505" idImplHALFunction="89"/><FunctionList idAP="15" idFunctionList="506" idImplHALFunction="48"/><FunctionList idAP="15" idFunctionList="507" idImplHALFunction="49"/><FunctionList idAP="15" idFunctionList="508" idImplHALFunction="98"/><FunctionList idAP="15" idFunctionList="509" idImplHALFunction="99"/><FunctionList idAP="15" idFunctionList="510" idImplHALFunction="100"/><FunctionList idAP="15" idFunctionList="511" idImplHALFunction="101"/><FunctionList idAP="15" idFunctionList="512" idImplHALFunction="102"/><FunctionList idAP="15" idFunctionList="513" idImplHALFunction="103"/><FunctionList idAP="15" idFunctionList="514" idImplHALFunction="131"/><FunctionList idAP="16" idFunctionList="515" idImplHALFunction="73"/><FunctionList idAP="16" idFunctionList="516" idImplHALFunction="74"/><FunctionList idAP="16" idFunctionList="517" idImplHALFunction="125"/><FunctionList idAP="16" idFunctionList="518" idImplHALFunction="126"/><FunctionList idAP="16" idFunctionList="519" idImplHALFunction="127"/><FunctionList idAP="16" idFunctionList="520" idImplHALFunction="128"/><FunctionList idAP="16" idFunctionList="521" idImplHALFunction="76"/><FunctionList idAP="16" idFunctionList="522" idImplHALFunction="77"/><FunctionList idAP="16" idFunctionList="523" idImplHALFunction="78"/><FunctionList idAP="16" idFunctionList="524" idImplHALFunction="79"/><FunctionList idAP="16" idFunctionList="525" idImplHALFunction="80"/><FunctionList idAP="16" idFunctionList="526" idImplHALFunction="81"/><FunctionList idAP="16" idFunctionList="527" idImplHALFunction="82"/><FunctionList idAP="16" idFunctionList="528" idImplHALFunction="83"/><FunctionList idAP="16" idFunctionList="529" idImplHALFunction="84"/><FunctionList idAP="16" idFunctionList="530" idImplHALFunction="85"/><FunctionList idAP="16" idFunctionList="531" idImplHALFunction="86"/><FunctionList idAP="16" idFunctionList="532" idImplHALFunction="87"/><FunctionList idAP="16" idFunctionList="533" idImplHALFunction="88"/><FunctionList idAP="16" idFunctionList="534" idImplHALFunction="104"/><FunctionList idAP="16" idFunctionList="535" idImplHALFunction="105"/><FunctionList idAP="16" idFunctionList="536" idImplHALFunction="106"/><FunctionList idAP="16" idFunctionList="537" idImplHALFunction="107"/><FunctionList idAP="16" idFunctionList="538" idImplHALFunction="108"/><FunctionList idAP="16" idFunctionList="539" idImplHALFunction="109"/><FunctionList idAP="16" idFunctionList="540" idImplHALFunction="110"/><FunctionList idAP="16" idFunctionList="541" idImplHALFunction="111"/><FunctionList idAP="16" idFunctionList="542" idImplHALFunction="112"/><FunctionList idAP="16" idFunctionList="543" idImplHALFunction="113"/><FunctionList idAP="16" idFunctionList="544" idImplHALFunction="114"/><FunctionList idAP="16" idFunctionList="545" idImplHALFunction="115"/><FunctionList idAP="16" idFunctionList="546" idImplHALFunction="116"/><FunctionList idAP="16" idFunctionList="547" idImplHALFunction="9"/><FunctionList idAP="16" idFunctionList="548" idImplHALFunction="70"/><FunctionList idAP="16" idFunctionList="549" idImplHALFunction="71"/><FunctionList idAP="16" idFunctionList="550" idImplHALFunction="72"/><FunctionList idAP="16" idFunctionList="551" idImplHALFunction="89"/><FunctionList idAP="16" idFunctionList="553" idImplHALFunction="133"/><FunctionList idAP="16" idFunctionList="554" idImplHALFunction="134"/><FunctionList idAP="16" idFunctionList="555" idImplHALFunction="117"/><FunctionList idAP="16" idFunctionList="556" idImplHALFunction="118"/><FunctionList idAP="16" idFunctionList="557" idImplHALFunction="119"/><FunctionList idAP="16" idFunctionList="558" idImplHALFunction="120"/><FunctionList idAP="16" idFunctionList="559" idImplHALFunction="121"/><FunctionList idAP="16" idFunctionList="560" idImplHALFunction="122"/><FunctionList idAP="16" idFunctionList="561" idImplHALFunction="123"/><FunctionList idAP="16" idFunctionList="562" idImplHALFunction="124"/><FunctionList idAP="16" idFunctionList="563" idImplHALFunction="98"/><FunctionList idAP="16" idFunctionList="564" idImplHALFunction="99"/><FunctionList idAP="16" idFunctionList="565" idImplHALFunction="100"/><FunctionList idAP="16" idFunctionList="566" idImplHALFunction="101"/><FunctionList idAP="16" idFunctionList="567" idImplHALFunction="102"/><FunctionList idAP="16" idFunctionList="568" idImplHALFunction="103"/><FunctionList idAP="16" idFunctionList="569" idImplHALFunction="131"/><FunctionList idAP="17" idFunctionList="570" idImplHALFunction="73"/><FunctionList idAP="17" idFunctionList="571" idImplHALFunction="74"/><FunctionList idAP="17" idFunctionList="572" idImplHALFunction="125"/><FunctionList idAP="17" idFunctionList="573" idImplHALFunction="126"/><FunctionList idAP="17" idFunctionList="574" idImplHALFunction="127"/><FunctionList idAP="17" idFunctionList="575" idImplHALFunction="128"/><FunctionList idAP="17" idFunctionList="576" idImplHALFunction="76"/><FunctionList idAP="17" idFunctionList="577" idImplHALFunction="77"/><FunctionList idAP="17" idFunctionList="578" idImplHALFunction="78"/><FunctionList idAP="17" idFunctionList="579" idImplHALFunction="79"/><FunctionList idAP="17" idFunctionList="580" idImplHALFunction="80"/><FunctionList idAP="17" idFunctionList="581" idImplHALFunction="81"/><FunctionList idAP="17" idFunctionList="582" idImplHALFunction="82"/><FunctionList idAP="17" idFunctionList="583" idImplHALFunction="83"/><FunctionList idAP="17" idFunctionList="584" idImplHALFunction="84"/><FunctionList idAP="17" idFunctionList="585" idImplHALFunction="85"/><FunctionList idAP="17" idFunctionList="586" idImplHALFunction="86"/><FunctionList idAP="17" idFunctionList="587" idImplHALFunction="87"/><FunctionList idAP="17" idFunctionList="588" idImplHALFunction="88"/><FunctionList idAP="17" idFunctionList="589" idImplHALFunction="104"/><FunctionList idAP="17" idFunctionList="590" idImplHALFunction="105"/><FunctionList idAP="17" idFunctionList="591" idImplHALFunction="106"/><FunctionList idAP="17" idFunctionList="592" idImplHALFunction="107"/><FunctionList idAP="17" idFunctionList="593" idImplHALFunction="108"/><FunctionList idAP="17" idFunctionList="594" idImplHALFunction="109"/><FunctionList idAP="17" idFunctionList="595" idImplHALFunction="110"/><FunctionList idAP="17" idFunctionList="596" idImplHALFunction="111"/><FunctionList idAP="17" idFunctionList="597" idImplHALFunction="112"/><FunctionList idAP="17" idFunctionList="598" idImplHALFunction="113"/><FunctionList idAP="17" idFunctionList="599" idImplHALFunction="114"/><FunctionList idAP="17" idFunctionList="600" idImplHALFunction="115"/><FunctionList idAP="17" idFunctionList="601" idImplHALFunction="116"/><FunctionList idAP="17" idFunctionList="602" idImplHALFunction="9"/><FunctionList idAP="17" idFunctionList="603" idImplHALFunction="70"/><FunctionList idAP="17" idFunctionList="604" idImplHALFunction="71"/><FunctionList idAP="17" idFunctionList="605" idImplHALFunction="72"/><FunctionList idAP="17" idFunctionList="606" idImplHALFunction="89"/><FunctionList idAP="17" idFunctionList="607" idImplHALFunction="98"/><FunctionList idAP="17" idFunctionList="608" idImplHALFunction="99"/><FunctionList idAP="17" idFunctionList="609" idImplHALFunction="100"/><FunctionList idAP="17" idFunctionList="610" idImplHALFunction="101"/><FunctionList idAP="17" idFunctionList="611" idImplHALFunction="102"/><FunctionList idAP="17" idFunctionList="612" idImplHALFunction="103"/><FunctionList idAP="17" idFunctionList="613" idImplHALFunction="131"/><FunctionList idAP="17" idFunctionList="614" idImplHALFunction="117"/><FunctionList idAP="17" idFunctionList="615" idImplHALFunction="118"/><FunctionList idAP="17" idFunctionList="616" idImplHALFunction="119"/><FunctionList idAP="17" idFunctionList="617" idImplHALFunction="120"/><FunctionList idAP="17" idFunctionList="618" idImplHALFunction="121"/><FunctionList idAP="17" idFunctionList="619" idImplHALFunction="122"/><FunctionList idAP="17" idFunctionList="620" idImplHALFunction="123"/><FunctionList idAP="17" idFunctionList="621" idImplHALFunction="124"/><FunctionList idAP="17" idFunctionList="622" idImplHALFunction="129"/><FunctionList idAP="17" idFunctionList="623" idImplHALFunction="130"/><FunctionList idAP="17" idFunctionList="624" idImplHALFunction="135"/><FunctionList idAP="17" idFunctionList="625" idImplHALFunction="136"/><FunctionList idAP="17" idFunctionList="626" idImplHALFunction="137"/><FunctionList idAP="17" idFunctionList="627" idImplHALFunction="138"/><FunctionList idAP="17" idFunctionList="628" idImplHALFunction="139"/><FunctionList idAP="17" idFunctionList="629" idImplHALFunction="140"/><FunctionList idAP="17" idFunctionList="630" idImplHALFunction="141"/><FunctionList idAP="17" idFunctionList="631" idImplHALFunction="142"/><FunctionList idAP="18" idFunctionList="632" idImplHALFunction="73"/><FunctionList idAP="18" idFunctionList="633" idImplHALFunction="74"/><FunctionList idAP="18" idFunctionList="634" idImplHALFunction="125"/><FunctionList idAP="18" idFunctionList="635" idImplHALFunction="126"/><FunctionList idAP="18" idFunctionList="636" idImplHALFunction="127"/><FunctionList idAP="18" idFunctionList="637" idImplHALFunction="128"/><FunctionList idAP="18" idFunctionList="638" idImplHALFunction="76"/><FunctionList idAP="18" idFunctionList="639" idImplHALFunction="77"/><FunctionList idAP="18" idFunctionList="640" idImplHALFunction="78"/><FunctionList idAP="18" idFunctionList="641" idImplHALFunction="79"/><FunctionList idAP="18" idFunctionList="642" idImplHALFunction="80"/><FunctionList idAP="18" idFunctionList="643" idImplHALFunction="81"/><FunctionList idAP="18" idFunctionList="644" idImplHALFunction="82"/><FunctionList idAP="18" idFunctionList="645" idImplHALFunction="83"/><FunctionList idAP="18" idFunctionList="646" idImplHALFunction="84"/><FunctionList idAP="18" idFunctionList="647" idImplHALFunction="85"/><FunctionList idAP="18" idFunctionList="648" idImplHALFunction="86"/><FunctionList idAP="18" idFunctionList="649" idImplHALFunction="87"/><FunctionList idAP="18" idFunctionList="650" idImplHALFunction="88"/><FunctionList idAP="18" idFunctionList="651" idImplHALFunction="104"/><FunctionList idAP="18" idFunctionList="652" idImplHALFunction="105"/><FunctionList idAP="18" idFunctionList="653" idImplHALFunction="106"/><FunctionList idAP="18" idFunctionList="654" idImplHALFunction="107"/><FunctionList idAP="18" idFunctionList="655" idImplHALFunction="108"/><FunctionList idAP="18" idFunctionList="656" idImplHALFunction="109"/><FunctionList idAP="18" idFunctionList="657" idImplHALFunction="110"/><FunctionList idAP="18" idFunctionList="658" idImplHALFunction="111"/><FunctionList idAP="18" idFunctionList="659" idImplHALFunction="112"/><FunctionList idAP="18" idFunctionList="660" idImplHALFunction="113"/><FunctionList idAP="18" idFunctionList="661" idImplHALFunction="114"/><FunctionList idAP="18" idFunctionList="662" idImplHALFunction="115"/><FunctionList idAP="18" idFunctionList="663" idImplHALFunction="116"/><FunctionList idAP="19" idFunctionList="664" idImplHALFunction="73"/><FunctionList idAP="19" idFunctionList="665" idImplHALFunction="74"/><FunctionList idAP="19" idFunctionList="666" idImplHALFunction="125"/><FunctionList idAP="19" idFunctionList="667" idImplHALFunction="126"/><FunctionList idAP="19" idFunctionList="668" idImplHALFunction="127"/><FunctionList idAP="19" idFunctionList="669" idImplHALFunction="128"/><FunctionList idAP="19" idFunctionList="670" idImplHALFunction="76"/><FunctionList idAP="19" idFunctionList="671" idImplHALFunction="77"/><FunctionList idAP="19" idFunctionList="672" idImplHALFunction="78"/><FunctionList idAP="19" idFunctionList="673" idImplHALFunction="79"/><FunctionList idAP="19" idFunctionList="674" idImplHALFunction="80"/><FunctionList idAP="19" idFunctionList="675" idImplHALFunction="81"/><FunctionList idAP="19" idFunctionList="676" idImplHALFunction="82"/><FunctionList idAP="19" idFunctionList="677" idImplHALFunction="83"/><FunctionList idAP="19" idFunctionList="678" idImplHALFunction="84"/><FunctionList idAP="19" idFunctionList="679" idImplHALFunction="85"/><FunctionList idAP="19" idFunctionList="680" idImplHALFunction="86"/><FunctionList idAP="19" idFunctionList="681" idImplHALFunction="87"/><FunctionList idAP="19" idFunctionList="682" idImplHALFunction="88"/><FunctionList idAP="19" idFunctionList="683" idImplHALFunction="104"/><FunctionList idAP="19" idFunctionList="684" idImplHALFunction="105"/><FunctionList idAP="19" idFunctionList="685" idImplHALFunction="106"/><FunctionList idAP="19" idFunctionList="686" idImplHALFunction="107"/><FunctionList idAP="19" idFunctionList="687" idImplHALFunction="108"/><FunctionList idAP="19" idFunctionList="688" idImplHALFunction="109"/><FunctionList idAP="19" idFunctionList="689" idImplHALFunction="110"/><FunctionList idAP="19" idFunctionList="690" idImplHALFunction="111"/><FunctionList idAP="19" idFunctionList="691" idImplHALFunction="112"/><FunctionList idAP="19" idFunctionList="692" idImplHALFunction="113"/><FunctionList idAP="19" idFunctionList="693" idImplHALFunction="114"/><FunctionList idAP="19" idFunctionList="694" idImplHALFunction="115"/><FunctionList idAP="19" idFunctionList="695" idImplHALFunction="116"/><FunctionList idAP="19" idFunctionList="696" idImplHALFunction="9"/><FunctionList idAP="19" idFunctionList="697" idImplHALFunction="70"/><FunctionList idAP="19" idFunctionList="698" idImplHALFunction="71"/><FunctionList idAP="19" idFunctionList="699" idImplHALFunction="72"/><FunctionList idAP="19" idFunctionList="700" idImplHALFunction="89"/><FunctionList idAP="19" idFunctionList="701" idImplHALFunction="133"/><FunctionList idAP="19" idFunctionList="702" idImplHALFunction="134"/><FunctionList idAP="19" idFunctionList="703" idImplHALFunction="98"/><FunctionList idAP="19" idFunctionList="704" idImplHALFunction="99"/><FunctionList idAP="19" idFunctionList="705" idImplHALFunction="100"/><FunctionList idAP="19" idFunctionList="706" idImplHALFunction="101"/><FunctionList idAP="19" idFunctionList="707" idImplHALFunction="102"/><FunctionList idAP="19" idFunctionList="708" idImplHALFunction="103"/><FunctionList idAP="19" idFunctionList="709" idImplHALFunction="131"/><FunctionList idAP="19" idFunctionList="710" idImplHALFunction="117"/><FunctionList idAP="19" idFunctionList="711" idImplHALFunction="118"/><FunctionList idAP="19" idFunctionList="712" idImplHALFunction="119"/><FunctionList idAP="19" idFunctionList="713" idImplHALFunction="120"/><FunctionList idAP="19" idFunctionList="714" idImplHALFunction="121"/><FunctionList idAP="19" idFunctionList="715" idImplHALFunction="122"/><FunctionList idAP="19" idFunctionList="716" idImplHALFunction="123"/><FunctionList idAP="19" idFunctionList="717" idImplHALFunction="124"/><FunctionList idAP="19" idFunctionList="718" idImplHALFunction="129"/><FunctionList idAP="19" idFunctionList="719" idImplHALFunction="130"/><FunctionList idAP="19" idFunctionList="720" idImplHALFunction="135"/><FunctionList idAP="19" idFunctionList="721" idImplHALFunction="136"/><FunctionList idAP="19" idFunctionList="722" idImplHALFunction="137"/><FunctionList idAP="19" idFunctionList="723" idImplHALFunction="138"/><FunctionList idAP="19" idFunctionList="724" idImplHALFunction="139"/><FunctionList idAP="19" idFunctionList="725" idImplHALFunction="140"/><FunctionList idAP="19" idFunctionList="726" idImplHALFunction="141"/><FunctionList idAP="19" idFunctionList="727" idImplHALFunction="142"/><FunctionList idAP="20" idFunctionList="728" idImplHALFunction="73"/><FunctionList idAP="20" idFunctionList="729" idImplHALFunction="74"/><FunctionList idAP="20" idFunctionList="730" idImplHALFunction="125"/><FunctionList idAP="20" idFunctionList="731" idImplHALFunction="126"/><FunctionList idAP="20" idFunctionList="732" idImplHALFunction="127"/><FunctionList idAP="20" idFunctionList="733" idImplHALFunction="128"/><FunctionList idAP="20" idFunctionList="734" idImplHALFunction="76"/><FunctionList idAP="20" idFunctionList="735" idImplHALFunction="77"/><FunctionList idAP="20" idFunctionList="736" idImplHALFunction="78"/><FunctionList idAP="20" idFunctionList="737" idImplHALFunction="79"/><FunctionList idAP="20" idFunctionList="738" idImplHALFunction="80"/><FunctionList idAP="20" idFunctionList="739" idImplHALFunction="81"/><FunctionList idAP="20" idFunctionList="740" idImplHALFunction="82"/><FunctionList idAP="20" idFunctionList="741" idImplHALFunction="83"/><FunctionList idAP="20" idFunctionList="742" idImplHALFunction="84"/><FunctionList idAP="20" idFunctionList="743" idImplHALFunction="85"/><FunctionList idAP="20" idFunctionList="744" idImplHALFunction="86"/><FunctionList idAP="20" idFunctionList="745" idImplHALFunction="87"/><FunctionList idAP="20" idFunctionList="746" idImplHALFunction="88"/><FunctionList idAP="20" idFunctionList="747" idImplHALFunction="104"/><FunctionList idAP="20" idFunctionList="748" idImplHALFunction="105"/><FunctionList idAP="20" idFunctionList="749" idImplHALFunction="106"/><FunctionList idAP="20" idFunctionList="750" idImplHALFunction="107"/><FunctionList idAP="20" idFunctionList="751" idImplHALFunction="108"/><FunctionList idAP="20" idFunctionList="752" idImplHALFunction="109"/><FunctionList idAP="20" idFunctionList="753" idImplHALFunction="110"/><FunctionList idAP="20" idFunctionList="754" idImplHALFunction="111"/><FunctionList idAP="20" idFunctionList="755" idImplHALFunction="112"/><FunctionList idAP="20" idFunctionList="756" idImplHALFunction="113"/><FunctionList idAP="20" idFunctionList="757" idImplHALFunction="114"/><FunctionList idAP="20" idFunctionList="758" idImplHALFunction="115"/><FunctionList idAP="20" idFunctionList="759" idImplHALFunction="116"/><FunctionList idAP="20" idFunctionList="760" idImplHALFunction="9"/><FunctionList idAP="20" idFunctionList="761" idImplHALFunction="70"/><FunctionList idAP="20" idFunctionList="762" idImplHALFunction="71"/><FunctionList idAP="20" idFunctionList="763" idImplHALFunction="72"/><FunctionList idAP="20" idFunctionList="764" idImplHALFunction="89"/><FunctionList idAP="20" idFunctionList="765" idImplHALFunction="98"/><FunctionList idAP="20" idFunctionList="766" idImplHALFunction="99"/><FunctionList idAP="20" idFunctionList="767" idImplHALFunction="100"/><FunctionList idAP="20" idFunctionList="768" idImplHALFunction="101"/><FunctionList idAP="20" idFunctionList="769" idImplHALFunction="102"/><FunctionList idAP="20" idFunctionList="770" idImplHALFunction="103"/><FunctionList idAP="20" idFunctionList="771" idImplHALFunction="131"/><FunctionList idAP="20" idFunctionList="772" idImplHALFunction="117"/><FunctionList idAP="20" idFunctionList="773" idImplHALFunction="118"/><FunctionList idAP="20" idFunctionList="774" idImplHALFunction="119"/><FunctionList idAP="20" idFunctionList="775" idImplHALFunction="120"/><FunctionList idAP="20" idFunctionList="776" idImplHALFunction="121"/><FunctionList idAP="20" idFunctionList="777" idImplHALFunction="122"/><FunctionList idAP="20" idFunctionList="778" idImplHALFunction="123"/><FunctionList idAP="20" idFunctionList="779" idImplHALFunction="124"/><FunctionList idAP="20" idFunctionList="780" idImplHALFunction="129"/><FunctionList idAP="20" idFunctionList="781" idImplHALFunction="130"/><FunctionList idAP="20" idFunctionList="782" idImplHALFunction="59"/><FunctionList idAP="20" idFunctionList="783" idImplHALFunction="64"/><FunctionList idAP="20" idFunctionList="784" idImplHALFunction="65"/><FunctionList idAP="20" idFunctionList="785" idImplHALFunction="66"/><FunctionList idAP="20" idFunctionList="786" idImplHALFunction="67"/><FunctionList idAP="20" idFunctionList="787" idImplHALFunction="68"/><FunctionList idAP="20" idFunctionList="788" idImplHALFunction="69"/><FunctionList idAP="20" idFunctionList="789" idImplHALFunction="75"/><FunctionList idAP="20" idFunctionList="790" idImplHALFunction="144"/><FunctionList idAP="19" idFunctionList="791" idImplHALFunction="145"/><FunctionList idAP="9" idFunctionList="792" idImplHALFunction="131"/><FunctionList idAP="10" idFunctionList="793" idImplHALFunction="131"/><FunctionList idAP="13" idFunctionList="794" idImplHALFunction="144"/><FunctionList idAP="14" idFunctionList="795" idImplHALFunction="144"/><FunctionList idAP="21" idFunctionList="796" idImplHALFunction="73"/><FunctionList idAP="21" idFunctionList="797" idImplHALFunction="74"/><FunctionList idAP="21" idFunctionList="798" idImplHALFunction="125"/><FunctionList idAP="21" idFunctionList="799" idImplHALFunction="126"/><FunctionList idAP="21" idFunctionList="800" idImplHALFunction="127"/><FunctionList idAP="21" idFunctionList="801" idImplHALFunction="128"/><FunctionList idAP="21" idFunctionList="802" idImplHALFunction="76"/><FunctionList idAP="21" idFunctionList="803" idImplHALFunction="77"/><FunctionList idAP="21" idFunctionList="804" idImplHALFunction="78"/><FunctionList idAP="21" idFunctionList="805" idImplHALFunction="79"/><FunctionList idAP="21" idFunctionList="806" idImplHALFunction="80"/><FunctionList idAP="21" idFunctionList="807" idImplHALFunction="81"/><FunctionList idAP="21" idFunctionList="808" idImplHALFunction="82"/><FunctionList idAP="21" idFunctionList="809" idImplHALFunction="83"/><FunctionList idAP="21" idFunctionList="810" idImplHALFunction="84"/><FunctionList idAP="21" idFunctionList="811" idImplHALFunction="85"/><FunctionList idAP="21" idFunctionList="812" idImplHALFunction="86"/><FunctionList idAP="21" idFunctionList="813" idImplHALFunction="87"/><FunctionList idAP="21" idFunctionList="814" idImplHALFunction="88"/><FunctionList idAP="21" idFunctionList="815" idImplHALFunction="104"/><FunctionList idAP="21" idFunctionList="816" idImplHALFunction="105"/><FunctionList idAP="21" idFunctionList="817" idImplHALFunction="106"/><FunctionList idAP="21" idFunctionList="818" idImplHALFunction="107"/><FunctionList idAP="21" idFunctionList="819" idImplHALFunction="108"/><FunctionList idAP="21" idFunctionList="820" idImplHALFunction="109"/><FunctionList idAP="21" idFunctionList="821" idImplHALFunction="110"/><FunctionList idAP="21" idFunctionList="822" idImplHALFunction="111"/><FunctionList idAP="21" idFunctionList="823" idImplHALFunction="112"/><FunctionList idAP="21" idFunctionList="824" idImplHALFunction="113"/><FunctionList idAP="21" idFunctionList="825" idImplHALFunction="114"/><FunctionList idAP="21" idFunctionList="826" idImplHALFunction="115"/><FunctionList idAP="21" idFunctionList="827" idImplHALFunction="116"/><FunctionList idAP="21" idFunctionList="828" idImplHALFunction="9"/><FunctionList idAP="21" idFunctionList="829" idImplHALFunction="70"/><FunctionList idAP="21" idFunctionList="830" idImplHALFunction="71"/><FunctionList idAP="21" idFunctionList="831" idImplHALFunction="72"/><FunctionList idAP="21" idFunctionList="832" idImplHALFunction="89"/><FunctionList idAP="21" idFunctionList="833" idImplHALFunction="98"/><FunctionList idAP="21" idFunctionList="834" idImplHALFunction="99"/><FunctionList idAP="21" idFunctionList="835" idImplHALFunction="100"/><FunctionList idAP="21" idFunctionList="836" idImplHALFunction="101"/><FunctionList idAP="21" idFunctionList="837" idImplHALFunction="102"/><FunctionList idAP="21" idFunctionList="838" idImplHALFunction="103"/><FunctionList idAP="21" idFunctionList="839" idImplHALFunction="131"/><FunctionList idAP="21" idFunctionList="840" idImplHALFunction="59"/><FunctionList idAP="21" idFunctionList="841" idImplHALFunction="64"/><FunctionList idAP="21" idFunctionList="842" idImplHALFunction="65"/><FunctionList idAP="21" idFunctionList="843" idImplHALFunction="66"/><FunctionList idAP="21" idFunctionList="844" idImplHALFunction="67"/><FunctionList idAP="21" idFunctionList="845" idImplHALFunction="68"/><FunctionList idAP="21" idFunctionList="846" idImplHALFunction="69"/><FunctionList idAP="21" idFunctionList="847" idImplHALFunction="75"/><FunctionList idAP="21" idFunctionList="848" idImplHALFunction="144"/><FunctionList idAP="21" idFunctionList="849" idImplHALFunction="129"/><FunctionList idAP="21" idFunctionList="850" idImplHALFunction="130"/></FunctionList_List><VariableList_List><VariableList idAP="9" idImplHALVariable="17" idVariableList="23"/><VariableList idAP="9" idImplHALVariable="18" idVariableList="24"/><VariableList idAP="9" idImplHALVariable="19" idVariableList="25"/><VariableList idAP="9" idImplHALVariable="20" idVariableList="26"/><VariableList idAP="9" idImplHALVariable="21" idVariableList="27"/><VariableList idAP="9" idImplHALVariable="22" idVariableList="28"/><VariableList idAP="10" idImplHALVariable="23" idVariableList="29"/><VariableList idAP="11" idImplHALVariable="22" idVariableList="30"/><VariableList idAP="11" idImplHALVariable="17" idVariableList="31"/><VariableList idAP="11" idImplHALVariable="24" idVariableList="32"/><VariableList idAP="11" idImplHALVariable="25" idVariableList="33"/><VariableList idAP="11" idImplHALVariable="26" idVariableList="34"/><VariableList idAP="11" idImplHALVariable="27" idVariableList="35"/><VariableList idAP="12" idImplHALVariable="22" idVariableList="37"/><VariableList idAP="12" idImplHALVariable="23" idVariableList="38"/><VariableList idAP="12" idImplHALVariable="28" idVariableList="39"/><VariableList idAP="12" idImplHALVariable="29" idVariableList="40"/><VariableList idAP="12" idImplHALVariable="30" idVariableList="41"/><VariableList idAP="12" idImplHALVariable="31" idVariableList="42"/><VariableList idAP="12" idImplHALVariable="32" idVariableList="43"/><VariableList idAP="9" idImplHALVariable="23" idVariableList="44"/><VariableList idAP="9" idImplHALVariable="28" idVariableList="45"/><VariableList idAP="9" idImplHALVariable="29" idVariableList="46"/><VariableList idAP="9" idImplHALVariable="30" idVariableList="47"/><VariableList idAP="9" idImplHALVariable="31" idVariableList="48"/><VariableList idAP="9" idImplHALVariable="32" idVariableList="49"/><VariableList idAP="12" idImplHALVariable="17" idVariableList="50"/><VariableList idAP="12" idImplHALVariable="18" idVariableList="51"/><VariableList idAP="12" idImplHALVariable="19" idVariableList="52"/><VariableList idAP="12" idImplHALVariable="20" idVariableList="53"/><VariableList idAP="12" idImplHALVariable="21" idVariableList="54"/><VariableList idAP="10" idImplHALVariable="28" idVariableList="55"/><VariableList idAP="13" idImplHALVariable="22" idVariableList="57"/><VariableList idAP="13" idImplHALVariable="23" idVariableList="58"/><VariableList idAP="13" idImplHALVariable="28" idVariableList="59"/><VariableList idAP="13" idImplHALVariable="18" idVariableList="60"/><VariableList idAP="13" idImplHALVariable="19" idVariableList="61"/><VariableList idAP="13" idImplHALVariable="20" idVariableList="62"/><VariableList idAP="13" idImplHALVariable="21" idVariableList="63"/><VariableList idAP="13" idImplHALVariable="17" idVariableList="64"/><VariableList idAP="11" idImplHALVariable="23" idVariableList="66"/><VariableList idAP="11" idImplHALVariable="28" idVariableList="67"/><VariableList idAP="12" idImplHALVariable="33" idVariableList="68"/><VariableList idAP="6" idImplHALVariable="22" idVariableList="69"/><VariableList idAP="6" idImplHALVariable="23" idVariableList="70"/><VariableList idAP="6" idImplHALVariable="28" idVariableList="71"/><VariableList idAP="6" idImplHALVariable="29" idVariableList="72"/><VariableList idAP="6" idImplHALVariable="30" idVariableList="73"/><VariableList idAP="6" idImplHALVariable="31" idVariableList="74"/><VariableList idAP="6" idImplHALVariable="32" idVariableList="75"/><VariableList idAP="6" idImplHALVariable="33" idVariableList="76"/><VariableList idAP="14" idImplHALVariable="22" idVariableList="77"/><VariableList idAP="14" idImplHALVariable="23" idVariableList="78"/><VariableList idAP="14" idImplHALVariable="17" idVariableList="79"/><VariableList idAP="14" idImplHALVariable="28" idVariableList="80"/><VariableList idAP="14" idImplHALVariable="29" idVariableList="81"/><VariableList idAP="14" idImplHALVariable="30" idVariableList="82"/><VariableList idAP="14" idImplHALVariable="31" idVariableList="83"/><VariableList idAP="14" idImplHALVariable="32" idVariableList="84"/><VariableList idAP="14" idImplHALVariable="33" idVariableList="85"/><VariableList idAP="14" idImplHALVariable="18" idVariableList="86"/><VariableList idAP="14" idImplHALVariable="19" idVariableList="87"/><VariableList idAP="14" idImplHALVariable="20" idVariableList="88"/><VariableList idAP="14" idImplHALVariable="21" idVariableList="89"/><VariableList idAP="9" idImplHALVariable="33" idVariableList="90"/><VariableList idAP="15" idImplHALVariable="23" idVariableList="91"/><VariableList idAP="15" idImplHALVariable="28" idVariableList="92"/><VariableList idAP="16" idImplHALVariable="22" idVariableList="93"/><VariableList idAP="16" idImplHALVariable="23" idVariableList="94"/><VariableList idAP="16" idImplHALVariable="29" idVariableList="95"/><VariableList idAP="16" idImplHALVariable="30" idVariableList="96"/><VariableList idAP="16" idImplHALVariable="31" idVariableList="97"/><VariableList idAP="16" idImplHALVariable="32" idVariableList="98"/><VariableList idAP="16" idImplHALVariable="28" idVariableList="99"/><VariableList idAP="17" idImplHALVariable="22" idVariableList="100"/><VariableList idAP="17" idImplHALVariable="23" idVariableList="101"/><VariableList idAP="17" idImplHALVariable="17" idVariableList="102"/><VariableList idAP="17" idImplHALVariable="28" idVariableList="103"/><VariableList idAP="17" idImplHALVariable="29" idVariableList="104"/><VariableList idAP="17" idImplHALVariable="30" idVariableList="105"/><VariableList idAP="17" idImplHALVariable="31" idVariableList="106"/><VariableList idAP="17" idImplHALVariable="32" idVariableList="107"/><VariableList idAP="17" idImplHALVariable="35" idVariableList="108"/><VariableList idAP="17" idImplHALVariable="36" idVariableList="109"/><VariableList idAP="17" idImplHALVariable="37" idVariableList="110"/><VariableList idAP="17" idImplHALVariable="38" idVariableList="111"/><VariableList idAP="17" idImplHALVariable="33" idVariableList="112"/><VariableList idAP="18" idImplHALVariable="17" idVariableList="113"/><VariableList idAP="18" idImplHALVariable="22" idVariableList="114"/><VariableList idAP="18" idImplHALVariable="23" idVariableList="115"/><VariableList idAP="19" idImplHALVariable="17" idVariableList="116"/><VariableList idAP="19" idImplHALVariable="22" idVariableList="117"/><VariableList idAP="19" idImplHALVariable="23" idVariableList="118"/><VariableList idAP="19" idImplHALVariable="28" idVariableList="119"/><VariableList idAP="19" idImplHALVariable="29" idVariableList="120"/><VariableList idAP="19" idImplHALVariable="30" idVariableList="121"/><VariableList idAP="19" idImplHALVariable="31" idVariableList="122"/><VariableList idAP="19" idImplHALVariable="32" idVariableList="123"/><VariableList idAP="19" idImplHALVariable="33" idVariableList="124"/><VariableList idAP="19" idImplHALVariable="35" idVariableList="125"/><VariableList idAP="19" idImplHALVariable="36" idVariableList="126"/><VariableList idAP="19" idImplHALVariable="37" idVariableList="127"/><VariableList idAP="19" idImplHALVariable="38" idVariableList="128"/><VariableList idAP="20" idImplHALVariable="22" idVariableList="129"/><VariableList idAP="20" idImplHALVariable="23" idVariableList="130"/><VariableList idAP="20" idImplHALVariable="17" idVariableList="131"/><VariableList idAP="20" idImplHALVariable="28" idVariableList="132"/><VariableList idAP="20" idImplHALVariable="29" idVariableList="133"/><VariableList idAP="20" idImplHALVariable="30" idVariableList="134"/><VariableList idAP="20" idImplHALVariable="31" idVariableList="135"/><VariableList idAP="20" idImplHALVariable="32" idVariableList="136"/><VariableList idAP="20" idImplHALVariable="33" idVariableList="137"/><VariableList idAP="20" idImplHALVariable="18" idVariableList="138"/><VariableList idAP="20" idImplHALVariable="19" idVariableList="139"/><VariableList idAP="20" idImplHALVariable="20" idVariableList="140"/><VariableList idAP="20" idImplHALVariable="21" idVariableList="141"/><VariableList idAP="10" idImplHALVariable="22" idVariableList="142"/><VariableList idAP="21" idImplHALVariable="22" idVariableList="143"/><VariableList idAP="21" idImplHALVariable="23" idVariableList="144"/><VariableList idAP="21" idImplHALVariable="17" idVariableList="145"/><VariableList idAP="21" idImplHALVariable="28" idVariableList="146"/><VariableList idAP="21" idImplHALVariable="18" idVariableList="147"/><VariableList idAP="21" idImplHALVariable="19" idVariableList="148"/><VariableList idAP="21" idImplHALVariable="20" idVariableList="149"/><VariableList idAP="21" idImplHALVariable="21" idVariableList="150"/></VariableList_List><DriverList_List><DriverList idAP="9" idDriverList="1" idImplMsgDriver="1"/><DriverList idAP="10" idDriverList="2" idImplMsgDriver="2"/><DriverList idAP="11" idDriverList="3" idImplMsgDriver="3"/><DriverList idAP="13" idDriverList="4" idImplMsgDriver="1"/><DriverList idAP="6" idDriverList="5" idImplMsgDriver="2"/><DriverList idAP="14" idDriverList="6" idImplMsgDriver="1"/><DriverList idAP="7" idDriverList="9" idImplMsgDriver="5"/><DriverList idAP="20" idDriverList="10" idImplMsgDriver="6"/><DriverList idAP="19" idDriverList="11" idImplMsgDriver="6"/><DriverList idAP="21" idDriverList="12" idImplMsgDriver="1"/></DriverList_List><APList_List><APList idAP="5" idAPList="5" idImplAP="6"/><APList idAP="6" idAPList="6" idImplAP="7"/><APList idAP="7" idAPList="7" idImplAP="8"/><APList idAP="9" idAPList="9" idImplAP="10"/><APList idAP="10" idAPList="10" idImplAP="7"/><APList idAP="11" idAPList="11" idImplAP="11"/><APList idAP="12" idAPList="12" idImplAP="10"/><APList idAP="13" idAPList="13" idImplAP="10"/><APList idAP="14" idAPList="14" idImplAP="10"/><APList idAP="15" idAPList="15" idImplAP="12"/><APList idAP="16" idAPList="16" idImplAP="13"/><APList idAP="17" idAPList="17" idImplAP="14"/><APList idAP="18" idAPList="18" idImplAP="12"/><APList idAP="19" idAPList="19" idImplAP="15"/><APList idAP="20" idAPList="20" idImplAP="10"/><APList idAP="21" idAPList="21" idImplAP="10"/></APList_List><ALASMprogramm_List><ALASMprogramm code="" idALASMprogramm="1"/><ALASMprogramm code="" idALASMprogramm="2"/><ALASMprogramm code="" idALASMprogramm="3"/></ALASMprogramm_List><pythonScript_List><pythonScript code="# the python implementation  import scipy import numpy  from scipy.io import wavfile from scipy.signal import lfilter  import floatwavefile import stjMatPython  def calcLP (fg, fs):     # n - numerator     # d - denumerator     k=numpy.tan(numpy.pi*fg/fs)     k2 = k * k     sqrtTwo = numpy.sqrt(2)     dn = (1+sqrtTwo*k+k2)          n0=k2/dn     n1=2*k2/dn     n2=k2/dn     d0=1     d1=(2*(k2-1))/dn     d2=(1-sqrtTwo*k+k2)/dn     return [[n0,n1,n2],[d0,d1,d2]]  def calcHP (fg, fs):     # n - numerator     # d - denumerator     k=numpy.tan(numpy.pi*fg/fs)     k2 = k * k     sqrtTwo = numpy.sqrt(2)     dn = (1+sqrtTwo*k+k2)          n0=1/dn     n1=-2/dn     n2=1/dn     d0=1     d1=(2*(k2-1))/dn     d2=(1-sqrtTwo*k+k2)/dn     return [[n0,n1,n2],[d0,d1,d2]]  def normFilterCoeff (n,d):     rn = numpy.divide(n,d[0])     rd = numpy.divide(d,d[0])     return rn, rd  def initCrossOver (fLp, fHp, fs): # scipy has an own bilinear transformation method to go from a sjw to z space #from scipy.signal import bilinear #LP = bilinear(b, a, fs)     # calc filter coefficents ...     n, d = calcLP(fLp, fs)     n, d = normFilterCoeff(n,d)     LP = {'n' : n, 'd' : d}     n, d = calcHP(fHp, fs)     n, d = normFilterCoeff(n,d)     HP = {'n' : n, 'd' : d}     return LP, HP  def convoluteSignalWithFilter (n, d, xA):     s1 = float(0.)     s2 = float(0.)     l = len(xA)     yA = numpy.zeros(l)     i = 0     for x in xA:         d1 = -d[2]*s2-d[1]*s1+d[0]*x         y = n[2]*s2+n[1]*s1+n[0]*d1         s2 = s1         s1 = d1         yA[i] = y         i += 1     return yA  def measureCrossOver (CO, Xsig):     LP = CO[0]     HP = CO[1]     yLP = lfilter (LP['n'],LP['d'],Xsig)     yHP = lfilter (HP['n'],HP['d'],Xsig)     #yLP = convoluteSignalWithFilter(LP['n'],LP['d'],Xsig)     #yHP = convoluteSignalWithFilter(HP['n'],HP['d'],Xsig)          return yLP,yHP   if __name__ == '__main__':     # set the sample frequency     N = int(2**16)     fs = float(44100)          xScalor = fs / N          # read data from the wave file         [rate, x] = floatwavefile.readFloatWAV('noise.wav')          #display read data      # convolute data with the crossover filter     CO = initCrossOver(1000,2000,fs)     yLP, yHP = measureCrossOver(CO,x)      wv = numpy.array(yLP,dtype=numpy.float32)          floatwavefile.writeFloatWAV('pythonLP.wav', fs, wv)      wv = numpy.array(yHP,dtype=numpy.float32)          floatwavefile.writeFloatWAV('pythonHP.wav', fs, wv)" idpythonScript="1"/><pythonScript code="# the python initiation script import scipy import numpy  from scipy.io import wavfile from scipy.signal import lfilter  import floatwavefile  # set the sample frequency N = int(2**16) fs = float(44100)      xScalor = fs / N      # create the amplitude and phase array # all fequencies have an amplitude of 1      # we have to keep in mind that we want to produce an real signal # this means that the fft specturm is mirrored at N/2      # generate random phase angle witch is uniform distributed phi = numpy.random.uniform(low=-1*numpy.pi, high=numpy.pi, size=N/2) Y = numpy.ones(N/2, dtype=complex)      # merge phase and amplitude # z = A * e^(jw) i = 0 for p in phi:     Y[i] = numpy.exp(1.j *p)     i += 1 # set the DC value to 0 Y[0] = 0 + 0.j  # ifft to gain a real signal x = numpy.fft.irfft(Y)  # dump wave file wv = numpy.array(x,dtype=numpy.float32)      floatwavefile.writeFloatWAV('noise.wav', fs, wv)" idpythonScript="2"/><pythonScript code="# the python close script import scipy import numpy  import floatwavefile import stjMatPython  import matplotlib.pyplot as plt  print ('analyse results')  N = int(2**16) fs = float(44100)  xScalor = fs / N  [rate, x] = floatwavefile.readFloatWAV('noise.wav')  [rate, yPLP] = floatwavefile.readFloatWAV('pythonLP.wav') [rate, yPHP] = floatwavefile.readFloatWAV('pythonHP.wav') [rate, yMLP] = floatwavefile.readFloatWAV('matlabLP.wav') [rate, yMHP] = floatwavefile.readFloatWAV('matlabHP.wav') [rate, yAPLP] = floatwavefile.readFloatWAV('apLP.wav') [rate, yAPHP] = floatwavefile.readFloatWAV('apHP.wav')    stjMatPython.poltBode (211,212,numpy.fft.rfft(yAPLP),N,xScalor,'red',1,0.4,'audio processor') stjMatPython.poltBode (211,212,numpy.fft.rfft(yAPHP),N,xScalor,'red',1,0.4,None) stjMatPython.poltBode (211,212,numpy.fft.rfft(yPLP),N,xScalor,'green',1,0.5,'python') stjMatPython.poltBode (211,212,numpy.fft.rfft(yPHP),N,xScalor,'green',1,0.5,None) stjMatPython.poltBode (211,212,numpy.fft.rfft(yMLP),N,xScalor,'blue',1,0.3,'matlab') stjMatPython.poltBode (211,212,numpy.fft.rfft(yMHP),N,xScalor,'blue',1,0.3,None)   lpDif = yPLP - yMLP hpDif = yPHP - yMHP  plt.show()" idpythonScript="3"/><pythonScript code="# the python implementation" idpythonScript="4"/><pythonScript code="# the python initiation script" idpythonScript="5"/><pythonScript code="# the python close script" idpythonScript="6"/><pythonScript code="# the python implementation" idpythonScript="7"/><pythonScript code="# the python initiation script" idpythonScript="8"/><pythonScript code="# the python close script" idpythonScript="9"/></pythonScript_List><MatlabProgramm_List><MatlabProgramm code="% the matlab program clear clc % const N = 2^16; fs = 44100.0; fHP = 2000; fLP = 1000;  % calc filter HP = calcHP(fs, fHP); LP = calcLP (fs, fLP);  %normize filter HP = normFilterCoeff(HP); LP = normFilterCoeff(LP);  %load noise signal x = wavread('noise.wav');  % convolute filter with the signal yHP = filter(HP(1,:),HP(2,:),x); yLP = filter(LP(1,:),LP(2,:),x);   % save results to file wavwrite (yLP,fs,32,'matlabLP.wav'); wavwrite (yHP,fs,32,'matlabHP.wav');" idMatlabProgramm="1"/><MatlabProgramm code="% the matlab program" idMatlabProgramm="2"/><MatlabProgramm code="% the matlab program" idMatlabProgramm="3"/></MatlabProgramm_List><testPattern_List><testPattern descr="test crossover filter" idALASMprogramm="1" idAP="1" idMatlabProgramm="1" idPythonExitScript="3" idPythonInitScript="2" idpythonProgramm="1" idtestPattern="1" name="cof"/><testPattern descr="embeeded world conference crossover test" idALASMprogramm="2" idAP="1" idMatlabProgramm="2" idPythonExitScript="6" idPythonInitScript="5" idpythonProgramm="4" idtestPattern="2" name="ebw"/><testPattern descr="DAFx 2012 testpattern" idALASMprogramm="3" idAP="6" idMatlabProgramm="3" idPythonExitScript="9" idPythonInitScript="8" idpythonProgramm="7" idtestPattern="3" name="DAFXx 2012"/></testPattern_List></APDB>