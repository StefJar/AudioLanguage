<?xml version="1.0" ?><APDB><HAL_basicIOTypes_List><HAL_basicIOTypes TypeID="1" TypeName="rational" cType="float" description="a type for rational numbers" endianType="False" idHAL_IOTypesDefinition="1" sizeInBytes="4"/><HAL_basicIOTypes TypeID="2" TypeName="integer" cType="int32_t" description="a type for natural and integer numbers" endianType="True" idHAL_IOTypesDefinition="2" sizeInBytes="4"/><HAL_basicIOTypes TypeID="3" TypeName="char" cType="char" description="a type for character" endianType="False" idHAL_IOTypesDefinition="3" sizeInBytes="1"/><HAL_basicIOTypes TypeID="4" TypeName="raw" cType="uint32_t" description="4 Byte Raw Data" endianType="False" idHAL_IOTypesDefinition="4" sizeInBytes="4"/></HAL_basicIOTypes_List><HAL_VariableIOParameter_List><HAL_VariableIOParameter VariableID="1" basicTypeID="1" description="the value of the number" idHAL_VariableIOParameter="1" initFunction="True" isArray="False" name="value" updateFunction="True"/><HAL_VariableIOParameter VariableID="2" basicTypeID="2" description="the value of the number" idHAL_VariableIOParameter="2" initFunction="True" isArray="False" name="value" updateFunction="True"/><HAL_VariableIOParameter VariableID="3" basicTypeID="2" description="the length of the string" idHAL_VariableIOParameter="3" initFunction="True" isArray="False" name="length" updateFunction="True"/><HAL_VariableIOParameter VariableID="3" basicTypeID="3" description="the text of the string" idHAL_VariableIOParameter="4" initFunction="True" isArray="True" name="text" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="5" initFunction="True" isArray="False" name="a0" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="6" initFunction="True" isArray="False" name="a1" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="enumerator coefficient" idHAL_VariableIOParameter="7" initFunction="True" isArray="False" name="a2" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="numerator coefficient" idHAL_VariableIOParameter="8" initFunction="True" isArray="False" name="b0" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="numerator coefficient" idHAL_VariableIOParameter="9" initFunction="True" isArray="False" name="b1" updateFunction="True"/><HAL_VariableIOParameter VariableID="10" basicTypeID="1" description="numerator coefficient" idHAL_VariableIOParameter="10" initFunction="True" isArray="False" name="b2" updateFunction="True"/><HAL_VariableIOParameter VariableID="30" basicTypeID="2" description="number of samples" idHAL_VariableIOParameter="11" initFunction="True" isArray="False" name="N" updateFunction="True"/><HAL_VariableIOParameter VariableID="4" basicTypeID="1" description="real part" idHAL_VariableIOParameter="12" initFunction="True" isArray="False" name="r" updateFunction="True"/><HAL_VariableIOParameter VariableID="4" basicTypeID="2" description="imaginary part" idHAL_VariableIOParameter="13" initFunction="True" isArray="False" name="i" updateFunction="True"/></HAL_VariableIOParameter_List><HAL_FunctionsParameter_List><HAL_FunctionsParameter descr="left side number" fid="40" idHAL_FunctionsParameter="41" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="50" idHAL_FunctionsParameter="53" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="51" idHAL_FunctionsParameter="54" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="amount of instructions to jump" fid="52" idHAL_FunctionsParameter="55" idParameterClass="1" idParameterType="2" name="number"/><HAL_FunctionsParameter descr="the channel" fid="60" idHAL_FunctionsParameter="56" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the result of the action" fid="60" idHAL_FunctionsParameter="57" idParameterClass="3" idParameterType="1" name="resValue"/><HAL_FunctionsParameter descr="the channel" fid="61" idHAL_FunctionsParameter="58" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the value to be written to the output" fid="61" idHAL_FunctionsParameter="59" idParameterClass="3" idParameterType="1" name="value"/><HAL_FunctionsParameter descr="a value" fid="3" idHAL_FunctionsParameter="60" idParameterClass="1" idParameterType="2" name="value"/><HAL_FunctionsParameter descr="input" fid="110" idHAL_FunctionsParameter="77" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="150" idHAL_FunctionsParameter="79" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="the delay" fid="150" idHAL_FunctionsParameter="80" idParameterClass="2" idParameterType="20" name="delay"/><HAL_FunctionsParameter descr="output" fid="150" idHAL_FunctionsParameter="81" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="biquad cascade" fid="110" idHAL_FunctionsParameter="83" idParameterClass="3" idParameterType="10" name="bqa"/><HAL_FunctionsParameter descr="output" fid="110" idHAL_FunctionsParameter="84" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="window length" fid="120" idHAL_FunctionsParameter="85" idParameterClass="1" idParameterType="2" name="wl"/><HAL_FunctionsParameter descr="set to 1 if used for periodic consructs like DFT/FFT" fid="120" idHAL_FunctionsParameter="86" idParameterClass="1" idParameterType="2" name="flag"/><HAL_FunctionsParameter descr="window coefficients (array of rational values)" fid="120" idHAL_FunctionsParameter="87" idParameterClass="2" idParameterType="1" name="wnd"/><HAL_FunctionsParameter descr="FFT length" fid="130" idHAL_FunctionsParameter="88" idParameterClass="1" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="IFFT length" fid="131" idHAL_FunctionsParameter="89" idParameterClass="1" idParameterType="2" name="N"/><HAL_FunctionsParameter descr="the channel" fid="62" idHAL_FunctionsParameter="92" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the buffer witch receives the samples" fid="62" idHAL_FunctionsParameter="93" idParameterClass="3" idParameterType="1" name="frameBuffer"/><HAL_FunctionsParameter descr="the channel" fid="63" idHAL_FunctionsParameter="94" idParameterClass="1" idParameterType="2" name="channel"/><HAL_FunctionsParameter descr="the buffer which is writen to the channel" fid="63" idHAL_FunctionsParameter="95" idParameterClass="3" idParameterType="1" name="frameBuffer"/><HAL_FunctionsParameter descr="input" fid="130" idHAL_FunctionsParameter="100" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="output" fid="130" idHAL_FunctionsParameter="101" idParameterClass="3" idParameterType="4" name="y"/><HAL_FunctionsParameter descr="input" fid="131" idHAL_FunctionsParameter="102" idParameterClass="3" idParameterType="4" name="x"/><HAL_FunctionsParameter descr="output" fid="131" idHAL_FunctionsParameter="103" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="IFFT structure" fid="131" idHAL_FunctionsParameter="104" idParameterClass="2" idParameterType="30" name="ifftStruct"/><HAL_FunctionsParameter descr="FFT structure" fid="130" idHAL_FunctionsParameter="105" idParameterClass="2" idParameterType="30" name="fftStruct"/><HAL_FunctionsParameter descr="the ifft info structure" fid="133" idHAL_FunctionsParameter="107" idParameterClass="2" idParameterType="30" name="ifftStruct"/><HAL_FunctionsParameter descr="the fft structure" fid="132" idHAL_FunctionsParameter="108" idParameterClass="2" idParameterType="30" name="fftStruct"/><HAL_FunctionsParameter descr="uuid of the pannel" fid="201" idHAL_FunctionsParameter="123" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="panel" fid="201" idHAL_FunctionsParameter="124" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="uuid of the button" fid="202" idHAL_FunctionsParameter="125" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="button" fid="202" idHAL_FunctionsParameter="126" idParameterClass="3" idParameterType="101" name="b"/><HAL_FunctionsParameter descr="uuid of the display" fid="203" idHAL_FunctionsParameter="127" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="display" fid="203" idHAL_FunctionsParameter="128" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="uuid of the LED" fid="204" idHAL_FunctionsParameter="129" idParameterClass="1" idParameterType="2" name="uiUUID"/><HAL_FunctionsParameter descr="LED" fid="204" idHAL_FunctionsParameter="130" idParameterClass="3" idParameterType="102" name="l"/><HAL_FunctionsParameter descr="the string" fid="5" idHAL_FunctionsParameter="131" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="5" idHAL_FunctionsParameter="132" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="length of the string" fid="5" idHAL_FunctionsParameter="133" idParameterClass="1" idParameterType="2" name="length"/><HAL_FunctionsParameter descr="the string" fid="6" idHAL_FunctionsParameter="134" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="6" idHAL_FunctionsParameter="135" idParameterClass="1" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="position at the string where to start from" fid="6" idHAL_FunctionsParameter="136" idParameterClass="1" idParameterType="2" name="p"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="137" idParameterClass="1" idParameterType="4" name="v1"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="138" idParameterClass="1" idParameterType="4" name="v2"/><HAL_FunctionsParameter descr="panel index" fid="201" idHAL_FunctionsParameter="139" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="button index" fid="202" idHAL_FunctionsParameter="140" idParameterClass="1" idParameterType="2" name="bIndex"/><HAL_FunctionsParameter descr="panel" fid="202" idHAL_FunctionsParameter="141" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="202" idHAL_FunctionsParameter="142" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="display index" fid="203" idHAL_FunctionsParameter="143" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="panel" fid="203" idHAL_FunctionsParameter="144" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="203" idHAL_FunctionsParameter="145" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="LED index" fid="204" idHAL_FunctionsParameter="146" idParameterClass="1" idParameterType="2" name="lIndex"/><HAL_FunctionsParameter descr="panel" fid="204" idHAL_FunctionsParameter="147" idParameterClass="3" idParameterType="100" name="p"/><HAL_FunctionsParameter descr="panel index" fid="204" idHAL_FunctionsParameter="148" idParameterClass="1" idParameterType="2" name="pIndex"/><HAL_FunctionsParameter descr="x position" fid="200" idHAL_FunctionsParameter="149" idParameterClass="1" idParameterType="2" name="x"/><HAL_FunctionsParameter descr="y position" fid="200" idHAL_FunctionsParameter="150" idParameterClass="1" idParameterType="2" name="y"/><HAL_FunctionsParameter descr="x length" fid="200" idHAL_FunctionsParameter="151" idParameterClass="1" idParameterType="2" name="xle"/><HAL_FunctionsParameter descr="y length" fid="200" idHAL_FunctionsParameter="152" idParameterClass="1" idParameterType="2" name="yle"/><HAL_FunctionsParameter descr="ui" fid="200" idHAL_FunctionsParameter="153" idParameterClass="3" idParameterType="0" name="ui"/><HAL_FunctionsParameter descr="ui index" fid="200" idHAL_FunctionsParameter="154" idParameterClass="1" idParameterType="2" name="uiIndex"/><HAL_FunctionsParameter descr="button" fid="210" idHAL_FunctionsParameter="155" idParameterClass="3" idParameterType="101" name="b"/><HAL_FunctionsParameter descr="button index" fid="210" idHAL_FunctionsParameter="156" idParameterClass="1" idParameterType="2" name="bIndex"/><HAL_FunctionsParameter descr="LED" fid="211" idHAL_FunctionsParameter="157" idParameterClass="3" idParameterType="102" name="l"/><HAL_FunctionsParameter descr="LED index" fid="211" idHAL_FunctionsParameter="158" idParameterClass="1" idParameterType="2" name="lIndex"/><HAL_FunctionsParameter descr="if the flag is not zero the LED is turned on" fid="211" idHAL_FunctionsParameter="159" idParameterClass="1" idParameterType="2" name="onFlag"/><HAL_FunctionsParameter descr="the value of the CF" fid="55" idHAL_FunctionsParameter="160" idParameterClass="1" idParameterType="2" name="value"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="161" idParameterClass="1" idParameterType="4" name="v3"/><HAL_FunctionsParameter descr="display" fid="212" idHAL_FunctionsParameter="162" idParameterClass="3" idParameterType="103" name="d"/><HAL_FunctionsParameter descr="display index" fid="212" idHAL_FunctionsParameter="163" idParameterClass="1" idParameterType="2" name="dIndex"/><HAL_FunctionsParameter descr="the string" fid="212" idHAL_FunctionsParameter="164" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="212" idHAL_FunctionsParameter="165" idParameterClass="1" idParameterType="2" name="iString"/><HAL_FunctionsParameter descr="integer vector" fid="20" idHAL_FunctionsParameter="166" idParameterClass="3" idParameterType="2" name="iv"/><HAL_FunctionsParameter descr="start index" fid="20" idHAL_FunctionsParameter="167" idParameterClass="1" idParameterType="2" name="iStart"/><HAL_FunctionsParameter descr="amount of values used" fid="20" idHAL_FunctionsParameter="168" idParameterClass="1" idParameterType="2" name="num"/><HAL_FunctionsParameter descr="value 1" fid="20" idHAL_FunctionsParameter="169" idParameterClass="1" idParameterType="2" name="v1"/><HAL_FunctionsParameter descr="value 2" fid="20" idHAL_FunctionsParameter="170" idParameterClass="1" idParameterType="2" name="v2"/><HAL_FunctionsParameter descr="value 3" fid="20" idHAL_FunctionsParameter="171" idParameterClass="1" idParameterType="2" name="v3"/><HAL_FunctionsParameter descr="vector a" fid="21" idHAL_FunctionsParameter="172" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="21" idHAL_FunctionsParameter="173" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector a" fid="22" idHAL_FunctionsParameter="175" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="22" idHAL_FunctionsParameter="176" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="22" idHAL_FunctionsParameter="177" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="23" idHAL_FunctionsParameter="178" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector a" fid="24" idHAL_FunctionsParameter="179" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="23" idHAL_FunctionsParameter="180" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector b" fid="24" idHAL_FunctionsParameter="181" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="23" idHAL_FunctionsParameter="182" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector c" fid="24" idHAL_FunctionsParameter="183" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="25" idHAL_FunctionsParameter="184" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="25" idHAL_FunctionsParameter="185" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="25" idHAL_FunctionsParameter="186" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="vector a" fid="26" idHAL_FunctionsParameter="187" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="vector b" fid="26" idHAL_FunctionsParameter="188" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="vector c" fid="26" idHAL_FunctionsParameter="189" idParameterClass="3" idParameterType="2" name="c"/><HAL_FunctionsParameter descr="index at a vector" fid="40" idHAL_FunctionsParameter="190" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="40" idHAL_FunctionsParameter="191" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="40" idHAL_FunctionsParameter="192" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="left side number" fid="41" idHAL_FunctionsParameter="193" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="42" idHAL_FunctionsParameter="194" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="43" idHAL_FunctionsParameter="195" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="44" idHAL_FunctionsParameter="196" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="left side number" fid="45" idHAL_FunctionsParameter="197" idParameterClass="3" idParameterType="2" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="41" idHAL_FunctionsParameter="198" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="42" idHAL_FunctionsParameter="199" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="43" idHAL_FunctionsParameter="200" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="44" idHAL_FunctionsParameter="201" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="45" idHAL_FunctionsParameter="202" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="41" idHAL_FunctionsParameter="203" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="42" idHAL_FunctionsParameter="204" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="43" idHAL_FunctionsParameter="205" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="44" idHAL_FunctionsParameter="206" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="right side number" fid="45" idHAL_FunctionsParameter="207" idParameterClass="3" idParameterType="2" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="41" idHAL_FunctionsParameter="208" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="42" idHAL_FunctionsParameter="209" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="43" idHAL_FunctionsParameter="210" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="44" idHAL_FunctionsParameter="211" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="45" idHAL_FunctionsParameter="212" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="the variable (internally the index of the variable)" fid="56" idHAL_FunctionsParameter="214" idParameterClass="5" idParameterType="0" name="var"/><HAL_FunctionsParameter descr="biquad cascade" fid="100" idHAL_FunctionsParameter="226" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="index at the cascade" fid="100" idHAL_FunctionsParameter="227" idParameterClass="1" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="sample frequnecy" fid="100" idHAL_FunctionsParameter="228" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="cut off frequency" fid="100" idHAL_FunctionsParameter="229" idParameterClass="3" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="biquad cascade" fid="101" idHAL_FunctionsParameter="230" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="biquad cascade" fid="102" idHAL_FunctionsParameter="231" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="biquad cascade" fid="103" idHAL_FunctionsParameter="232" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="biquad cascade" fid="104" idHAL_FunctionsParameter="233" idParameterClass="2" idParameterType="10" name="bq"/><HAL_FunctionsParameter descr="index at the cascade" fid="101" idHAL_FunctionsParameter="234" idParameterClass="1" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="index at the cascade" fid="102" idHAL_FunctionsParameter="235" idParameterClass="1" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="index at the cascade" fid="103" idHAL_FunctionsParameter="236" idParameterClass="1" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="index at the cascade" fid="104" idHAL_FunctionsParameter="237" idParameterClass="1" idParameterType="2" name="index"/><HAL_FunctionsParameter descr="sample frequnecy" fid="101" idHAL_FunctionsParameter="238" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="sample frequnecy" fid="102" idHAL_FunctionsParameter="239" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="sample frequnecy" fid="103" idHAL_FunctionsParameter="240" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="sample frequnecy" fid="104" idHAL_FunctionsParameter="241" idParameterClass="3" idParameterType="1" name="fs"/><HAL_FunctionsParameter descr="cut off frequency" fid="101" idHAL_FunctionsParameter="242" idParameterClass="3" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="center frequency" fid="102" idHAL_FunctionsParameter="243" idParameterClass="3" idParameterType="1" name="fc"/><HAL_FunctionsParameter descr="cut/boost frequency" fid="103" idHAL_FunctionsParameter="244" idParameterClass="3" idParameterType="1" name="f"/><HAL_FunctionsParameter descr="cut/boost frequency" fid="104" idHAL_FunctionsParameter="245" idParameterClass="3" idParameterType="1" name="f"/><HAL_FunctionsParameter descr="quality" fid="102" idHAL_FunctionsParameter="246" idParameterClass="3" idParameterType="1" name="q"/><HAL_FunctionsParameter descr="quality" fid="103" idHAL_FunctionsParameter="247" idParameterClass="3" idParameterType="1" name="q"/><HAL_FunctionsParameter descr="quality" fid="104" idHAL_FunctionsParameter="248" idParameterClass="3" idParameterType="1" name="q"/><HAL_FunctionsParameter descr="gain (not in dB)" fid="102" idHAL_FunctionsParameter="249" idParameterClass="3" idParameterType="1" name="g"/><HAL_FunctionsParameter descr="gain (not in dB)" fid="103" idHAL_FunctionsParameter="250" idParameterClass="3" idParameterType="1" name="g"/><HAL_FunctionsParameter descr="gain (not in dB)" fid="104" idHAL_FunctionsParameter="251" idParameterClass="3" idParameterType="1" name="g"/><HAL_FunctionsParameter descr="left side number" fid="34" idHAL_FunctionsParameter="252" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="34" idHAL_FunctionsParameter="253" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="34" idHAL_FunctionsParameter="254" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="34" idHAL_FunctionsParameter="255" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="left side number" fid="35" idHAL_FunctionsParameter="256" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="36" idHAL_FunctionsParameter="257" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="37" idHAL_FunctionsParameter="258" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="38" idHAL_FunctionsParameter="259" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="left side number" fid="39" idHAL_FunctionsParameter="260" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="index at a vector" fid="35" idHAL_FunctionsParameter="261" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="36" idHAL_FunctionsParameter="262" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="37" idHAL_FunctionsParameter="263" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="38" idHAL_FunctionsParameter="264" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="index at a vector" fid="39" idHAL_FunctionsParameter="265" idParameterClass="1" idParameterType="2" name="ia"/><HAL_FunctionsParameter descr="right side number" fid="35" idHAL_FunctionsParameter="266" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="36" idHAL_FunctionsParameter="267" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="37" idHAL_FunctionsParameter="268" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="38" idHAL_FunctionsParameter="269" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="right side number" fid="39" idHAL_FunctionsParameter="270" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="index at b vector" fid="35" idHAL_FunctionsParameter="271" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="36" idHAL_FunctionsParameter="272" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="37" idHAL_FunctionsParameter="273" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="38" idHAL_FunctionsParameter="274" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="index at b vector" fid="39" idHAL_FunctionsParameter="275" idParameterClass="1" idParameterType="2" name="ib"/><HAL_FunctionsParameter descr="rational vector" fid="27" idHAL_FunctionsParameter="276" idParameterClass="3" idParameterType="1" name="iv"/><HAL_FunctionsParameter descr="start index" fid="27" idHAL_FunctionsParameter="277" idParameterClass="1" idParameterType="2" name="iStart"/><HAL_FunctionsParameter descr="amount of values used" fid="27" idHAL_FunctionsParameter="278" idParameterClass="1" idParameterType="2" name="num"/><HAL_FunctionsParameter descr="value 1" fid="27" idHAL_FunctionsParameter="279" idParameterClass="1" idParameterType="1" name="v1"/><HAL_FunctionsParameter descr="value 2" fid="27" idHAL_FunctionsParameter="280" idParameterClass="1" idParameterType="1" name="v2"/><HAL_FunctionsParameter descr="value 3" fid="27" idHAL_FunctionsParameter="281" idParameterClass="1" idParameterType="1" name="v3"/><HAL_FunctionsParameter descr="vector a" fid="28" idHAL_FunctionsParameter="282" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector b" fid="28" idHAL_FunctionsParameter="283" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector a" fid="29" idHAL_FunctionsParameter="284" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector b" fid="29" idHAL_FunctionsParameter="285" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector c" fid="29" idHAL_FunctionsParameter="286" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector a" fid="30" idHAL_FunctionsParameter="287" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector a" fid="31" idHAL_FunctionsParameter="288" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector a" fid="32" idHAL_FunctionsParameter="289" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector a" fid="33" idHAL_FunctionsParameter="290" idParameterClass="3" idParameterType="1" name="a"/><HAL_FunctionsParameter descr="vector b" fid="30" idHAL_FunctionsParameter="291" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector b" fid="31" idHAL_FunctionsParameter="292" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector b" fid="32" idHAL_FunctionsParameter="293" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector b" fid="33" idHAL_FunctionsParameter="294" idParameterClass="3" idParameterType="1" name="b"/><HAL_FunctionsParameter descr="vector c" fid="30" idHAL_FunctionsParameter="295" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector c" fid="31" idHAL_FunctionsParameter="296" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector c" fid="32" idHAL_FunctionsParameter="297" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="vector c" fid="33" idHAL_FunctionsParameter="298" idParameterClass="3" idParameterType="1" name="c"/><HAL_FunctionsParameter descr="noisegate" fid="111" idHAL_FunctionsParameter="299" idParameterClass="3" idParameterType="11" name="ng"/><HAL_FunctionsParameter descr="time average value for the rms" fid="111" idHAL_FunctionsParameter="300" idParameterClass="1" idParameterType="1" name="rmsTAV"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="111" idHAL_FunctionsParameter="301" idParameterClass="1" idParameterType="1" name="AT"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="111" idHAL_FunctionsParameter="302" idParameterClass="1" idParameterType="1" name="RT"/><HAL_FunctionsParameter descr="noise cut off threshold" fid="111" idHAL_FunctionsParameter="303" idParameterClass="1" idParameterType="1" name="NT"/><HAL_FunctionsParameter descr="slope" fid="111" idHAL_FunctionsParameter="304" idParameterClass="1" idParameterType="1" name="NS"/><HAL_FunctionsParameter descr="expander" fid="112" idHAL_FunctionsParameter="305" idParameterClass="3" idParameterType="12" name="exp"/><HAL_FunctionsParameter descr="time average value for the rms" fid="112" idHAL_FunctionsParameter="306" idParameterClass="1" idParameterType="1" name="rmsTAV"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="112" idHAL_FunctionsParameter="307" idParameterClass="1" idParameterType="1" name="AT"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="112" idHAL_FunctionsParameter="308" idParameterClass="1" idParameterType="1" name="RT"/><HAL_FunctionsParameter descr="expander threshold" fid="112" idHAL_FunctionsParameter="309" idParameterClass="1" idParameterType="1" name="ET"/><HAL_FunctionsParameter descr="slope" fid="112" idHAL_FunctionsParameter="310" idParameterClass="1" idParameterType="1" name="ES"/><HAL_FunctionsParameter descr="compressor" fid="113" idHAL_FunctionsParameter="311" idParameterClass="3" idParameterType="13" name="comp"/><HAL_FunctionsParameter descr="limiter" fid="114" idHAL_FunctionsParameter="312" idParameterClass="3" idParameterType="14" name="lim"/><HAL_FunctionsParameter descr="time average value for the rms" fid="113" idHAL_FunctionsParameter="313" idParameterClass="1" idParameterType="1" name="rmsTAV"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="113" idHAL_FunctionsParameter="314" idParameterClass="1" idParameterType="1" name="AT"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="113" idHAL_FunctionsParameter="315" idParameterClass="1" idParameterType="1" name="RT"/><HAL_FunctionsParameter descr="compressor threshold" fid="113" idHAL_FunctionsParameter="316" idParameterClass="1" idParameterType="1" name="CT"/><HAL_FunctionsParameter descr="slope" fid="113" idHAL_FunctionsParameter="317" idParameterClass="1" idParameterType="1" name="CS"/><HAL_FunctionsParameter descr="attack value for the peak detection" fid="114" idHAL_FunctionsParameter="318" idParameterClass="1" idParameterType="1" name="ATpeak"/><HAL_FunctionsParameter descr="release value for the peak detection" fid="114" idHAL_FunctionsParameter="319" idParameterClass="1" idParameterType="1" name="RTpeak"/><HAL_FunctionsParameter descr="attack value for the smoothing" fid="114" idHAL_FunctionsParameter="320" idParameterClass="1" idParameterType="1" name="ATsmooth"/><HAL_FunctionsParameter descr="release value for the smoothing" fid="114" idHAL_FunctionsParameter="321" idParameterClass="1" idParameterType="1" name="RTsmooth"/><HAL_FunctionsParameter descr="limiter threshold" fid="114" idHAL_FunctionsParameter="322" idParameterClass="1" idParameterType="1" name="LT"/><HAL_FunctionsParameter descr="slope" fid="114" idHAL_FunctionsParameter="323" idParameterClass="1" idParameterType="1" name="LS"/><HAL_FunctionsParameter descr="value 4" fid="20" idHAL_FunctionsParameter="324" idParameterClass="1" idParameterType="2" name="v4"/><HAL_FunctionsParameter descr="value 4" fid="27" idHAL_FunctionsParameter="325" idParameterClass="1" idParameterType="1" name="v4"/><HAL_FunctionsParameter descr="input" fid="115" idHAL_FunctionsParameter="326" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="noisegate" fid="115" idHAL_FunctionsParameter="327" idParameterClass="3" idParameterType="11" name="ng"/><HAL_FunctionsParameter descr="output" fid="115" idHAL_FunctionsParameter="328" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="input" fid="116" idHAL_FunctionsParameter="329" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="117" idHAL_FunctionsParameter="330" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="input" fid="118" idHAL_FunctionsParameter="331" idParameterClass="3" idParameterType="1" name="x"/><HAL_FunctionsParameter descr="expander" fid="116" idHAL_FunctionsParameter="332" idParameterClass="3" idParameterType="12" name="exp"/><HAL_FunctionsParameter descr="compressor" fid="117" idHAL_FunctionsParameter="333" idParameterClass="3" idParameterType="13" name="comp"/><HAL_FunctionsParameter descr="limiter" fid="118" idHAL_FunctionsParameter="334" idParameterClass="3" idParameterType="14" name="lim"/><HAL_FunctionsParameter descr="output" fid="116" idHAL_FunctionsParameter="335" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="output" fid="117" idHAL_FunctionsParameter="336" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="output" fid="118" idHAL_FunctionsParameter="337" idParameterClass="3" idParameterType="1" name="y"/><HAL_FunctionsParameter descr="chars coded as 4 byte integer" fid="6" idHAL_FunctionsParameter="338" idParameterClass="1" idParameterType="4" name="v4"/><HAL_FunctionsParameter descr="the string at its end the other string is concated" fid="7" idHAL_FunctionsParameter="339" idParameterClass="3" idParameterType="3" name="s1"/><HAL_FunctionsParameter descr="index of the string 1" fid="7" idHAL_FunctionsParameter="340" idParameterClass="1" idParameterType="2" name="i1"/><HAL_FunctionsParameter descr="the concat string" fid="7" idHAL_FunctionsParameter="341" idParameterClass="3" idParameterType="3" name="s2"/><HAL_FunctionsParameter descr="index of the string 2" fid="7" idHAL_FunctionsParameter="342" idParameterClass="1" idParameterType="2" name="i2"/><HAL_FunctionsParameter descr="the string" fid="8" idHAL_FunctionsParameter="343" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="the string" fid="9" idHAL_FunctionsParameter="344" idParameterClass="3" idParameterType="3" name="s"/><HAL_FunctionsParameter descr="index of the string at the array" fid="8" idHAL_FunctionsParameter="345" idParameterClass="1" idParameterType="2" name="sIndex"/><HAL_FunctionsParameter descr="index of the string at the array" fid="9" idHAL_FunctionsParameter="346" idParameterClass="1" idParameterType="2" name="sIndex"/><HAL_FunctionsParameter descr="rational vector" fid="8" idHAL_FunctionsParameter="347" idParameterClass="3" idParameterType="1" name="r"/><HAL_FunctionsParameter descr="rational vector index" fid="8" idHAL_FunctionsParameter="348" idParameterClass="1" idParameterType="2" name="rIndx"/><HAL_FunctionsParameter descr="integer vector" fid="9" idHAL_FunctionsParameter="349" idParameterClass="3" idParameterType="2" name="i"/><HAL_FunctionsParameter descr="integer vector indx" fid="9" idHAL_FunctionsParameter="350" idParameterClass="1" idParameterType="2" name="iIndex"/><HAL_FunctionsParameter descr="the string at its end the other string is concated" fid="10" idHAL_FunctionsParameter="351" idParameterClass="3" idParameterType="3" name="s1"/><HAL_FunctionsParameter descr="index of the string 1" fid="10" idHAL_FunctionsParameter="352" idParameterClass="1" idParameterType="2" name="i1"/><HAL_FunctionsParameter descr="the concat string" fid="10" idHAL_FunctionsParameter="353" idParameterClass="3" idParameterType="3" name="s2"/><HAL_FunctionsParameter descr="index of the string 2" fid="10" idHAL_FunctionsParameter="354" idParameterClass="1" idParameterType="2" name="i2"/></HAL_FunctionsParameter_List><HAL_MessageParameter_List><HAL_MessageParameter basicTypeID="2" descr="number of the global variables" idHAL_MessageParameter="1" isArray="False" msgID="10" name="globalVariableNumber" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="number of the local variables" idHAL_MessageParameter="2" isArray="False" msgID="10" name="localVariableNumber" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="number of the instructions" idHAL_MessageParameter="3" isArray="False" msgID="10" name="instructionNumber" positionIndex="2"/><HAL_MessageParameter basicTypeID="2" descr="the index of the variable" idHAL_MessageParameter="9" isArray="False" msgID="11" name="index" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="type id of the variable" idHAL_MessageParameter="10" isArray="False" msgID="11" name="varTypeID" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="number of variables" idHAL_MessageParameter="11" isArray="False" msgID="11" name="num" positionIndex="2"/><HAL_MessageParameter basicTypeID="2" descr="index of the function call" idHAL_MessageParameter="12" isArray="False" msgID="12" name="index" positionIndex="0"/><HAL_MessageParameter basicTypeID="4" descr="function byte code" idHAL_MessageParameter="13" isArray="True" msgID="12" name="fbc" positionIndex="1"/><HAL_MessageParameter basicTypeID="2" descr="global variable index" idHAL_MessageParameter="14" isArray="False" msgID="23" name="gIndex" positionIndex="0"/><HAL_MessageParameter basicTypeID="2" descr="amount of data elements" idHAL_MessageParameter="15" isArray="False" msgID="23" name="dataElements" positionIndex="1"/></HAL_MessageParameter_List><HAL_VariableDefinition_List><HAL_VariableDefinition VariableID="1" description="a rational number" idHAL_VariableDefinition="1" varName="rational"/><HAL_VariableDefinition VariableID="2" description="a integer number" idHAL_VariableDefinition="2" varName="integer"/><HAL_VariableDefinition VariableID="3" description="a string" idHAL_VariableDefinition="3" varName="string"/><HAL_VariableDefinition VariableID="10" description="a biquad filter" idHAL_VariableDefinition="4" varName="biquad"/><HAL_VariableDefinition VariableID="20" description="a delay" idHAL_VariableDefinition="5" varName="delay"/><HAL_VariableDefinition VariableID="30" description="FFT or IFFT sturcture" idHAL_VariableDefinition="6" varName="FFT"/><HAL_VariableDefinition VariableID="4" description="a complex number" idHAL_VariableDefinition="7" varName="complex"/><HAL_VariableDefinition VariableID="101" description="button UI" idHAL_VariableDefinition="8" varName="button"/><HAL_VariableDefinition VariableID="100" description="panel UI" idHAL_VariableDefinition="9" varName="panel"/><HAL_VariableDefinition VariableID="102" description="led UI" idHAL_VariableDefinition="10" varName="led"/><HAL_VariableDefinition VariableID="103" description="display UI" idHAL_VariableDefinition="11" varName="display"/><HAL_VariableDefinition VariableID="11" description="a noisegate" idHAL_VariableDefinition="12" varName="noisegate"/><HAL_VariableDefinition VariableID="12" description="a expander" idHAL_VariableDefinition="13" varName="expander"/><HAL_VariableDefinition VariableID="13" description="a compressor" idHAL_VariableDefinition="14" varName="compressor"/><HAL_VariableDefinition VariableID="14" description="a limiter" idHAL_VariableDefinition="15" varName="limiter"/></HAL_VariableDefinition_List><HAL_Function_List><HAL_Function descr="a &lt; b ? CF = 1 : CF = 0" fid="40" idHAL_Function="17" name="compareIntegerLess"/><HAL_Function descr="a &gt; b ? CF = 1 : CF = 0" fid="41" idHAL_Function="18" name="compareIntegerMore"/><HAL_Function descr="a == b ? CF = 1 : CF = 0" fid="42" idHAL_Function="19" name="compareIntegerEqual"/><HAL_Function descr="a != b ? CF = 1 : CF = 0" fid="43" idHAL_Function="20" name="compareIntegerNEqual"/><HAL_Function descr="a &lt;= b ? CF = 1 : CF = 0" fid="44" idHAL_Function="21" name="compareIntegerLessEqual"/><HAL_Function descr="a &gt;= b ? CF = 1 : CF = 0" fid="45" idHAL_Function="22" name="compareIntegerMoreEqual"/><HAL_Function descr="jumps n instructions" fid="50" idHAL_Function="23" name="jump"/><HAL_Function descr="jumps if the carry flag is set n instructions" fid="51" idHAL_Function="24" name="jumpCF"/><HAL_Function descr="jumps if the carry flag is not set n instructions" fid="52" idHAL_Function="25" name="jumpNCF"/><HAL_Function descr="reading a sample from an input" fid="60" idHAL_Function="26" name="readSample"/><HAL_Function descr="writes a sample to a output" fid="61" idHAL_Function="27" name="writeSample"/><HAL_Function descr="generate a test signal, witch can be used to meassure performance" fid="3" idHAL_Function="28" name="genTestSignal"/><HAL_Function descr="inits a biquad filter as an high pass filter" fid="100" idHAL_Function="29" name="initBiquadAsHP"/><HAL_Function descr="inits a biquad filter as a low pass filter" fid="101" idHAL_Function="32" name="initBiquadAsLP"/><HAL_Function descr="convolute biquad with an input and generate an output" fid="110" idHAL_Function="33" name="convoluteBiquad"/><HAL_Function descr="shifts the content of the delay" fid="150" idHAL_Function="34" name="calcDelay"/><HAL_Function descr="inits an array as an &quot;von Hann&quot; window" fid="120" idHAL_Function="36" name="initHannWindow"/><HAL_Function descr="init FFT structure as real input FFT" fid="130" idHAL_Function="37" name="initRFFT"/><HAL_Function descr="init inverse FFT structure" fid="131" idHAL_Function="38" name="initIFFT"/><HAL_Function descr="reading a frames of sample from an input" fid="62" idHAL_Function="39" name="readSampleFrame"/><HAL_Function descr="writes a frame of samples to a output" fid="63" idHAL_Function="40" name="writeSampleFrame"/><HAL_Function descr="processes the IFFT" fid="133" idHAL_Function="43" name="processIFFT"/><HAL_Function descr="processes the real input FFT" fid="132" idHAL_Function="44" name="processRFFT"/><HAL_Function descr="inits a panel" fid="201" idHAL_Function="49" name="uiInitPanel"/><HAL_Function descr="inits a button" fid="202" idHAL_Function="50" name="uiInitButton"/><HAL_Function descr="inits a display" fid="203" idHAL_Function="51" name="uiInitDisplay"/><HAL_Function descr="inits a LED" fid="204" idHAL_Function="52" name="uiInitLED"/><HAL_Function descr="resets the size of a string" fid="5" idHAL_Function="53" name="setStringSize"/><HAL_Function descr="set the string" fid="6" idHAL_Function="54" name="setStringValues"/><HAL_Function descr="sets the dimension of a UI" fid="200" idHAL_Function="55" name="uiSetDim"/><HAL_Function descr="if the button was pressed the CF is set" fid="210" idHAL_Function="56" name="uiCheckButtonPressed"/><HAL_Function descr="set the LED state" fid="211" idHAL_Function="57" name="uiSetLED"/><HAL_Function descr="sets the carry flag" fid="55" idHAL_Function="58" name="setCF"/><HAL_Function descr="set the text of a display" fid="212" idHAL_Function="59" name="uiSetDisplay"/><HAL_Function descr="a = values" fid="20" idHAL_Function="60" name="assignConstInteger"/><HAL_Function descr="c = a + b" fid="22" idHAL_Function="61" name="addInteger"/><HAL_Function descr="c = a - b" fid="23" idHAL_Function="62" name="subInteger"/><HAL_Function descr="c = a * b" fid="24" idHAL_Function="63" name="mulInteger"/><HAL_Function descr="c = a / b" fid="25" idHAL_Function="64" name="divInteger"/><HAL_Function descr="a = b" fid="21" idHAL_Function="65" name="assignInteger"/><HAL_Function descr="c = mod(a,b)" fid="26" idHAL_Function="66" name="modInteger"/><HAL_Function descr="updates a global variable" fid="56" idHAL_Function="67" name="update"/><HAL_Function descr="inits a biquad filter as peak filter" fid="102" idHAL_Function="68" name="initBiquadAsPeakFilter"/><HAL_Function descr="inits a biquad filter as low ferquency shelving filter" fid="103" idHAL_Function="71" name="initBiquadAsLowFreqShelvFilter"/><HAL_Function descr="inits a biquad filter as high ferquency shelving filter" fid="104" idHAL_Function="72" name="initBiquadAsHighFreqShelvFilter"/><HAL_Function descr="a = values" fid="27" idHAL_Function="73" name="assignConstRational"/><HAL_Function descr="a = b" fid="28" idHAL_Function="74" name="assignRational"/><HAL_Function descr="c = a + b" fid="29" idHAL_Function="75" name="addRational"/><HAL_Function descr="c = a - b" fid="30" idHAL_Function="76" name="subRational"/><HAL_Function descr="c = a * b" fid="31" idHAL_Function="77" name="mulRational"/><HAL_Function descr="c = a / b" fid="32" idHAL_Function="78" name="divRational"/><HAL_Function descr="c = mod(a,b)" fid="33" idHAL_Function="79" name="modRational"/><HAL_Function descr="a &lt; b ? CF = 1 : CF = 0" fid="34" idHAL_Function="80" name="compareRationalLess"/><HAL_Function descr="a &gt; b ? CF = 1 : CF = 0" fid="35" idHAL_Function="81" name="compareRationalMore"/><HAL_Function descr="a == b ? CF = 1 : CF = 0" fid="36" idHAL_Function="82" name="compareRationalEqual"/><HAL_Function descr="a != b ? CF = 1 : CF = 0" fid="37" idHAL_Function="83" name="compareRationalNEqual"/><HAL_Function descr="a &lt;= b ? CF = 1 : CF = 0" fid="38" idHAL_Function="84" name="compareRationalLessEqual"/><HAL_Function descr="a &gt;= b ? CF = 1 : CF = 0" fid="39" idHAL_Function="85" name="compareRationalMoreEqual"/><HAL_Function descr="initialize a noisegate" fid="111" idHAL_Function="86" name="initNoisegate"/><HAL_Function descr="initialize a expander" fid="112" idHAL_Function="87" name="initExpander"/><HAL_Function descr="initialize a compressor" fid="113" idHAL_Function="88" name="initCompressor"/><HAL_Function descr="initialize a limiter" fid="114" idHAL_Function="89" name="initLimiter"/><HAL_Function descr="sends a stream of samples through a noisegate" fid="115" idHAL_Function="90" name="calcNoisegate"/><HAL_Function descr="sends a stream of samples through a expander" fid="116" idHAL_Function="91" name="calcExpander"/><HAL_Function descr="sends a stream of samples through a compressor" fid="117" idHAL_Function="92" name="calcCompressor"/><HAL_Function descr="sends a stream of samples through a limiter" fid="118" idHAL_Function="93" name="calcLimiter"/><HAL_Function descr="concat two strings" fid="7" idHAL_Function="94" name="concatStrings"/><HAL_Function descr="converts a rational to a string" fid="8" idHAL_Function="95" name="rationalToString"/><HAL_Function descr="converts an integer to a string" fid="9" idHAL_Function="96" name="integerToString"/><HAL_Function descr="assigns a string to an other" fid="10" idHAL_Function="97" name="assignString"/></HAL_Function_List><HAL_MessageType_List><HAL_MessageType descr="acknowledge" idHAL_MessageType="1" msgID="1" name="ACK"/><HAL_MessageType descr="not acknowledge" idHAL_MessageType="2" msgID="2" name="NACK"/><HAL_MessageType descr="start sending a program" idHAL_MessageType="3" msgID="10" name="startPrg"/><HAL_MessageType descr="sends a variable" idHAL_MessageType="4" msgID="11" name="sendVariable"/><HAL_MessageType descr="sends an instruction" idHAL_MessageType="5" msgID="12" name="sendInstruction"/><HAL_MessageType descr="sings that the program transmission has completed" idHAL_MessageType="6" msgID="13" name="endPrg"/><HAL_MessageType descr="stops the AP" idHAL_MessageType="7" msgID="20" name="stop"/><HAL_MessageType descr="the AP executes one instruction" idHAL_MessageType="8" msgID="21" name="step"/><HAL_MessageType descr="the AP runs the program" idHAL_MessageType="9" msgID="22" name="run"/><HAL_MessageType descr="a variable going to be updated" idHAL_MessageType="10" msgID="23" name="updateVariable"/><HAL_MessageType descr="a AP is going to be logged in to the system" idHAL_MessageType="11" msgID="30" name="login"/><HAL_MessageType descr="a AP is going to be logged out of the system" idHAL_MessageType="12" msgID="31" name="logout"/></HAL_MessageType_List><HAL_MessageProcess_List><HAL_MessageProcess descr="log in the AP to the system" idHAL_MessageProcess="1" isRX="False" msgProcID="10" name="login">TX_login [handle=none]() {
	declare	recv	Node;
	declare	mNum	mNum;

	recv = ALL;
	loopAll drivers[driver] {
		mNum = getNewMsgNum();
		driver&gt;&gt;send(login(recv,mNum));
	}
return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handle login calls" idHAL_MessageProcess="2" isRX="True" msgProcID="30" name="login">RX_login [handle=login]() {
	declare	sender	Node;
	declare	driver	Driver;
	declare	mNum	mNum;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();

	if (!addNode(sender, driver)) {
		return driver&gt;&gt;send(login(sender,mNum));
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="runs the audio-processor" idHAL_MessageProcess="3" isRX="False" msgProcID="20" name="run">TX_run [handle=none](Node dest) {
	declare	driver	Driver;
	declare	sender	Node;
	declare	mNum	mNum;

	sender = getSelfSenderID();
	if (dest != ALL) {
		mNum = getNewMsgNum();
		driver = getDriver(dest);
		driver&gt;&gt;send(run(sender,mNum));
		return waitACK(mNum);
	}

	loopAll drivers[drv] {
		mNum = getNewMsgNum();
		drv&gt;&gt;send(run(sender,mNum));
		if (waitACK(mNum)) {
			return -1;
		}
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handles the run command" idHAL_MessageProcess="4" isRX="True" msgProcID="22" name="run">RX_run [handle=run]() {
	declare	sender			Node;
	declare	driver			Driver;
	declare	mNum			mNum;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();

	if (!runAP()) {
		return driver&gt;&gt;send(ACK(sender,mNum));
	} else {
		return driver&gt;&gt;send(NACK(sender,mNum));
	}
}
</HAL_MessageProcess><HAL_MessageProcess descr="log the AP out of the system" idHAL_MessageProcess="5" isRX="False" msgProcID="0" name="logout">TX_logout [handle=none]() {
	declare	recv	Node;
	declare	mNum	mNum;

	recv = ALL;
	loopAll drivers[driver] {
		mNum = getNewMsgNum();
		driver&gt;&gt;send(logout(recv,mNum));
	}
return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="handle login calls" idHAL_MessageProcess="6" isRX="True" msgProcID="31" name="logout">RX_logout [handle=logout]() {
	declare	sender	Node;
	
	sender = getSender();

	removeNode(sender);
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="updates a global variable at diffrent systems" idHAL_MessageProcess="9" isRX="False" msgProcID="0" name="updateVariable">TX_updateVariable [handle=none](VarIndex vi) {
	declare	mNum	mNum;
	declare	apV		Variable;

	apV = getVariableByIndex(vi);

	loopAll nodes[node] {
		if (getNodeIDfromNode(node) != getSelfSenderID()) {
			mNum = getNewMsgNum();
			apV&gt;&gt;call(sendUpdate(getVariableData(apV),getDriverFromNode(node),ALL,mNum,vi));
			if (waitACK(mNum)) {
				return -1;
			}
		}
	}
	return 0;
}
</HAL_MessageProcess><HAL_MessageProcess descr="updates a global variable at diffrent systems" idHAL_MessageProcess="10" isRX="True" msgProcID="23" name="updateVariable">RX_updateVariable [handle=updateVariable]() {
	declare	sender			Node;
	declare	driver			Driver;
	declare	mNum			mNum;
	declare	apV				Variable;
	declare	gIndex			int;

	sender = getSender();
	driver = getDriver();
	mNum = getMsgNum();
	gIndex = getMsgDataToInt(0);

	apV = getVariableByIndex(gIndex);
	if (!apV) {
		return -1;
	}

	apV&gt;&gt;call(recvUpdate(getVariableData(apV),getMsgDataRef()));

	return driver&gt;&gt;send(ACK(sender,mNum));
}</HAL_MessageProcess></HAL_MessageProcess_List><Includes_List><Includes idIncludes="8" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="9" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="10" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="12" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="13" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="14" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="15" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="16" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="17" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="18" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="19" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="23" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="24" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="25" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="26" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="27" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="28" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="29" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="30" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="31" includefile="-1" lib="string.h" syslib=""/><Includes idIncludes="32" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="33" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="34" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="35" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="36" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="37" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="42" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="43" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="44" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="45" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="46" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="47" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="48" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="49" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="50" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="51" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="52" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="53" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="54" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="55" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="56" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="57" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="58" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="59" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="60" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="61" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="62" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="63" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="64" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="65" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="66" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="67" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="68" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="69" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="70" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="71" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="72" includefile="AP" lib="" syslib="0"/><Includes idIncludes="73" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="74" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="75" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="77" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="78" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="79" includefile="sndfile.h" lib="sndfile-1" syslib="0"/><Includes idIncludes="84" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="85" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="86" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="87" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="88" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="89" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="90" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="91" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="92" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="93" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="95" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="96" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="98" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="99" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="104" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="105" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="116" includefile="fftw3.h" lib="libfftw3f-3" syslib="0"/><Includes idIncludes="117" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="120" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="129" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="132" includefile="sndfile.h" lib="sndfile-1" syslib="0"/><Includes idIncludes="133" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="134" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="135" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="136" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="140" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="141" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="142" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="143" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="148" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="149" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="150" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="151" includefile="sru21369.h" lib="" syslib="1"/><Includes idIncludes="152" includefile="cdef21369.h" lib="" syslib="1"/><Includes idIncludes="153" includefile="def21369.h" lib="" syslib="1"/><Includes idIncludes="154" includefile="signal.h" lib="" syslib="1"/><Includes idIncludes="155" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="156" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="160" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="161" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="162" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="163" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="164" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="166" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="167" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="169" includefile="sndfile.h" lib="sndfile-1" syslib="1"/><Includes idIncludes="170" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="171" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="172" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="173" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="174" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="177" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="178" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="179" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="180" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="185" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="188" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="189" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="190" includefile="winsock2.h" lib="ws2_32" syslib="1"/><Includes idIncludes="191" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="192" includefile="ws2tcpip.h" lib="" syslib="1"/><Includes idIncludes="193" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="195" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="196" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="197" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="198" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="199" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="200" includefile="winsock2.h" lib="ws2_32" syslib="1"/><Includes idIncludes="201" includefile="ws2tcpip.h" lib="" syslib="1"/><Includes idIncludes="203" includefile="pthread.h" lib="pthread" syslib="1"/><Includes idIncludes="204" includefile="semaphore.h" lib="" syslib="1"/><Includes idIncludes="205" includefile="pthread.h" lib="" syslib="1"/><Includes idIncludes="206" includefile="gtk/gtk.h" lib="gtk-win32-2.0" syslib="1"/><Includes idIncludes="207" includefile="glib.h" lib="glib-2.0" syslib="1"/><Includes idIncludes="208" includefile="gthread.h" lib="gthread-2.0" syslib="1"/><Includes idIncludes="209" includefile="glib-object.h" lib="gobject-2.0" syslib="1"/><Includes idIncludes="210" includefile="cairo.h" lib="cairo" syslib="1"/><Includes idIncludes="211" includefile="pango/pango.h" lib="pango-1.0" syslib="1"/><Includes idIncludes="212" includefile="semaphore.h" lib="pthread" syslib="1"/><Includes idIncludes="213" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="219" includefile="gdk/gdk.h" lib="gdk-win32-2.0" syslib="1"/><Includes idIncludes="224" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="225" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="230" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="231" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="232" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="233" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="235" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="236" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="237" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="238" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="239" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="240" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="242" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="243" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="244" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="245" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="246" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="247" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="248" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="249" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="250" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="251" includefile="stdint.h" lib="" syslib="1"/><Includes idIncludes="252" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="253" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="254" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="255" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="256" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="257" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="258" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="265" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="266" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="267" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="268" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="269" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="270" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="271" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="272" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="273" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="274" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="275" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="276" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="277" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="278" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="279" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="280" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="281" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="282" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="283" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="284" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="285" includefile="string.h" lib="" syslib="0"/><Includes idIncludes="286" includefile="sru21369.h" lib="" syslib="1"/><Includes idIncludes="287" includefile="cdef21369.h" lib="" syslib="1"/><Includes idIncludes="288" includefile="def21369.h" lib="" syslib="1"/><Includes idIncludes="289" includefile="signal.h" lib="" syslib="1"/><Includes idIncludes="290" includefile="stdio.h" lib="" syslib="1"/><Includes idIncludes="291" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="292" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="293" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="294" includefile="msp430x16x.h" lib="" syslib="1"/><Includes idIncludes="295" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="296" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="297" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="298" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="299" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="300" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="301" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="302" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="303" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="304" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="305" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="306" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="307" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="308" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="309" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="310" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="311" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="312" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="313" includefile="stdlib.h" lib="" syslib="1"/><Includes idIncludes="314" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="315" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="316" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="317" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="318" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="319" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="320" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="321" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="322" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="323" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="324" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="325" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="326" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="327" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="328" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="329" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="330" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="331" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="332" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="333" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="334" includefile="math.h" lib="m" syslib="1"/><Includes idIncludes="335" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="336" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="337" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="338" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="339" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="340" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="341" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="342" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="343" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="344" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="345" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="346" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="347" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="348" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="349" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="350" includefile="AP.h" lib="" syslib="0"/><Includes idIncludes="351" includefile="string.h" lib="" syslib="1"/><Includes idIncludes="352" includefile="AP.h" lib="" syslib="0"/></Includes_List><IncludeList_List><IncludeList idCode="10" idIncludes="8"/><IncludeList idCode="11" idIncludes="9"/><IncludeList idCode="12" idIncludes="10"/><IncludeList idCode="14" idIncludes="12"/><IncludeList idCode="15" idIncludes="13"/><IncludeList idCode="16" idIncludes="14"/><IncludeList idCode="17" idIncludes="15"/><IncludeList idCode="18" idIncludes="16"/><IncludeList idCode="20" idIncludes="17"/><IncludeList idCode="21" idIncludes="18"/><IncludeList idCode="22" idIncludes="19"/><IncludeList idCode="26" idIncludes="23"/><IncludeList idCode="27" idIncludes="24"/><IncludeList idCode="28" idIncludes="25"/><IncludeList idCode="29" idIncludes="26"/><IncludeList idCode="30" idIncludes="27"/><IncludeList idCode="31" idIncludes="28"/><IncludeList idCode="32" idIncludes="29"/><IncludeList idCode="33" idIncludes="30"/><IncludeList idCode="33" idIncludes="31"/><IncludeList idCode="34" idIncludes="32"/><IncludeList idCode="34" idIncludes="33"/><IncludeList idCode="35" idIncludes="34"/><IncludeList idCode="35" idIncludes="35"/><IncludeList idCode="36" idIncludes="36"/><IncludeList idCode="36" idIncludes="37"/><IncludeList idCode="41" idIncludes="42"/><IncludeList idCode="41" idIncludes="43"/><IncludeList idCode="42" idIncludes="44"/><IncludeList idCode="42" idIncludes="45"/><IncludeList idCode="43" idIncludes="46"/><IncludeList idCode="43" idIncludes="47"/><IncludeList idCode="44" idIncludes="48"/><IncludeList idCode="44" idIncludes="49"/><IncludeList idCode="45" idIncludes="50"/><IncludeList idCode="45" idIncludes="51"/><IncludeList idCode="46" idIncludes="52"/><IncludeList idCode="46" idIncludes="53"/><IncludeList idCode="47" idIncludes="54"/><IncludeList idCode="47" idIncludes="55"/><IncludeList idCode="48" idIncludes="56"/><IncludeList idCode="48" idIncludes="57"/><IncludeList idCode="49" idIncludes="58"/><IncludeList idCode="49" idIncludes="59"/><IncludeList idCode="50" idIncludes="60"/><IncludeList idCode="50" idIncludes="61"/><IncludeList idCode="51" idIncludes="62"/><IncludeList idCode="51" idIncludes="63"/><IncludeList idCode="52" idIncludes="64"/><IncludeList idCode="53" idIncludes="65"/><IncludeList idCode="54" idIncludes="66"/><IncludeList idCode="54" idIncludes="67"/><IncludeList idCode="55" idIncludes="68"/><IncludeList idCode="55" idIncludes="69"/><IncludeList idCode="56" idIncludes="70"/><IncludeList idCode="58" idIncludes="71"/><IncludeList idCode="59" idIncludes="72"/><IncludeList idCode="60" idIncludes="73"/><IncludeList idCode="61" idIncludes="74"/><IncludeList idCode="62" idIncludes="75"/><IncludeList idCode="64" idIncludes="77"/><IncludeList idCode="65" idIncludes="78"/><IncludeList idCode="66" idIncludes="79"/><IncludeList idCode="71" idIncludes="84"/><IncludeList idCode="72" idIncludes="85"/><IncludeList idCode="73" idIncludes="86"/><IncludeList idCode="74" idIncludes="87"/><IncludeList idCode="75" idIncludes="88"/><IncludeList idCode="76" idIncludes="89"/><IncludeList idCode="77" idIncludes="90"/><IncludeList idCode="78" idIncludes="91"/><IncludeList idCode="79" idIncludes="92"/><IncludeList idCode="80" idIncludes="93"/><IncludeList idCode="81" idIncludes="95"/><IncludeList idCode="82" idIncludes="96"/><IncludeList idCode="84" idIncludes="98"/><IncludeList idCode="85" idIncludes="99"/><IncludeList idCode="90" idIncludes="104"/><IncludeList idCode="91" idIncludes="105"/><IncludeList idCode="98" idIncludes="116"/><IncludeList idCode="99" idIncludes="117"/><IncludeList idCode="102" idIncludes="120"/><IncludeList idCode="111" idIncludes="129"/><IncludeList idCode="101" idIncludes="132"/><IncludeList idCode="101" idIncludes="133"/><IncludeList idCode="114" idIncludes="134"/><IncludeList idCode="115" idIncludes="135"/><IncludeList idCode="116" idIncludes="136"/><IncludeList idCode="120" idIncludes="140"/><IncludeList idCode="121" idIncludes="141"/><IncludeList idCode="122" idIncludes="142"/><IncludeList idCode="123" idIncludes="143"/><IncludeList idCode="125" idIncludes="148"/><IncludeList idCode="126" idIncludes="149"/><IncludeList idCode="125" idIncludes="150"/><IncludeList idCode="124" idIncludes="151"/><IncludeList idCode="124" idIncludes="152"/><IncludeList idCode="124" idIncludes="153"/><IncludeList idCode="124" idIncludes="154"/><IncludeList idCode="124" idIncludes="155"/><IncludeList idCode="127" idIncludes="156"/><IncludeList idCode="131" idIncludes="160"/><IncludeList idCode="132" idIncludes="161"/><IncludeList idCode="133" idIncludes="162"/><IncludeList idCode="134" idIncludes="163"/><IncludeList idCode="135" idIncludes="164"/><IncludeList idCode="137" idIncludes="166"/><IncludeList idCode="138" idIncludes="167"/><IncludeList idCode="140" idIncludes="169"/><IncludeList idCode="140" idIncludes="170"/><IncludeList idCode="141" idIncludes="171"/><IncludeList idCode="142" idIncludes="172"/><IncludeList idCode="143" idIncludes="173"/><IncludeList idCode="144" idIncludes="174"/><IncludeList idCode="145" idIncludes="177"/><IncludeList idCode="146" idIncludes="178"/><IncludeList idCode="147" idIncludes="179"/><IncludeList idCode="145" idIncludes="180"/><IncludeList idCode="152" idIncludes="185"/><IncludeList idCode="154" idIncludes="188"/><IncludeList idCode="155" idIncludes="189"/><IncludeList idCode="155" idIncludes="190"/><IncludeList idCode="155" idIncludes="191"/><IncludeList idCode="155" idIncludes="192"/><IncludeList idCode="155" idIncludes="193"/><IncludeList idCode="157" idIncludes="195"/><IncludeList idCode="158" idIncludes="196"/><IncludeList idCode="159" idIncludes="197"/><IncludeList idCode="155" idIncludes="198"/><IncludeList idCode="160" idIncludes="199"/><IncludeList idCode="152" idIncludes="200"/><IncludeList idCode="152" idIncludes="201"/><IncludeList idCode="161" idIncludes="203"/><IncludeList idCode="161" idIncludes="204"/><IncludeList idCode="152" idIncludes="205"/><IncludeList idCode="162" idIncludes="206"/><IncludeList idCode="162" idIncludes="207"/><IncludeList idCode="162" idIncludes="208"/><IncludeList idCode="162" idIncludes="209"/><IncludeList idCode="162" idIncludes="210"/><IncludeList idCode="162" idIncludes="211"/><IncludeList idCode="162" idIncludes="212"/><IncludeList idCode="162" idIncludes="213"/><IncludeList idCode="162" idIncludes="219"/><IncludeList idCode="162" idIncludes="224"/><IncludeList idCode="172" idIncludes="225"/><IncludeList idCode="177" idIncludes="230"/><IncludeList idCode="178" idIncludes="231"/><IncludeList idCode="179" idIncludes="232"/><IncludeList idCode="180" idIncludes="233"/><IncludeList idCode="182" idIncludes="235"/><IncludeList idCode="183" idIncludes="236"/><IncludeList idCode="184" idIncludes="237"/><IncludeList idCode="185" idIncludes="238"/><IncludeList idCode="186" idIncludes="239"/><IncludeList idCode="187" idIncludes="240"/><IncludeList idCode="189" idIncludes="242"/><IncludeList idCode="190" idIncludes="243"/><IncludeList idCode="191" idIncludes="244"/><IncludeList idCode="192" idIncludes="245"/><IncludeList idCode="193" idIncludes="246"/><IncludeList idCode="194" idIncludes="247"/><IncludeList idCode="195" idIncludes="248"/><IncludeList idCode="196" idIncludes="249"/><IncludeList idCode="1" idIncludes="250"/><IncludeList idCode="1" idIncludes="251"/><IncludeList idCode="197" idIncludes="252"/><IncludeList idCode="198" idIncludes="253"/><IncludeList idCode="199" idIncludes="254"/><IncludeList idCode="200" idIncludes="255"/><IncludeList idCode="201" idIncludes="256"/><IncludeList idCode="202" idIncludes="257"/><IncludeList idCode="203" idIncludes="258"/><IncludeList idCode="210" idIncludes="265"/><IncludeList idCode="211" idIncludes="266"/><IncludeList idCode="212" idIncludes="267"/><IncludeList idCode="213" idIncludes="268"/><IncludeList idCode="214" idIncludes="269"/><IncludeList idCode="215" idIncludes="270"/><IncludeList idCode="216" idIncludes="271"/><IncludeList idCode="219" idIncludes="272"/><IncludeList idCode="220" idIncludes="273"/><IncludeList idCode="221" idIncludes="274"/><IncludeList idCode="222" idIncludes="275"/><IncludeList idCode="223" idIncludes="276"/><IncludeList idCode="1" idIncludes="277"/><IncludeList idCode="224" idIncludes="278"/><IncludeList idCode="225" idIncludes="279"/><IncludeList idCode="226" idIncludes="280"/><IncludeList idCode="227" idIncludes="281"/><IncludeList idCode="228" idIncludes="282"/><IncludeList idCode="229" idIncludes="283"/><IncludeList idCode="230" idIncludes="284"/><IncludeList idCode="230" idIncludes="285"/><IncludeList idCode="231" idIncludes="286"/><IncludeList idCode="231" idIncludes="287"/><IncludeList idCode="231" idIncludes="288"/><IncludeList idCode="231" idIncludes="289"/><IncludeList idCode="231" idIncludes="290"/><IncludeList idCode="231" idIncludes="291"/><IncludeList idCode="232" idIncludes="292"/><IncludeList idCode="233" idIncludes="293"/><IncludeList idCode="145" idIncludes="294"/><IncludeList idCode="234" idIncludes="295"/><IncludeList idCode="235" idIncludes="296"/><IncludeList idCode="236" idIncludes="297"/><IncludeList idCode="237" idIncludes="298"/><IncludeList idCode="238" idIncludes="299"/><IncludeList idCode="239" idIncludes="300"/><IncludeList idCode="240" idIncludes="301"/><IncludeList idCode="241" idIncludes="302"/><IncludeList idCode="242" idIncludes="303"/><IncludeList idCode="243" idIncludes="304"/><IncludeList idCode="244" idIncludes="305"/><IncludeList idCode="245" idIncludes="306"/><IncludeList idCode="246" idIncludes="307"/><IncludeList idCode="247" idIncludes="308"/><IncludeList idCode="248" idIncludes="309"/><IncludeList idCode="249" idIncludes="310"/><IncludeList idCode="251" idIncludes="311"/><IncludeList idCode="250" idIncludes="312"/><IncludeList idCode="250" idIncludes="313"/><IncludeList idCode="252" idIncludes="314"/><IncludeList idCode="253" idIncludes="315"/><IncludeList idCode="254" idIncludes="316"/><IncludeList idCode="255" idIncludes="317"/><IncludeList idCode="256" idIncludes="318"/><IncludeList idCode="257" idIncludes="319"/><IncludeList idCode="258" idIncludes="320"/><IncludeList idCode="259" idIncludes="321"/><IncludeList idCode="260" idIncludes="322"/><IncludeList idCode="261" idIncludes="323"/><IncludeList idCode="262" idIncludes="324"/><IncludeList idCode="263" idIncludes="325"/><IncludeList idCode="264" idIncludes="326"/><IncludeList idCode="265" idIncludes="327"/><IncludeList idCode="266" idIncludes="328"/><IncludeList idCode="267" idIncludes="329"/><IncludeList idCode="268" idIncludes="330"/><IncludeList idCode="269" idIncludes="331"/><IncludeList idCode="270" idIncludes="332"/><IncludeList idCode="271" idIncludes="333"/><IncludeList idCode="272" idIncludes="334"/><IncludeList idCode="273" idIncludes="335"/><IncludeList idCode="274" idIncludes="336"/><IncludeList idCode="275" idIncludes="337"/><IncludeList idCode="276" idIncludes="338"/><IncludeList idCode="277" idIncludes="339"/><IncludeList idCode="278" idIncludes="340"/><IncludeList idCode="279" idIncludes="341"/><IncludeList idCode="280" idIncludes="342"/><IncludeList idCode="281" idIncludes="343"/><IncludeList idCode="282" idIncludes="344"/><IncludeList idCode="283" idIncludes="345"/><IncludeList idCode="284" idIncludes="346"/><IncludeList idCode="285" idIncludes="347"/><IncludeList idCode="286" idIncludes="348"/><IncludeList idCode="287" idIncludes="349"/><IncludeList idCode="288" idIncludes="350"/><IncludeList idCode="187" idIncludes="351"/><IncludeList idCode="292" idIncludes="352"/></IncludeList_List><Code_List><Code idCode="1">// ==============================================
// generic vector interface for integer and
// rational types based on the std. C lib
// ==============================================

// ----------------------------------------------
// generic integer type
// ----------------------------------------------

// transforms the integer to a 'unique form'
inline uint32_t APgenericInteger_ToUniform (uint32_t v) {
	uint32_t u;
	u = v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= (v &amp; 0xFF);
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= (v &amp; 0xFF);
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= (v &amp; 0xFF);
	return u;
}

// inverse transformation of the unique integer to the 'local form'
inline uint32_t APgenericInteger_FromUniform (uint32_t v) {
	uint32_t u;
	u = v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= v &amp; 0xFF;
	u &lt;&lt;= 8;
	v &gt;&gt;= 8;
	u |= v &amp; 0xFF;
	return u;
}



// type for a generic vector based int type
typedef struct SAPgenericIntegerVector {
	int32_t *	pVal;
	int			num;
} TAPgenericIntegerVector;

// create int vector
TAPgenericIntegerVector * APgenericIntegerVector_create (int num) {
	int i;
	// alloc memory
	TAPgenericIntegerVector * pI = malloc (sizeof(TAPgenericIntegerVector));
	if (!pI) return NULL;
	pI-&gt;pVal = malloc (sizeof(int32_t)*num);
	if (!pI-&gt;pVal) {
		free (pI);
		return NULL;
	}
	pI-&gt;num = num;
	// set memory
	for (i = 0; i&lt; num; i++) {
		pI-&gt;pVal[i] = 0;
	}
	return pI;
}

// destroy int vector
void APgenericIntegerVector_destroy (TAPgenericIntegerVector * pV) {
	if (pV) {
		free(pV-&gt;pVal);
		free(pV);
	}
}

// resize int vector
int APgenericIntegerVector_resize (TAPgenericIntegerVector * pV, int newNum) {
	int i;

	if (pV-&gt;num == newNum) return 0;
	free (pV-&gt;pVal);
	pV-&gt;pVal = malloc (sizeof(int32_t)*newNum);
	if (!pV-&gt;pVal) return -1;
	pV-&gt;num = newNum;
	// set memory
	for (i = 0; i&lt; newNum; i++) {
		pV-&gt;pVal[i] = 0;
	}
	return 0;
}

// assign a = values
int APgenericIntegerVector_assignConst (TAPgenericIntegerVector * pa, int iStart, int num, int32_t * pVals) {
	int i = iStart;
	int imax = i + num;
	int32_t * pD = pa-&gt;pVal + iStart;
	if (imax &gt; pa-&gt;num) imax = pa-&gt;num;

	for (; i &lt; imax; i++) {
		*pD = *pVals;
		pD++;
		pVals++;
	}
	return 0;
}

// assign a = b
int APgenericIntegerVector_assign (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb) {
	int imax = pa-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pa-&gt;pVal[i] = pb-&gt;pVal[i];
	}
	return 0;
}


// add c = a + b
int APgenericIntegerVector_add (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[i];
	}
	return 0;
}

// sub c = a - b
int APgenericIntegerVector_sub (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[i];
	}
	return 0;
}

// mul c = a * b
int APgenericIntegerVector_mul (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[i];
	}
	return 0;
}

// div c = a * b
int APgenericIntegerVector_div (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[i];
	}
	return 0;
}

// modulo c = a mod b
int APgenericIntegerVector_mod (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, TAPgenericIntegerVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] % pb-&gt;pVal[i];
	}
	return 0;
}

// cmp Element cmp(a[i],b[j]):
//		res = -1: a &lt; b
//		res = 1 : a &gt; b
//		res = 0: a = b
int APgenericIntegerVector_cmpEle (TAPgenericIntegerVector * pa, TAPgenericIntegerVector * pb, int ia, int ib) {
	int zwv = pa-&gt;pVal[ia] - pb-&gt;pVal[ib];
	if (!zwv) return 0;
	if (zwv &lt; 0) return -1;
	return 1;
}


// ----------------------------------------------
// generic rational type
// ----------------------------------------------

// type for a generic vector based float type
typedef struct SAPgenericRationalVector {
	float *		pVal;
	int			num;
} TAPgenericRationalVector;

// create float vector
TAPgenericRationalVector * APgenericRationalVector_create (int num) {
	int i;
	// alloc memory
	TAPgenericRationalVector * pR = malloc (sizeof(TAPgenericRationalVector));
	if (!pR) return NULL;
	pR-&gt;pVal = malloc (sizeof(float)*num);
	if (!pR-&gt;pVal) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = num;
	// set memory
	for (i = 0; i&lt; num; i++) {
		pR-&gt;pVal[i] = 0.f;
	}
	return pR;
}

// destroy float vector
void APgenericRationalVector_destroy (TAPgenericRationalVector * pV) {
	if (pV) {
		free(pV-&gt;pVal);
		free(pV);
	}
}

// resize float vector
int APgenericRationalVector_resize (TAPgenericRationalVector * pV, int newNum) {
	int i;

	if (pV-&gt;num == newNum) return 0;
	free (pV-&gt;pVal);
	pV-&gt;pVal = malloc (sizeof(float)*newNum);
	if (!pV-&gt;pVal) return -1;
	pV-&gt;num = newNum;
	// set memory
	for (i = 0; i&lt; newNum; i++) {
		pV-&gt;pVal[i] = 0.f;
	}
	return 0;
}

// assign a = values
int APgenericRationalVector_assignConst (TAPgenericRationalVector * pa, int iStart, int num, float * pVals) {
	int i = iStart;
	int imax = i + num;
	float * pD = pa-&gt;pVal + iStart;
	if (imax &gt; pa-&gt;num) imax = pa-&gt;num;

	for (; i &lt; imax; i++) {
		*pD = *pVals;
		pD++;
		pVals++;
	}
	return 0;
}

// assign a = b
int APgenericRationalVector_assign (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb) {
	int imax = pa-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pa-&gt;pVal[i] = pb-&gt;pVal[i];
	}
	return 0;
}


// add c = a + b
int APgenericRationalVector_add (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] + pb-&gt;pVal[i];
	}
	return 0;
}

// sub c = a - b
int APgenericRationalVector_sub (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] - pb-&gt;pVal[i];
	}
	return 0;
}

// mul c = a * b
int APgenericRationalVector_mul (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] * pb-&gt;pVal[i];
	}
	return 0;
}

// div c = a * b
int APgenericRationalVector_div (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = pa-&gt;pVal[i] / pb-&gt;pVal[i];
	}
	return 0;
}

// modulo c = a mod b
int APgenericRationalVector_mod (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, TAPgenericRationalVector * pc) {
	int imax = pc-&gt;num;
	int i;
	for (i = 0; i &lt; imax; i++) {
		pc-&gt;pVal[i] = fmodf(pa-&gt;pVal[i],pb-&gt;pVal[i]);
	}
	return 0;
}

// cmp Element cmp(a[i],b[j]):
//		res = -1: a &lt; b
//		res = 1 : a &gt; b
//		res = 0: a = b
int APgenericRationalVector_cmpEle (TAPgenericRationalVector * pa, TAPgenericRationalVector * pb, int ia, int ib) {
	float zwv = pa-&gt;pVal[ia] - pb-&gt;pVal[ib];
	if (zwv == 0.f) return 0;
	if (zwv &lt; 0.f) return -1;
	return 1;
}</Code><Code idCode="2">// ===============================
// function implementation for assignRational(var id = 10)
// description: a = b
// ===============================

void HALfunc_ID10_assignRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: the source
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="3">// ===============================
// function implementation for addRational(var id = 11)
// description: c = a + b
// ===============================

void HALfunc_ID11_addRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="4">// ===============================
// function implementation for subRational(var id = 12)
// description: c = a - b
// ===============================

void HALfunc_ID12_subRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="5">// ===============================
// function implementation for mulRational(var id = 13)
// description: c = a * b
// ===============================

void HALfunc_ID13_mulRational(void * pIPcpu, uAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="6">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// transmit the data
void HALimpl_1_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_1_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_1_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_1_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_1_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="7">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// transmit the data
void HALimpl_2_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_2_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_2_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_2_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="8">// ===============================
// variable implementation for a integer number(var id = 3)
// ===============================

// transmit the data
void HALimpl_3_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_3_create (void * pMMU) {
return NULL;
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_3_delete (void * pVar, void *pMMU) {

}
</Code><Code idCode="9"></Code><Code idCode="10">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_1 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_1 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_1 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_1(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_1(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_1(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_1(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_1(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_1(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="11">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_2 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_2 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_2 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_2(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_2(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_2(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_2(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_2(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_2(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="12">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// create a mmu
TAPMMU AP_MMU_create (size_t poolSize) {

}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {

}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t amountInBytes) {

}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {

}
</Code><Code idCode="13">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// create a mmu
TAPMMU AP_MMU_create (size_t poolSize) {

}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {

}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t amountInBytes) {

}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {

}

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {
	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}

</Code><Code idCode="14">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="15">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="16">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="17">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="18">// ===============================
// AP uuid = 1
// ===============================

</Code><Code idCode="19"></Code><Code idCode="20">// ===============================
// AP uuid = 1
// ===============================



@

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	@
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	@
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

	@	
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
@
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
@MMUUnLock
	return pM;
error:
@MMUUnLock
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;
@
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
@MMUUnLock
}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="21">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="22">// ===============================
// AP uuid = 1
// ===============================




// the mutex type
typedef void * TAPMutex;

// create an AP mutex
TAPMutex APMutexCreate () {
	return NULL;
}

// delete mutex
void APMutexDelete (TAPMutex mtx) {

}

inline void APMutexLock (TAPMutex mtx) {

}

inline void APMutexUnlock (TAPMutex mtx) {

}



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber, 
			size_t				progammPoolSize,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(progammPoolSize);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
		TAPMutex mtx;
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
		pMMU-&gt;mtx = APMutexCreate();
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		APMutexDelete(pMMU-&gt;mtx);	
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return pM;
error:
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	APMutexUnlock(pMMU-&gt;MMUmutext);
}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

@ReplacedWithRealInterpreterType

// create a new interpreter
TAPInterpreter APInterpreterCreate (size_t maxProgrammAndVariableSize) {

	return NULL;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {

}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="23">// ===============================
// variable implementation for a integer number(var id = 3)
// ===============================

// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len - iStart;

	for (i = 0;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}

// transmit the data
void HALimpl_3_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVar, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_3_create () {
return NULL;
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVar) {
return NULL;
}
// delete the variable
void HALimpl_3_delete (void * pVar) {

}
</Code><Code idCode="24">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================
// stdint.h
// transmit the data
void HALimpl_2_init (void * pVar, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVar, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVar, int * pframeSize) {
	return sizeof(int32_t);
}
// end init process
void HALimpl_2_initEnd (void * pVar) {

}
// create a new variable
void * HALimpl_2_create () {
	int * pI = malloc(sizeof(int32_t));
	*pI = 0;
	return pI;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVar, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVar) {
	return pVar;
}
// delete the variable
void HALimpl_2_delete (void * pVar) {
	free ((int32_t *)pVar);
}
</Code><Code idCode="25">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// transmit the data
void HALimpl_1_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_1_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_1_create () {
	float * pF = (float *) malloc (sizeof(float));
	if (pF) *pF = 0.0f;
	return pF;
}
// fill the frame with data
void HALimpl_1_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="26">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory pM) {
	TAPrealMMU * pMMU = mmu;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory pM) {
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="27">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPrealMMUMemory * AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
inline void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="28">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU))
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter))
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="29">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) free (pIP-&gt;code);
	
	// clean variables
	
	if (pIP-&gt;variables) free (pIP-&gt;variables);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
@IPlock

@IPunlock
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	return -1;
}
</Code><Code idCode="30">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free pIP;	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="31">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free pIP;	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="32">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="33">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="34">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int							instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int							variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int instructionsNumber, int globalVariableNumber, int localVariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (globalVariableNumber+localVariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}
</Code><Code idCode="35">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = globalVariableNumber+localVariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int32_t index, int32_t varTypeID)
{

}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP, int32_t i, int32_t * pRawInstr)
{

}


</Code><Code idCode="36">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP,int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int32_t index, int32_t varTypeID)
{

}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP, int32_t i, int32_t * pRawInstr)
{

}


</Code><Code idCode="37">// ===============================
// function implementation for assignRational(var id = 10)
// description: a = b
// ===============================

void HALfunc_ID10_assignRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: the source
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="38">// ===============================
// function implementation for addRational(var id = 11)
// description: c = a + b
// ===============================

void HALfunc_ID11_addRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="39">// ===============================
// function implementation for subRational(var id = 12)
// description: c = a - b
// ===============================

void HALfunc_ID12_subRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="40">// ===============================
// function implementation for mulRational(var id = 13)
// description: c = a * b
// ===============================

void HALfunc_ID13_mulRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter c descr: destination of the operation
	void ** pc = &amp;( pParams[0].fp_pD);
// parameter a descr: left side number
	void ** pa = &amp;( pParams[1].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[2].fp_pD);
};
</Code><Code idCode="41">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="42">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pIP-&gt;sysEndian = eAP_littleEndian;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="43">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the runtime of a variable
typedef struct SAPruntimeVariable {
	const THAL_Variable *	pIV;	// interface of the variable
	void *					pVD;	// Data of the variable
} TAPruntimeVariable; 

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPruntimeVariable *		variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPruntimeVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		pV-&gt;pIV-&gt;pFkt_delete(pV-&gt;pVD);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPruntimeVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	TAPruntimeVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pVD = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pVD) return -3;

	pRTV-&gt;pIV = pV;;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="44">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{

}

</Code><Code idCode="45">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int32_t						state;					// state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;state = state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP&gt;sysEndian) {
		APendianConversation32Bit(-&gt;amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="46">// ===============================
// AP uuid = 1
// ===============================




// the mutex type
typedef void * TAPMutex;

// create an AP mutex
TAPMutex APMutexCreate () {
	return NULL;
}

// delete mutex
void APMutexDelete (TAPMutex mtx) {

}

inline void APMutexLock (TAPMutex mtx) {

}

inline void APMutexUnlock (TAPMutex mtx) {

}



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	TAPMutex		mtx;
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
		pMMU-&gt;mtx = APMutexCreate();
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		APMutexDelete(pMMU-&gt;mtx);	
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	APMutexLock(pMMU-&gt;MMUmutext);
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return pM;
error:
	APMutexUnlock(pMMU-&gt;MMUmutext);
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	APMutexLock(pMMU-&gt;MMUmutext);
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	APMutexUnlock(pMMU-&gt;MMUmutext);
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="47">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate();
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	return 0;
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate () {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = eAP_littleEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="48">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (TAP * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = pAP-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="49">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			void *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = pAP-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

</Code><Code idCode="50">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem pMS = (TAPrealMsgSystem) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pSM-&gt;pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pSM-&gt;pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem *						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="51">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem *						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="52">// ===============================
// driver uuid =3
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_3 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_3 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_3 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_3(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_3(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_3(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_3(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_3(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_3(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="53">// ===============================
// driver uuid =4
// ===============================

//open an existing driver and bind it to the AP
int drvOpen_4 (void * pAP, struct SAPMsgDrv *pDrv){
	return 0;
}
//close the driver
int drvClose_4 (struct SAPMsgDrv *pDrv){
	return 0;
}
//destroys the driver
int drvDestroy_4 (struct SAPMsgDrv *pDrv){
	return 0;
}
// acknowledge
int drvACK_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// not acknowledge
int drvNACK_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// start sending a program
int drvstartPrg_4(void *pDrvData, uint32_t receiver, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber){
	return 0;
}
// sends a variable
int drvsendVariable_4(void *pDrvData, uint32_t receiver, int32_t * data){
	return 0;
}
// sends an instruction
int drvsendInstruction_4(void *pDrvData, uint32_t receiver, int32_t functionID, int32_t * parameter){
	return 0;
}
// sings that the program transmission has completed
int drvendPrg_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// stops the AP
int drvstop_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP executes one instruction
int drvstep_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// the AP runs the program
int drvrun_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// a variable going to be updated
int drvupdateVariable_4(void *pDrvData, uint32_t receiver, int32_t ctID, int32_t * data){
	return 0;
}
// a AP is going to be logged in to the system
int drvlogin_4(void *pDrvData, uint32_t receiver){
	return 0;
}
// a AP is going to be logged out of the system
int drvlogout_4(void *pDrvData, uint32_t receiver){
	return 0;
}
</Code><Code idCode="54">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	if((!pAP-&gt;msgSysMMU)||(!pAP-&gt;IP)) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="55">// ===============================
// AP uuid = 1
// ===============================





// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	APInterpreterDelete(pAP-&gt;IP);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes
	
} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;
	
	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;
	
	
	
	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;
	
	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);

		
}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;
	
	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	
	return pM;
error:
	
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;
	
	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
	
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code 
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;
	
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;	
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;	
	
	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;
	
	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;
	
	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	
	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;
	
	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);	
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);
	
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}
	
	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;
	
	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;
	
	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received
	
	
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;
	
	
	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	
	
	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	
	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;
	

	
}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list
	
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
	
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}
	
	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;
	
	mc = pMS-&gt;messagecounter;
	
	while (mc == pMS-&gt;messagecounter) {
		
	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS; 
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}
</Code><Code idCode="56">// ===============================
// function implementation for jump(var id = 50)
// description: jumps n instructions
// ===============================

void HALfunc_ID50_jump(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter number descr: amount of instructions to jump
//	int32_t* pnumber = &amp;( pParams[0].fp_integer);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
};
</Code><Code idCode="57"></Code><Code idCode="58">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}

	pIP-&gt;code = malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (pMsgIDandFunctAsso-&gt;msgID == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="59">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = mmu;
	TAPrealMMUMemory * pM = memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;instructionsNumber);
		APendianConversation32Bit(&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
		APendianConversation32Bit(&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit(&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg (pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (pMsgIDandFunctAsso-&gt;msgID == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="60">// ===============================
// AP uuid = 1
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="61">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="62">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="63">// ===============================
// variable implementation for a biqaud filter(var id = 10)
// ===============================

typedef struct SAPBiquadDF2 {
	float	k;
	float	a1;
	float	a2;
	float	b1;
	float	b2;
	float	s1;
	float	s2;
} TAPBiquadDF2;

// transmit the data
void HALimpl_10_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_10_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_10_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_10_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_10_create () {
	TAPBiquadDF2 * pBQ = malloc(sizeof(TAPBiquadDF2));
	if (!pBQ) return NULL;
	pBQ-&gt;k =0.0;
	pBQ-&gt;a1 =0.0;
	pBQ-&gt;a2 =0.0;
	pBQ-&gt;b1 =0.0;
	pBQ-&gt;b2 =0.0;
	pBQ-&gt;s1 = 0.0;
	pBQ-&gt;s2 = 0.0;
	return pBQ;
}
// fill the frame with data
void HALimpl_10_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="64">// ===============================
// startup code for the audio processor abc
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="65">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="66">// ==============================
// descr: some helpers for the lib-snd-file group
// author: Stefan Jaritz
//
// the lib is the &quot;libsndfile-1&quot;
// ==============================

typedef struct SStjWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input
	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)
	unsigned int	sampleAmountCacheSize;	//!&lt; amount of samples cached before writing or/ at reading
} TStjWAVOpenInfo;

typedef struct SStjWAVFile {
	unsigned int	channel;			//!&lt; the channel
	SNDFILE *		pSndF;				//!&lt; the file
	unsigned int	isInput;			//!&lt; if &lt;&gt; 0 the channel is an input channel
	unsigned int	channelsAmount; 	//!&lt; the amount of channels
	unsigned int	sampleAmount;		//!&lt; the amount of samples at the cache
	unsigned int	maxSampleAmount;	//!&lt; the maximum sample amount
	unsigned int	dataOffset;			//!&lt; the offset of the channel at the sample cache
	float *			pCache;				//!&lt; the sample cache
	float *			pD;					//!&lt; pointer to the data
} TStjWAVFile;


typedef struct SStjWAVmodule {
	TStjWAVFile *	pChannels;
	unsigned int	number;
} TStjWAVmodule;

// fill the wav sample cache
int WAVmoduleFillCache (TStjWAVFile * pWF) {
	sf_count_t amount = (sf_count_t) pWF-&gt;maxSampleAmount;
	// read a data frame(s)
	amount = sf_readf_float (pWF-&gt;pSndF,pWF-&gt;pCache, amount);
	if (amount &lt; 1) return -1;
	// reset data pointers and indexes
	pWF-&gt;pD = pWF-&gt;pCache;
	pWF-&gt;sampleAmount = (unsigned int) amount;
	return 0;
}

// flushes the wav sample cache to disk
int WAVmoduleFlushCache (TStjWAVFile * pWF) {
	if (!pWF-&gt;sampleAmount) return 0;
	sf_count_t amount = (sf_count_t) pWF-&gt;sampleAmount;
	if (amount != sf_write_float (pWF-&gt;pSndF,pWF-&gt;pCache , amount)) return -1;
	pWF-&gt;pD = pWF-&gt;pCache;
	pWF-&gt;sampleAmount = 0;
	return 0;
}


//! close the set of wav files
void WAVmoduleExit (TStjWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		// if it is an output flush the samples to disk
		if (!pWF-&gt;isInput) {
			WAVmoduleFlushCache(pWF);
		}
		sf_close(pWF-&gt;pSndF);
		if (pWF-&gt;pCache) {
			free (pWF-&gt;pCache);
		}
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int WAVmoduleInit (
		int 				number,		//!&lt;(in) amount of files
		TStjWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjWAVmodule *		pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjWAVFile) * number);
	pModul-&gt;number = number;

	int 			i;
	SF_INFO 		info;
	TStjWAVFile * 	pWF = pModul-&gt;pChannels;
	size_t			cacheSize;

	for (i = 0;i &lt; number;i++) {
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info) ;
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info) ;
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;
		pWF-&gt;channelsAmount = (unsigned int) info.channels;
		pWF-&gt;dataOffset = (unsigned int) pWAVFiles[i].fileChannelNumber;
		pWF-&gt;maxSampleAmount = (unsigned int) pWAVFiles[i].sampleAmountCacheSize;
		cacheSize =  pWF-&gt;channelsAmount * pWF-&gt;maxSampleAmount * sizeof(float);
		pWF-&gt;pCache = malloc (cacheSize);
		if (!pWF-&gt;pCache) goto error;
		memset (pWF-&gt;pCache,0,cacheSize);
		pWF-&gt;sampleAmount = 0;
		// now fill the cache with data
		if (pWF-&gt;isInput) {
			if (WAVmoduleFillCache(pWF)) goto error;
		} else {
			pWF-&gt;pD = pWF-&gt;pCache;
		}
		pWF++;
	}
	return 0;
error:
	WAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjWAVFile * WAVmoduleFindChannel (
		TStjWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
		) {
	TStjWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int WAVmoduleGetInput (
		TStjWAVmodule *	pM,			//!&lt;(in) the module
		int				channel,	//!&lt;(in) the channel
		float *			pSample		//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjWAVFile * pWF = WAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}
	// if the cache is empty then fill it
	if (!pWF-&gt;sampleAmount) {
		if (WAVmoduleFillCache(pWF)) return -3;
	}
	// copy sample
	*pSample = pWF-&gt;pD[pWF-&gt;dataOffset];
	pWF-&gt;pD += pWF-&gt;channelsAmount;
	// now there is one sample less at the buffer
	pWF-&gt;sampleAmount--;
	return 0;
}

//! writes a sample to an output
int WAVmoduleSetOutput (
		TStjWAVmodule *	pM,			//!&lt;(in) the module
		int				channel,	//!&lt;(in) the channel
		float 			sample		//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjWAVFile * pWF = WAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// if the cache is full then flush it
	if (pWF-&gt;sampleAmount == pWF-&gt;maxSampleAmount) {
		if (WAVmoduleFlushCache(pWF)) return -3;
	}
	// now store the value
	pWF-&gt;pD[pWF-&gt;dataOffset] = sample;
	pWF-&gt;pD += pWF-&gt;channelsAmount;
	pWF-&gt;sampleAmount++;
	return 0;
}</Code><Code idCode="67">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter resValue descr: the result of the action
	float ** presValue = &amp;( pParams[1].fp_pD);

	WAVmoduleGetInput ();
};
</Code><Code idCode="68">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="69">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	void ** pchannel = &amp;( pParams[0].fp_pD);
// parameter resValue descr: the result of the action
	void ** presValue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="70">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	void ** pchannel = &amp;( pParams[0].fp_pD);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="71">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="72">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="73">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);


	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;
/*
	int res = loadALCfromFile (&quot;../APgen/ALASM/test.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
*/

	free (varL);
	free (instrL);

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="74">// ===============================
// startup code for the audio processor
// ===============================
/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc (sizeof(int32_t)*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main() {
	TAP AP;

	APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	int res = loadALCfromFile (&quot;../APgen/ALASM/bypass.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (res) return EXIT_FAILURE;

	res = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="75">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}



typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="76">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsg (
		TAPrealMsgSystem *	pMS,
		TAPMessageID		msgID,	// if 0 all messages are allowed
		TAPNodeID			sender	// if 0 all senders are allowed
	) {
	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok)) {
			res = pM;
			goto exit;
		}
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}

	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="77">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APcreateMsgSystem (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APdeleteMsgSystem (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;


	free (pMS);
}

// get memory for a new message
TAPMsg * APgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APgetMsgMsgSystem (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APwaitForNewMessage(pMS);
		// get the message
		pM = APgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="78">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APcreateMsgSystem (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APdeleteMsgSystem (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="79">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="80">// ===============================
// AP uuid = 1
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new programm
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a single Variable to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create();
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="81">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// int32_t* pchannel =  pParams[0].fp_integer;
// parameter resValue descr: the result of the action
	// int32_t* pSample =  pParams[1].fp_pD;
	
	// foreward declaration of the global variable
	extern TStjWAVmodule gWAVModule;

	if (WAVmoduleGetInput(&amp;gWAVModule,pParams[0].fp_integer,((TAPvarRational *)pParams[1].fp_pD)-&gt;pR)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="82">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
//	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
//	void ** pvalue = &amp;( pParams[1].fp_pD);

	// foreward declaration of the global variable
	extern TStjWAVmodule gWAVModule;
	if (WAVmoduleSetOutput(&amp;gWAVModule,pParams[0].fp_integer,*((TAPvarRational *)pParams[1].fp_pD)-&gt;pR)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="83">// ===============================
// function implementation for assignConstInteger(var id = 25)
// description: a = const b
// ===============================

void HALfunc_ID25_assignConstInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: the destination
//	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: constant integer
//	int32_t* pb = &amp;( pParams[1].fp_integer);
	*((int32_t*) pParams[0].fp_pD) = pParams[1].fp_integer;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="84">// ===============================
// AP uuid = 2
// ===============================

#define WAVsampleCache (20000000)

// the wav modul global var
TStjWAVmodule gWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	// init wav module
	TStjWAVOpenInfo wavIOs[] = {
			{1,&quot;input.wav&quot;,1,44100,0,WAVsampleCache},
			{2,&quot;bypass.wav&quot;,0,44100,0,WAVsampleCache},
			{3,&quot;subbass.wav&quot;,0,44100,0,WAVsampleCache},
			{4,&quot;lowerVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{5,&quot;upperVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{6,&quot;harmonics.wav&quot;,0,44100,0,WAVsampleCache},
	};

	if (WAVmoduleInit (sizeof(wavIOs) / sizeof(TStjWAVOpenInfo),wavIOs,&amp;gWAVModule)) {
		return -2;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close wav module
	WAVmoduleExit(&amp;gWAVModule);

	// close the AP
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="85">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="86">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// the internal integer type
typedef struct SAPvarInteger {
	unsigned int		num;
	int * 			pI;
}  TAPvarInteger;

// transmit the data
void HALimpl_2_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_2_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_2_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	*pframeSize = pI-&gt;num * sizeof(int32_t);
	return 1;
}
// end init process
void HALimpl_2_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_2_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarInteger * pI;
	pI = malloc(sizeof(TAPvarInteger));
	if (!pI) return NULL;

	pI-&gt;pI = malloc(sizeof(int32_t)*numberOfElements);
	if (!(pI-&gt;pI)) {
		free (pI);
		return NULL;
	}
	pI-&gt;num = numberOfElements;

	memset (pI-&gt;pI,0,sizeof(int32_t)*numberOfElements);
	return pI;
}
// fill the frame with data
void HALimpl_2_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVarData) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	return pI-&gt;pI;
}
// delete the variable
void HALimpl_2_delete (void * pVarData) {
	TAPvarInteger * pI = (TAPvarInteger *) pVarData;
	if (pI) {
		if (pI-&gt;pI) free (pI-&gt;pI);
		free (pI);
	}
}</Code><Code idCode="87">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// the internal rational type
typedef struct SAPvarRational {
	unsigned int		num;
	float * 			pR;
}  TAPvarRational;


// transmit the data
void HALimpl_1_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_1_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_1_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	*pframeSize = pR-&gt;num * sizeof(float);
	return 1;
}
// end init process
void HALimpl_1_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarRational * pR;
	pR = malloc(sizeof(TAPvarRational));
	if (!pR) return NULL;

	pR-&gt;pR = malloc(sizeof(float)*numberOfElements);
	if (!(pR-&gt;pR)) {
		free (pR);
		return NULL;
	}
	pR-&gt;num = numberOfElements;

	memset (pR-&gt;pR,0,sizeof(float)*numberOfElements);
	return pR;

}
// fill the frame with data
void HALimpl_1_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	return pR;
}

// delete the variable
void HALimpl_1_delete (void * pVarData) {
	TAPvarRational * pR = (TAPvarRational *) pVarData;
	if (pR) {
		if (pR-&gt;pR) free (pR-&gt;pR);
		free (pR);
	}
}</Code><Code idCode="88">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

typedef struct SAPBiquadDF2 {
	float	k;	// gain
	float	n1;	// nominator
	float	n2;
	float	d1; // denominator
	float	d2;
	float	s1; // delays
	float	s2;
} TAPBiquadDF2;

typedef struct SAPvarBiquad {
	unsigned int		num;
	TAPBiquadDF2 *	pB;	
} TAPvarBiquad;


// transmit the data
void HALimpl_10_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_10_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_10_frameGetNumber (void * pVarData, int * pframeSize) {
	return 0;
}
// end init process
void HALimpl_10_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_10_create (unsigned int numberOfElements) {
	TAPvarBiquad * pB = malloc (sizeof(TAPvarBiquad));
	if (!pB) return NULL;
	pB-&gt;pB = malloc(sizeof(TAPBiquadDF2)*numberOfElements);
	if (!pB-&gt;pB) {
		free (pB);
		return NULL;
	}
	pB-&gt;num = numberOfElements;
	int i;
	for (i = 0; i &lt; numberOfElements; i++) {
		pB-&gt;pB[i].k = 0.0;
		pB-&gt;pB[i].n1 = 0.0;
		pB-&gt;pB[i].n2 = 0.0;
		pB-&gt;pB[i].d1 = 0.0;
		pB-&gt;pB[i].d2 = 0.0;
		pB-&gt;pB[i].s1 = 0.0;
		pB-&gt;pB[i].s2 = 0.0;
	}
	return pB;
}
// fill the frame with data
void HALimpl_10_frameFill (void * pVarData, int frameNumber, void * pFrame) {
}

// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	TAPvarBiquad * pB = (TAPvarBiquad *) pVarData;
	return pB;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	TAPvarBiquad * pB = (TAPvarBiquad *) pVarData;
	if (pB) {
		if (pB-&gt;pB) {
			free (pB-&gt;pB);
		}
		free (pB);
	}
}
</Code><Code idCode="89">// ===============================
// variable implementation for a delay(var id = 20)
// ===============================

// map delay functions to the rational functions
#define HALimpl_20_init HALimpl_1_init


// transmit the data
void  (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_20_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_20_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_20_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_20_create (unsigned int numberOfElements) {
return NULL;
}
// fill the frame with data
void HALimpl_20_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_20_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_20_delete (void * pVarData) {

}</Code><Code idCode="90">// ===============================
// variable implementation for a delay(var id = 20)
// ===============================

// map delay to the rational datatype

#define HALimpl_20_create HALimpl_1_create
#define HALimpl_20_delete HALimpl_1_delete

#define HALimpl_20_initStart HALimpl_1_initStart
#define HALimpl_20_init HALimpl_1_init
#define HALimpl_20_initEnd HALimpl_1_initEnd

#define HALimpl_20_frameGetNumber HALimpl_1_frameGetNumber
#define HALimpl_20_frameFill HALimpl_1_frameFill

#define HALimpl_20_decodeData HALimpl_1_decodeData</Code><Code idCode="91">// ===============================
// AP uuid = 3
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="92">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
};
</Code><Code idCode="93">// ===============================
// function implementation for initBiquadAsLP(var id = 101)
// description: inits a biquad filter as a low pass filter
// ===============================

void HALfunc_ID101_initBiquadAsLP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter i descr: index at the biquad array
	int32_t i = pParams[0].fp_integer;
	// parameter fs descr: sample frequency
	float fs = pParams[1].fp_rational;
	// parameter fc descr: cut off frequency
	float fc = pParams[2].fp_rational;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[3].fp_pV-&gt;pData;

	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=k2/dn;
	float n1=2*k2/dn;
	float n2=k2/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;
		
	pBQA-&gt;pB[i].n1 = n1 / n0;
	pBQA-&gt;pB[i].n2 = n2 / n0;
	pBQA-&gt;pB[i].d1 = d1 / d0;
	pBQA-&gt;pB[i].d2 = d2 / d0;
	pBQA-&gt;pB[i].k = n0 / d0;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="94">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================

void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float * px = (float *) pParams[0].fp_pD;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	float x = *px;
	float y;
	int i;
	float d1;
	TAPBiquadDF2 * pF = pBQA-&gt;pB;

	for (i = 0; i &lt; pBQA-&gt;num; i++) {
		// filter
		d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + x);
		y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
		y *= pF-&gt;k;

		pF-&gt;s2 = pF-&gt;s1;
		pF-&gt;s1 = d1;
		// output is input for the next filter
		x = y;
		pF++;
	}

	// save result to the output
	*py = y;
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};</Code><Code idCode="95">// ===============================
// function implementation for shiftDelay(var id = 150)
// description: shifts the content of the delay
// ===============================

void HALfunc_ID150_shiftDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float * px = (float *) pParams[0].fp_pD;
	// parameter delay descr: the delay
	TAPvarRational * pDelay = (TAPvarRational *) pParams[1].fp_pD;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// save oldest value
	int imax = pDelay-&gt;num-1;

	*py = pDelay-&gt;pR[imax];

	// shift value (we copy only num -1 values with the offset of 1)
	memcpy (pDelay-&gt;pR+1,pDelay-&gt;pR,imax);

	// save the input
	*pDelay-&gt;pR = *px;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="96">// ===============================
// function implementation for shiftDelay(var id = 150)
// description: shifts the content of the delay
// ===============================

void HALfunc_ID150_shiftDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter x descr: input
	float x = *((float *) pParams[0].fp_pD);
	// parameter delay descr: the delay
	TAPvarRational * pDelay = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// save oldest value
	int imax = pDelay-&gt;num-1;

	*py = pDelay-&gt;pR[imax];

	// shift value (we copy only num -1 values with the offset of 1)
	memcpy (pDelay-&gt;pR+1,pDelay-&gt;pR,imax*sizeof(float));

	// save the input
	*pDelay-&gt;pR = x;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="97">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter i descr: index at the biquad array
	int32_t i = pParams[0].fp_integer;
	// parameter fs descr: sample frequency
	float fs = pParams[1].fp_rational;
	// parameter fc descr: cut off frequency
	float fc = pParams[2].fp_rational;
	// parameter bqa descr: biquad array
	TAPvarBiquad * pBQA = (TAPvarBiquad *) pParams[3].fp_pV-&gt;pData;

	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=1/dn;
	float n1=-2/dn;
	float n2=1/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;

	pBQA-&gt;pB[i].n1 = n1 / n0;
	pBQA-&gt;pB[i].n2 = n2 / n0;
	pBQA-&gt;pB[i].d1 = d1 / d0;
	pBQA-&gt;pB[i].d2 = d2 / d0;
	pBQA-&gt;pB[i].k = n0 / d0;

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="98">//  ==================================
// fftw3 libis used for complex and fft &amp; ifft functions
//  ==================================</Code><Code idCode="99">// ===============================
// variable implementation for a complex number(var id = 4)
// ===============================

// the type for the complex data struct
typedef struct SAPvarComplex {
	fftwf_complex *	pC;
	int				num;
} TAPvarComplex;

// transmit the data
void HALimpl_4_init (void * pVarData, int frameNumber, void * pData) {

}

// start the init process
void HALimpl_4_initStart (void * pVarData, int frameNumber, int bigEndian) {

}

// get the frame Number and size
int HALimpl_4_frameGetNumber (void * pVarData, int * pframeSize) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	*pframeSize = pC-&gt;num * sizeof(fftwf_complex);
	return 1;
}

// end init process
void HALimpl_4_initEnd (void * pVarData) {

}

// create a new variable
void * HALimpl_4_create (unsigned int numberOfElements) {
	if (!numberOfElements) return NULL;

	TAPvarComplex * pC;
	pC = malloc(sizeof(TAPvarComplex));
	if (!pC) return NULL;

	pC-&gt;pC = fftwf_malloc(sizeof(fftwf_complex)*numberOfElements);
	if (!(pC-&gt;pC)) {
		free (pC);
		return NULL;
	}
	pC-&gt;num = numberOfElements;

	memset (pC-&gt;pC,0,sizeof(fftwf_complex)*numberOfElements);
	return pC;
}

// fill the frame with data
void HALimpl_4_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}

// decode data for the HAL functions
void * HALimpl_4_decodeData (void * pVarData) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	return pC-&gt;pC;
}

// delete the variable
void HALimpl_4_delete (void * pVarData) {
	TAPvarComplex * pC = (TAPvarComplex *) pVarData;
	if (pC) {
		if (pC-&gt;pC) fftwf_free(pC-&gt;pC);
		free (pC);
	}
}</Code><Code idCode="100">// ===============================
// variable implementation for FFT or IFFT sturcture(var id = 30)
// ===============================

// transmit the data
void HALimpl_30_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_30_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_30_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_30_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_30_create (unsigned int numberOfElements) {
	return NULL;
}
// fill the frame with data
void HALimpl_30_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_30_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_30_delete (void * pVarData) {
	if (pVarData) {
		fftwf_destroy_plan(pVarData);
	}
}
</Code><Code idCode="101">// ============================================================
// descr: some helpers for the lib-snd-file group
// author: Stefan Jaritz
//
// the lib is the &quot;libsndfile-1&quot;
// ============================================================

// defines

typedef struct SStjFrameOverlappedWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input

	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)

	unsigned int	frameSize;				//!&lt; number of samples per frame
	unsigned int	overlappingNumber;		//!&lt; the number of samples kept in the frame at reading/writing
} TStjFrameOverlappedWAVOpenInfo;

typedef struct SStjFrameOverlappedWAVFile {
	unsigned int	channel;				//!&lt; the channel
	SNDFILE *		pSndF;					//!&lt; the file
	unsigned int	isInput;				//!&lt; if 0 the channel is an input channel

	float *			pRB;					//!&lt; the ring buffer storing/writing the samples
	unsigned int	rbFrameSize;			//!&lt; the size of the frames at the ring buffer
	unsigned int	FrameSize;				//!&lt; amount of samples at the frame
	unsigned int	nMax;					//!&lt; number of elements at the ring buffer
	unsigned int	n;						//!&lt; actual element (for inputs)/ the offset (output)
} TStjFrameOverlappedWAVFile;

typedef struct SStjFrameOverlappedWAVmodule {
	TStjFrameOverlappedWAVFile *	pChannels;
	unsigned int		number;
} TStjFrameOverlappedWAVmodule;

//! close the set of wav files
void FrameOverlappedWAVmoduleExit (TStjFrameOverlappedWAVmodule * pM);

//! initis a set of wav files for writing / reading
int FrameOverlappedWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameOverlappedWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameOverlappedWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	);

//! looking for the right channel
TStjFrameOverlappedWAVFile * FrameOverlappedWAVmoduleFindChannel (
		TStjFrameOverlappedWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
	);

//! reads a sample from a channel
int FrameOverlappedWAVmoduleGetInput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(out) pointer to the sample buffer witch is filled
	);

//! writes a sample to an output
int FrameOverlappedWAVmoduleSetOutput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(in) pointer to the sample buffer witch is filled
	);

// functions

//! close the set of wav files
void FrameOverlappedWAVmoduleExit (TStjFrameOverlappedWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjFrameOverlappedWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		sf_close(pWF-&gt;pSndF);
		free (pWF-&gt;pRB);
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int FrameOverlappedWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameOverlappedWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameOverlappedWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjFrameOverlappedWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjFrameOverlappedWAVFile) * number);
	pModul-&gt;number = number;

	int 				i;
	SF_INFO 			info;
	TStjFrameOverlappedWAVFile * 	pWF = pModul-&gt;pChannels;

	for (i = 0;i &lt; number;i++) {
		// open sndfile interface
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info) ;
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info) ;
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;

		// prepare buffers
		pWF-&gt;FrameSize = pWAVFiles[i].frameSize;
		if (pWAVFiles[i].frameSize % pWAVFiles[i].overlappingNumber) {
			goto error;
		}
		pWF-&gt;nMax = pWAVFiles[i].frameSize / pWAVFiles[i].overlappingNumber;
		pWF-&gt;rbFrameSize = pWAVFiles[i].overlappingNumber;
		// if it's an input we need a memory for the old frames witch are read before
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pRB = malloc(sizeof(float)*pWAVFiles[i].frameSize);
			if (!pWF-&gt;pRB){
				goto error;
			}
			memset(pWF-&gt;pRB,0,sizeof(float)*pWAVFiles[i].frameSize);
			pWF-&gt;n = 0;
		} else {
			pWF-&gt;pRB = NULL;
			// the n is used as offset
			pWF-&gt;n = pWAVFiles[i].frameSize - pWAVFiles[i].overlappingNumber;
		}
		pWF++;
	}
	return 0;
error:
	FrameOverlappedWAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjFrameOverlappedWAVFile * FrameOverlappedWAVmoduleFindChannel (
		TStjFrameOverlappedWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
		) {
	TStjFrameOverlappedWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int FrameOverlappedWAVmoduleGetInput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjFrameOverlappedWAVFile * pWF = FrameOverlappedWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}

	// check the offset at the ringbuffer
	if (pWF-&gt;n &gt;= pWF-&gt;nMax) pWF-&gt;n = 0;

	int offset;
	int idx = pWF-&gt;rbFrameSize * pWF-&gt;n;
	// fill the buffer

	sf_count_t am = sf_readf_float (pWF-&gt;pSndF,&amp;pWF-&gt;pRB[idx], (sf_count_t) pWF-&gt;rbFrameSize);

	if (am == 0) return -3;
	if (am != (sf_count_t) pWF-&gt;rbFrameSize) {
		offset = (sf_count_t) am;
		// calc the missing samples
		am = (sf_count_t) pWF-&gt;rbFrameSize - am;
		// set the buffer to 0
		memset(&amp;pWF-&gt;pRB[idx+offset],0,sizeof(float)*am);
	}
	// build the frame
	// on pos n is the newest frame
	// n+1 is oldest frame
	int nStart = pWF-&gt;n + 1;
	int amount;

	// copy all frames left from the newest block till the wrapping
	amount = pWF-&gt;nMax - nStart;
	if (amount) {
		memcpy(pFrame,&amp;pWF-&gt;pRB[nStart*pWF-&gt;rbFrameSize],sizeof(float)*amount*pWF-&gt;rbFrameSize);
	}
	nStart = amount;
	// wrap and copy the rest of it
	amount = pWF-&gt;nMax - amount;
	memcpy(&amp;pFrame[nStart*pWF-&gt;rbFrameSize],pWF-&gt;pRB,sizeof(float)*amount*pWF-&gt;rbFrameSize);
	// remember that we received a frame(with wrapping)
	pWF-&gt;n++;
	return 0;
}

//! writes a sample to an output
int FrameOverlappedWAVmoduleSetOutput (
		TStjFrameOverlappedWAVmodule *	pM,			//!&lt;(in) the module
		int						channel,	//!&lt;(in) the channel
		float *					pFrame		//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjFrameOverlappedWAVFile * pWF = FrameOverlappedWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// the last samples at the frame are new
	if (pWF-&gt;rbFrameSize != sf_write_float (pWF-&gt;pSndF,&amp;pFrame[pWF-&gt;n] , pWF-&gt;rbFrameSize)) return -3;

	return 0;
}

// ====================================================================
</Code><Code idCode="102">// ===============================
// AP uuid = 4
// ===============================

// the global var for the Frame WAV modul
TStjFrameWAVmodule gFrameWAVModule;


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// setup the wav modul

	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;input.wav&quot;,1,44100,1,1024,256},
			{2,&quot;output.wav&quot;,0,44100,1,1024,256}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	// closes the wav frame modul
	FrameWAVmoduleExit(&amp;gFrameWAVModule);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="103">// ===============================
// function implementation for initFFT(var id = 130)
// description: init FFT structure
// ===============================

void HALfunc_ID130_initFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  *(pParams[0].fp_integer);
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="104">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  *(pParams[0].fp_integer);
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="105">// ===============================
// function implementation for processFFT(var id = 132)
// description: processes the FFT
// ===============================

void HALfunc_ID132_processFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter fftStruct descr: the fft info structure
	TAPInterpreterVariable ** pfftStruct = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="106">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter ifftStruct descr: the ifft info structure
	TAPInterpreterVariable ** pifftStruct = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="107">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  pParams[0].fp_integer;
	// parameter x descr: input
	TAPvarRational * px = (TAPvarRational *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarComplex * py = (TAPvarComplex *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_r2c_1d(N, px-&gt;pR, py-&gt;pC, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="108">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan * pP = pParams[0].fp_pD;
	fftwf_execute(*pP);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="109">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N =  pParams[0].fp_integer;
	// parameter x descr: input
	TAPvarComplex * px = (TAPvarComplex *) pParams[1].fp_pV-&gt;pData;
	// parameter y descr: output
	TAPvarRational * py = (TAPvarRational *) pParams[2].fp_pV-&gt;pData;
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	*pP = fftwf_plan_dft_c2r_1d(N, px-&gt;pC, py-&gt;pR, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="110">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan * pP = pParams[0].fp_pD;
	fftwf_execute(*pP);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="111">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int 		sysEndian;
	int32_t		vc;
	int32_t		ic;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	int32_t	idField;
	int32_t endian;

	if (1 != fread (&amp;idField,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int32_t),1,f)) goto error;
	*pEndianness = (int) endian;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;

	// check the endianes
	vc = *pVarcount;
	ic = *pInstrCount;

	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(vc));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(ic));
	if (!*ppInstructions) goto error;

	if (vc != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),vc,f)) goto error;

	if (ic != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),ic,f)) goto error;

	fclose (f);
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;

	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit(&amp;vc);
		APendianConversation32Bit(&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;framebasedBypass.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) return EXIT_FAILURE;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);

	free (varL);
	free (instrL);

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);


#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="112">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer witch receives the samples
	TAPInterpreterVariable ** pframeBuffer = &amp;( pParams[1].fp_pV);

	extern TStjFrameWAVmodule gFrameWAVModule;
};


// parameter channel descr: the channel
	// int32_t* pchannel =  pParams[0].fp_integer;
// parameter resValue descr: the result of the action
	// int32_t* pSample =  pParams[1].fp_pD;
	
	// foreward declaration of the global variable


	if (WAVmoduleGetInput(&amp;gWAVModule,pParams[0].fp_integer,pParams[1].fp_pD)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}
	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;</Code><Code idCode="113">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	TAPInterpreterVariable ** pframeBuffer = &amp;( pParams[1].fp_pV);
};
</Code><Code idCode="114">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer witch receives the samples
error rational vartype
	float * pFrame = (float *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleGetInput(&amp;gFrameWAVModule,channel,pFrame)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="115">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
	// parameter frameBuffer descr: the buffer which is writen to the channel
error rational vartype
	float * pFrame = (float *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleSetOutput(&amp;gFrameWAVModule,channel,pFrame)){
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = 1;
	}	
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
}</Code><Code idCode="116">// ===============================
// variable implementation for FFT or IFFT sturcture(var id = 30)
// ===============================

// transmit the data
void HALimpl_30_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_30_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_30_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_30_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_30_create (unsigned int numberOfElements) {
	return NULL;
}
// fill the frame with data
void HALimpl_30_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_30_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_30_delete (void * pVarData) {
	if (pVarData) {
		fftwf_destroy_plan(pVarData);
	}
}
</Code><Code idCode="117">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	float * px = (float *) pParams[1].fp_pD;
	
	// parameter y descr: output
	fftwf_complex * py = (fftwf_complex *) pParams[2].fp_pD;
	
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	fftwf_plan P = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);
	*pP = P;

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="118">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	fftwf_complex * px = (fftwf_complex *) pParams[1].fp_pD;
	
	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;
	
	// parameter fftStruct descr: FFT structure
	fftwf_plan * pP = (fftwf_plan *) pParams[3].fp_pD;
	
	// create plan
	fftwf_plan P = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);
	*pP = P;

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};</Code><Code idCode="119">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	fftwf_plan P = (fftwf_plan)pParams[0].fp_pD;
	fftwf_execute(P);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="120">// ===============================
// function implementation for processIFFT(var id = 133)
// description: processes the IFFT
// ===============================

void HALfunc_ID133_processIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter fftStruct descr: the fft structure
	fftwf_execute(pParams[0].fp_pV-&gt;pData);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
}</Code><Code idCode="121">// ===============================
// function implementation for initRFFT(var id = 130)
// description: init FFT structure as real input FFT
// ===============================

void HALfunc_ID130_initRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;
	
	// parameter x descr: input
	float * px = (float *) pParams[1].fp_pD;
	
	// parameter y descr: output
	fftwf_complex * py = (fftwf_complex *) pParams[2].fp_pD;

	// parameter fftStruct descr: FFT structure
	TAPInterpreterVariable * pFFTVar = pParams[3].fp_pV;

	if (pFFTVar-&gt;pData) fftwf_destroy_plan(pFFTVar-&gt;pData);
	pFFTVar-&gt;pData = fftwf_plan_dft_r2c_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};


	
</Code><Code idCode="122">// ===============================
// function implementation for initIFFT(var id = 131)
// description: init inverse FFT structure
// ===============================

void HALfunc_ID131_initIFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter N descr: FFT length
	int32_t N = pParams[0].fp_integer;

	// parameter x descr: input
	fftwf_complex * px = (fftwf_complex *) pParams[1].fp_pD;

	// parameter y descr: output
	float * py = (float *) pParams[2].fp_pD;

	// parameter fftStruct descr: FFT structure
	TAPInterpreterVariable * pFFTVar = pParams[3].fp_pV;

	if (pFFTVar-&gt;pData) fftwf_destroy_plan(pFFTVar-&gt;pData);
	pFFTVar-&gt;pData = fftwf_plan_dft_c2r_1d(N, px, py, FFTW_ESTIMATE);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="123">// ===============================
// function implementation for processRFFT(var id = 132)
// description: processes the real input FFT
// ===============================

void HALfunc_ID132_processRFFT(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	// parameter fftStruct descr: the fft structure
	fftwf_execute(pParams[0].fp_pV-&gt;pData);

	// increment IP
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="124">// The following definition allows the SRU macro to check for errors. Once the routings have
// been verified, this definition can be removed to save some program memory space.
// The preprocessor will issue a warning stating this when using the SRU macro without this
// definition
#define SRUDEBUG  // Check SRU Routings for errors.
#include &lt;SRU.h&gt;


// =======================================================
// AD 1835 defines
// =======================================================

//
//  AD1835.h
//
//  Configuration values for the AD1835A codec
//

#define DACCTRL1   	(0x0000)  // DAC control register 1    (R/W)
#define DACCTRL2   	(0x1000)  // DAC control register 2    (R/W)
#define DACVOL_L1   (0x2000)  // DAC volume - left 1       (R/W)
#define DACVOL_R1   (0x3000)  // DAC volume - right 1      (R/W)
#define DACVOL_L2   (0x4000)  // DAC volume - left 2       (R/W)
#define DACVOL_R2   (0x5000)  // DAC volume - right 2      (R/W)
#define DACVOL_L3   (0x6000)  // DAC volume - left 3       (R/W)
#define DACVOL_R3   (0x7000)  // DAC volume - right 3      (R/W)
#define DACVOL_L4   (0x8000)  // DAC volume - left 4       (R/W)
#define DACVOL_R4   (0x9000)  // DAC volume - right 4      (R/W)
#define ADCPEAKL   	(0xA000)  // ADC left peak              (R)
#define ADCPEAKR   	(0xB000)  // ADC right peak             (R)
#define ADCCTRL1   	(0xC000)  // ADC control 1             (R/W)
#define ADCCTRL2   	(0xD000)  // ADC control 2             (R/W)
#define ADCCTRL3   	(0xE000)  // ADC control 3             (R/W)

#define RD         	(0x0800)
#define WR         	(0x0000)  // Write to register


// DAC control register 1
#define DEEMPH44_1 	(0x0100)  // Deemphasis filter for 44.1 KHz
#define DEEMPH32   	(0x0200)  // Deemphasis filter for 32.0 KHz
#define DEEMPH48   	(0x0300)  // Deemphasis filter for 48.0 KHz

#define DACI2S     	(0x0000)  // DAC receives I2S format
#define DACRJ      	(0x0020)  // DAC receives I2S format
#define DACDSP     	(0x0040)  // DAC receives I2S format
#define DACLJ      	(0x0060)  // DAC receives I2S format
#define DACPACK256 	(0x0080)  // DAC receives I2S format

#define DAC24BIT   	(0x0000)  // 24-bit output word length
#define DAC20BIT   	(0x0008)  // 20-bit output word length
#define DAC16BIT   	(0x0010)  // 16-bit output word length

#define DACPOWERDN 	(0x0004)  // DAC into power-down mode

#define DACFS48    	(0x0000)  // Sample rate = 48 KHz (x8)
#define DACFS96    	(0x0001)  // Sample rate = 96 KHz (x4)
#define DACFS192   	(0x0002)  // Sample rate = 192 KHz (x2)


// DAC control register 2

#define DACREPLICATE  (0x0100)  // Replicate output of DAC 1/2 on 3/4, 5/6 &amp; 7/8
#define DACMUTE_R4    (0x0080)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L4    (0x0040)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R3    (0x0020)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L3    (0x0010)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R2    (0x0008)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L2    (0x0004)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R1    (0x0002)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L1    (0x0001)  // Mute DAC output channel (clear to un-mute)


//-------------------------------------------------------------------------------
//DAC Volume Control - 10-bit granularity (1024 levels)
#define DACVOL_MIN      (0x000)
#define DACVOL_LOW      (0X100)
#define DACVOL_MED      (0X200)
#define DACVOL_HI       (0X300)
#define DACVOL_MAX      (0x3FF)
#define DACVOL_MASK     (0x3FF)  // Volume in dB is in 10 LSBs
                                 //   3FF = 0 dBFS = 1023/1023
                                 //   3FE = -0.01 dBFS = 1022/1023
                                 //      ...
                                 //   002 = -50.7 dBFS = 3/1023
                                 //   001 = -54.2 dBFS = 2/1023

//-------------------------------------------------------------------------------
//  ADC Control 1

#define ADCHPF     (0x0100)  // High pass filter (AC-coupled)
#define ADCPOWERDN (0x0080)  // DAC into power-down mode
#define ADCFS48    (0x0000)  // Sample rate = 48 KHz
#define ADCFS96    (0x0040)  // Sample rate = 96 KHz

//-------------------------------------------------------------------------------
//  ADC Control 2

#define AUXSLAVE   (0x0000)  // Aux input is in slave mode
#define AUXMASTER  (0x0200)  // Aux input is in master mode

#define ADCI2S     (0x0000)  // ADC transmits in I2S format
#define ADCRJ      (0x0040)  // ADC transmits in right-justified format
#define ADCDSP     (0x0080)  // ADC transmits in DSP (TDM) format
#define ADCLJ      (0x00C0)  // ADC transmits in left-justified format
#define ADCPACK256 (0x0100)  // ADC transmits in packed 256 format
#define ADCAUX256  (0x0180)  // ADC transmits in packed 128 format

#define ADC24BIT   (0x0000)  // 24-bit output word length
#define ADC20BIT   (0x0010)  // 20-bit output word length
#define ADC16BIT   (0x0020)  // 16-bit output word length

#define ADCMUTER   (0x0002)  // Mute right channel from ADC
#define ADCMUTEL   (0x0001)  // Mute right channel from ADC

//-------------------------------------------------------------------------------
//  ADC Control 3

#define IMCLKx2    (0x0000)  // Internal MCLK = external MCLK x 2
#define IMCLKx1    (0x0040)  // Internal MCLK = external MCLK
#define IMCLKx23   (0x0080)  // Internal MCLK = external MCLK x 2/3

#define PEAKRDEN   (0x0020)  // Enable reads of peak ADC levels
#define PEAKLEVELMASK  (0x003F)  // Six significant bit of level
									// 000000 = 0dBFS, -1dB/LSB


// =======================================================
// talk through interface
// =======================================================
#define NUM_SAMPLES 1024

// Function prototypes for this talkthrough code

extern void InitPLL_SDRAM(void);
extern void processBlock(unsigned int *);

extern void InitSRU(void);
extern void Init1835viaSPI(void);

extern void InitSPORT(void);
extern void TalkThroughISR(int);
extern void ClearSPORT(void);

extern void SetupSPI1835 (void) ;
extern void DisableSPI1835 (void) ;
extern void Configure1835Register (int i) ;
extern unsigned int Get1835Register (int i) ;

extern void SetupIRQ01 (void) ;
extern void Irq0ISR (int i) ;
extern void Irq1ISR (int i) ;

typedef void (* TFkt_ADSPuartCB) (unsigned int value);

extern void initUART(TFkt_ADSPuartCB cbRXFunction);
extern void UARTisr(int i);
extern void sendUARTuint32Values(unsigned int *pD, int amount);

extern void Delay (int i) ;

// =======================================================
// init AD1835
// =======================================================
/* Setup the SPI pramaters here in a buffer first */
unsigned int Config1835Param [] = {
            WR | DACCTRL1 | DACI2S | DAC24BIT | DACFS48,
            WR | DACCTRL2 ,//| DACMUTE_R4 | DACMUTE_L4,
            WR | DACVOL_L1 | DACVOL_MAX,
            WR | DACVOL_R1 | DACVOL_MAX,
            WR | DACVOL_L2 | DACVOL_MAX,
            WR | DACVOL_R2 | DACVOL_MAX,
            WR | DACVOL_L3 | DACVOL_MAX,
            WR | DACVOL_R3 | DACVOL_MAX,
            WR | DACVOL_L4 | DACVOL_MAX,
            WR | DACVOL_R4 | DACVOL_MAX,
            WR | ADCCTRL1 | ADCFS48,
            WR | ADCCTRL2 | ADCI2S | ADC24BIT,
            WR | ADCCTRL3 | IMCLKx2
        } ;

volatile int spiFlag ;

//Set up the SPI port to access the AD1835
void SetupSPI1835 ()
{
    /* First configure the SPI Control registers */
    /* First clear a few registers     */
    *pSPICTL = (TXFLSH | RXFLSH) ;
    *pSPIFLG = 0;
    *pSPICTL = 0;

    /* Setup the baud rate to 500 KHz */
    *pSPIBAUD = 100;

    /* Setup the SPI Flag register to FLAG3 : 0xF708*/
    *pSPIFLG = 0xF708;

    /* Now setup the SPI Control register : 0x5281*/
    *pSPICTL = (SPIEN | SPIMS | MSBF | WL16 | TIMOD1) ;

}

//Disable the SPI Port
void DisableSPI1835 ()
{
    *pSPICTL = (TXFLSH | RXFLSH);
}

//Send a word to the AD1835 via SPI
void Configure1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI to indicate that it has finished.
    while (1)
    {
        if (*pSPISTAT &amp; SPIF)
            break ;
    }
    Delay (100) ;
}

//Receive a register setting from the AD1835
unsigned int Get1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI port to indicate that it has finished
    while (1)
    {
        if (SPIF &amp; *pSPISTAT)
            break ;
    }
    Delay (100) ;
    return *pRXSPI ;
//  return i ;
}

//Set up all AD1835 registers via SPI
void Init1835viaSPI()
{
    int configSize = sizeof (Config1835Param) / sizeof (int) ;
    int i ;

    SetupSPI1835 () ;

    for (i = 0; i &lt; configSize; ++i)
    {
        Configure1835Register (Config1835Param[i]) ;
    }

    DisableSPI1835 () ;

}

//Delay loop
void Delay (int i)
{
    for (;i&gt;0;--i)
        asm (&quot;nop;&quot;) ;
}

// =======================================================
// PLL for SDRAM init
// =======================================================
void InitPLL_SDRAM(){

int i, pmctlsetting;

//Change this value to optimize the performance for quazi-sequential accesses (step &gt; 1)
#define SDMODIFY 1

    pmctlsetting= *pPMCTL;
    pmctlsetting &amp;= ~(0xFF); //Clear

    // CLKIN= 24.576 MHz, Multiplier= 27, Divisor= 1, INDIV=1, CCLK_SDCLK_RATIO= 2.
    // Core clock = (24.576 MHz * 27) /2 = 331.776 MHz
    pmctlsetting= SDCKR2|PLLM27|INDIV|DIVEN;
    *pPMCTL= pmctlsetting;
    pmctlsetting|= PLLBP;
    *pPMCTL= pmctlsetting;

    //Wait for around 4096 cycles for the pll to lock.
    for (i=0; i&lt;4096; i++)
          asm(&quot;nop;&quot;);

    *pPMCTL ^= PLLBP;       //Clear Bypass Mode
    *pPMCTL |= (CLKOUTEN);  //and start clkout


    // Programming SDRAM control registers and enabling SDRAM read optimization
    // CCLK_SDCLK_RATIO= 2.5
    // RDIV = ((f SDCLK X t REF )/NRA) - (tRAS + tRP )
    // (166*(10^6)*64*(10^-3)/4096) - (7+3) = 2583

    *pSDRRC= (0xA17)|(SDMODIFY&lt;&lt;17)|SDROPT;

    //===================================================================
    //
    // Configure SDRAM Control Register (SDCTL) for PART MT48LC4M32B2
    //
    //  SDCL3  : SDRAM CAS Latency= 3 cycles
    //  DSDCLK1: Disable SDRAM Clock 1
    //  SDPSS  : Start SDRAM Power up Sequence
    //  SDCAW8 : SDRAM Bank Column Address Width= 8 bits
    //  SDRAW12: SDRAM Row Address Width= 12 bits
    //  SDTRAS7: SDRAM tRAS Specification. Active Command delay = 7 cycles
    //  SDTRP3 : SDRAM tRP Specification. Precharge delay = 3 cycles.
    //  SDTWR2 : SDRAM tWR Specification. tWR = 2 cycles.
    //  SDTRCD3: SDRAM tRCD Specification. tRCD = 3 cycles.
    //
    //--------------------------------------------------------------------

    *pSDCTL= SDCL3|DSDCLK1|SDPSS|SDCAW8|SDRAW12|SDTRAS7|SDTRP3|SDTWR2|SDTRCD3;

    // Note that MS2 &amp; MS3 pin multiplexed with flag2 &amp; flag3.
    // MSEN bit must be enabled to access SDRAM, but LED7 cannot be driven with sdram
    *pSYSCTL |=MSEN;

    // Mapping Bank 2 to SDRAM
    // Make sure that jumper is set appropriately so that MS2 is connected to
    // chip select of 16-bit SDRAM device
    *pEPCTL |=B2SD;
    *pEPCTL &amp;= ~(B0SD|B1SD|B3SD);

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL0) Bank 0 for the ISSI IS61LV5128
    //
    //  WS2 : Wait States = 2 cycles
    //  HC1  : Bus Hold Cycle (at end of write access)= 1 cycle.
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //SRAM Settings
    *pAMICTL0 = WS2|HC1|AMIEN|BW8;

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL) Bank 1 for the AMD AM29LV08
    //
    //  WS23 : Wait States= 23 cycles
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //Flash Settings
    *pAMICTL1 = WS23|AMIEN|BW8;
}

// =======================================================
// serial Port
// =======================================================
/*
   Here is the mapping between the SPORTS and the DACS
   ADC -&gt; DSP  : SPORT0A : I2S
   DSP -&gt; DAC1 : SPORT1A : I2S
   DSP -&gt; DAC2 : SPORT1B : I2S
   DSP -&gt; DAC3 : SPORT2A : I2S
   DSP -&gt; DAC4 : SPORT2B : I2S
*/

unsigned int PCI = 0x00080000 ;
unsigned int OFFSET = 0x00080000 ;

// TCB blocks for Chaining
//Each block will be used for:
//      Filling from the ADC
//      Processing filled data
//      Sending to DAC
//
//Each one is doing only one of these steps for each SPORT interrupt.

//For this example the startup state is
// Start to 1st interrupt: gBlock_A is filled first, gBlock_C is sent
// 1st int to 2nd int: gBlock_C filled, gBlock_A processed, gBlock_B sent
// 2nd int to 3rd int: gBlock_B filled, gBlock_C processed, gBlock_A sent
// 3rd int to 4th int: gBlock_A filled, gBlock_B processed, gBlock_C sent
unsigned int gBlock_A[NUM_SAMPLES] ;
unsigned int gBlock_B[NUM_SAMPLES] ;
unsigned int gBlock_C[NUM_SAMPLES] ;

//Set up the TCBs to rotate automatically
int TCB_gBlock_A[4] = { 0, sizeof(gBlock_A), 1, 0};;
int TCB_gBlock_B[4] = { 0, sizeof(gBlock_B), 1, 0};
int TCB_gBlock_C[4] = { 0, sizeof(gBlock_C), 1, 0};

void InitSPORT()
{
    //Proceed from Block A to Block C
    TCB_gBlock_A[0] = (int) TCB_gBlock_C + 3 - OFFSET + PCI ;
    TCB_gBlock_A[3] = (unsigned int) gBlock_A - OFFSET ;

    //Proceed from Block B to Block A
    TCB_gBlock_B[0] = (int) TCB_gBlock_A + 3 - OFFSET + PCI ;
    TCB_gBlock_B[3] = (unsigned int) gBlock_B - OFFSET ;

    //Proceed from Block C to Block B
    TCB_gBlock_C[0] = (int) TCB_gBlock_B + 3 - OFFSET + PCI ;
    TCB_gBlock_C[3] = (unsigned int) gBlock_C - OFFSET ;

    //Clear the Mutlichannel control registers
    *pSPMCTL0 = 0;
    *pSPMCTL1 = 0;
    *pSPMCTL2 = 0;
    *pSPCTL0 = 0 ;
    *pSPCTL1 = 0 ;
    *pSPCTL2 = 0 ;

    //============================================================
    //
    // Configure SPORT 0 for input from ADC
    //
    //------------------------------------------------------------


    *pSPCTL0 = (OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A);

    // Enabling Chaining
    // Block A will be filled first
    *pCPSP0A = (unsigned int) TCB_gBlock_A - OFFSET + 3 ;

    //============================================================
    //
    // Configure SPORTs 1 &amp; 2 for output to DACs 1-4
    //
    //------------------------------------------------------------

    #ifdef DAC1
    *pSPCTL1 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC1
    *pCPSP1A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC2
    *pSPCTL1 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC2
    *pCPSP1B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC3
    *pSPCTL2 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC3
    *pCPSP2A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC4
    *pSPCTL2 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC4
    *pCPSP2B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif
}


// =======================================================
// init SRU
// =======================================================

void InitSRU(){

//-----------------------------------------------------------------------------
//
//  MCLK: The output of the 12.288 MHz xtal is either directly connected to the
//        codec, but also connected to DAI_P06, or just to DAI_P17. This is
//        determined by switch SW3 For this example we route the MCLK into
//        DAI_P17 and supply the clock to the ADC via DAI_P06  by routing the
//        signal through the SRU.

//  Tie the pin buffer input LOW.
    SRU(LOW,DAI_PB17_I);

//  Tie the pin buffer enable input LOW
    SRU(LOW,PBEN17_I);

//-----------------------------------------------------------------------------
//
//  Connect the ADC: The codec drives a BCLK output to DAI pin 7, a LRCLK
//          (a.k.a. frame sync) to DAI pin 8 and data to DAI pin 5.
//
//          Connect the ADC to SPORT0, using data input A
//
//          All three lines are always inputs to the SHARC so tie the pin
//          buffer inputs and pin buffer enable inputs all low.


//------------------------------------------------------------------------
//  Connect the ADC to SPORT0, using data input A

    //  Clock in on pin 7
    SRU(DAI_PB07_O,SPORT0_CLK_I);

    //  Frame sync in on pin 8
    SRU(DAI_PB08_O,SPORT0_FS_I);

    //  Data in on pin 5
    SRU(DAI_PB05_O,SPORT0_DA_I);

//------------------------------------------------------------------------
//    Tie the pin buffer inputs LOW for DAI pins 5, 7 and 8.  Even though
//    these pins are inputs to the SHARC, tying unused pin buffer inputs
//    LOW is &quot;good coding style&quot; to eliminate the possibility of
//    termination artifacts internal to the IC.  Note that signal
//    integrity is degraded only with a few specific SRU combinations.
//    In practice, this occurs VERY rarely, and these connections are
//    typically unnecessary.


    SRU(LOW,DAI_PB05_I);
    SRU(LOW,DAI_PB07_I);
    SRU(LOW,DAI_PB08_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs LOW for DAI pins 5, 6, 7 and 8 so
//  that they are always input pins.

    SRU(LOW,PBEN05_I);
    SRU(LOW,PBEN07_I);
    SRU(LOW,PBEN08_I);

//-----------------------------------------------------------------------------
//
//  Connect the DACs: The codec accepts a BCLK input from DAI pin 13 and
//          a LRCLK (a.k.a. frame sync) from DAI pin 14 and has four
//          serial data outputs to DAI pins 12, 11, 10 and 9
//
//          Connect DAC1 to SPORT1, using data output A
//          Connect DAC2 to SPORT1, using data output B
//          Connect DAC3 to SPORT2, using data output A
//          Connect DAC4 to SPORT2, using data output B
//
//          Connect the clock and frame sync inputs to SPORT1 and SPORT2
//          should come from the ADC on DAI pins 7 and 8, respectively
//
//          Connect the ADC BCLK and LRCLK back out to the DAC on DAI
//          pins 13 and 14, respectively.
//
//          All six DAC connections are always outputs from the SHARC
//          so tie the pin buffer enable inputs all high.
//

//------------------------------------------------------------------------
//  Connect the pin buffers to the SPORT data lines and ADC BCLK &amp; LRCLK

    SRU(SPORT2_DB_O,DAI_PB09_I);
    SRU(SPORT2_DA_O,DAI_PB10_I);
    SRU(SPORT1_DB_O,DAI_PB11_I);
    SRU(SPORT1_DA_O,DAI_PB12_I);

//------------------------------------------------------------------------
//  Connect the clock and frame sync input from the ADC directly
//    to the output pins driving the DACs.

    SRU(DAI_PB07_O,DAI_PB13_I);
    SRU(DAI_PB08_O,DAI_PB14_I);
    SRU(DAI_PB17_O,DAI_PB06_I);

//------------------------------------------------------------------------
//  Connect the SPORT clocks and frame syncs to the clock and
//  frame sync from the SPDIF receiver

    SRU(DAI_PB07_O,SPORT1_CLK_I);
    SRU(DAI_PB07_O,SPORT2_CLK_I);
    SRU(DAI_PB08_O,SPORT1_FS_I);
    SRU(DAI_PB08_O,SPORT2_FS_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs HIGH to make DAI pins 9-14 outputs.
    SRU(HIGH,PBEN06_I);
    SRU(HIGH,PBEN09_I);
    SRU(HIGH,PBEN10_I);
    SRU(HIGH,PBEN11_I);
    SRU(HIGH,PBEN12_I);
    SRU(HIGH,PBEN13_I);
    SRU(HIGH,PBEN14_I);
//--------------------------------------------------------------------------
// Route SPI signals to AD1835.

    SRU(SPI_MOSI_O,DPI_PB01_I)      //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I)     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I)      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG3_O, DPI_PB04_I)     //Connect SPI FLAG3 to DPI PB4.
//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peipherals to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG3_PBEN_O, DPI_PBEN04_I);

//-----------------------------------------------------------------------------
// UART config
    SRU2(UART0_TX_O,DPI_PB09_I); // UART transmit signal is connected to DPI pin 9
    SRU2(HIGH,DPI_PBEN09_I);
    SRU2(DPI_PB10_O,UART0_RX_I); // connect the pin buffer output signal to the UART0 receive
    SRU2(LOW,DPI_PB10_I);
    SRU2(LOW,DPI_PBEN10_I);      // disables DPI pin10 as input
}

// =======================================================
// IRQ's
// =======================================================
void SetupIRQ01 ()
{
    //Enable the pins as IRQ0 and IRQ1
    *pSYSCTL|= IRQ0EN | IRQ1EN;
    asm (&quot;#include &lt;def21369.h&gt;&quot;) ;
    //Set the IRQ pins to be edge sensitive
    asm (&quot;bit set mode2 IRQ0E;&quot;) ;
    asm (&quot;bit set mode2 IRQ1E;&quot;) ;
}

void Irq0ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ0 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol -= 0x3F ;
    rightDAC4Vol -= 0x3F ;

    if (leftDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

void Irq1ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ1 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol += 0x3F ;
    rightDAC4Vol += 0x3F ;

    if (leftDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

// =======================================================
// UART
// =======================================================

// type for the low level receive
typedef struct SADSPuartRecv {
	unsigned int 	val;	//!&lt; the value
	int				i;		//!&lt; the index
	TFkt_ADSPuartCB cb;		//!&lt; the callback function when we received 4 bytes of data
} TADSPuartRecv;

TADSPuartRecv gUARTrx;


// init ADSP uart
//          Bits per Second  -&gt; 19200
//          Data Bits        -&gt; 8
//          Parity           -&gt; odd
//          Stop Bits        -&gt; 2
//          Flow Control     -&gt; None
void initUART(TFkt_ADSPuartCB cbRXFunction) {
	// Sets the Baud rate for UART0
	*pUART0LCR = UARTDLAB;  //enables access to Divisor register to set baud rate
//	*pUART0DLL = 0x1c;      //0x21c = 540 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
//    *pUART0DLH = 0x02;

	*pUART0DLL = 0x38;      //1080 = 0x438 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
	*pUART0DLH = 0x04;



    // Configures UART0 LCR
//    *pUART0LCR = UARTWLS8| 				// word length 8
//                 UARTPEN| 				// parity enable ODD parity
//                 UARTSTB ; 				// Two stop bits
	*pUART0LCR = UARTWLS8;	// 8Bit 1StopBit NoParity

    //enables UART0 in receive mode
    *pUART0RXCTL = UARTEN;
    //enables UART0 in core driven mode
    *pUART0TXCTL = UARTEN;

    // set rx callback function and the state machine
    gUARTrx.val = 0;
    gUARTrx.i = 3;
    gUARTrx.cb = cbRXFunction;
}

// UART isr
void UARTisr(int i) {
	unsigned int v;
	v = *pUART0RBR;
	// shift register
	gUARTrx.val &lt;&lt;= 8;
	gUARTrx.val |= v;
	if (gUARTrx.i) {
		gUARTrx.i--;
	} else {
		gUARTrx.cb(gUARTrx.val);
		gUARTrx.i = 3;
		gUARTrx.val = 0;
	}
}

// UART send
void sendUARTuint32Values(unsigned int *pD, int amount) {
	unsigned int	v;
	int				i;
	int				j;

	for (i = 0; i &lt; amount; i++) {
		v = *pD;
		for (j = 0; j &lt; 4; j++) {
			// wait till the transmitter is ready
			while ((*pUART0LSR &amp; UARTTHRE) == 0);
			// mask all other bytes out and send the lowest byte
			*pUART0THR = v &amp; 0xFF;
			v &gt;&gt;= 8;
		}
		pD++;
	}
	// wait till the transmitter is ready
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
}


// =======================================================
// SPORT IRQs
// =======================================================

    //Pointer to the blocks

unsigned int *gpProcessBuffer[3] = {gBlock_A,gBlock_C,gBlock_B};

// Counter to choose which buffer to process
volatile int gProcessBufferCounter=2;
// Semaphore to indicate to main that a block is ready for processing
volatile int gProcessBufferReady=0;

void TalkThroughISR(int sig_int)
{
    //Increment the block pointer
    gProcessBufferCounter++;
    gProcessBufferCounter %= 3;

    gProcessBufferReady = 1;
}

// =======================================================
// LED func
// =======================================================

void LEDSRUinit () {
	// Init LED Ports
	SRU(LOW,DPI_PB06_I);				// Connect GND to DPI_PB06 input (LED1)
	SRU(LOW,DPI_PB07_I);	    		// Connect GND to DPI_PB07 input (LED2)
	SRU(LOW,DPI_PB08_I);	    		// Connect GND to DPI_PB08 input (LED3)
	SRU(LOW,DPI_PB13_I);	    		// Connect GND to DPI_PB13 input (LED4)
	SRU(LOW,DPI_PB14_I);	    		// Connect GND to DPI_PB14 input (LED5)
	SRU(LOW,DAI_PB15_I);		  		// Connect GND to DAI_PB15 input (LED6)
	SRU(LOW,DAI_PB16_I);  				// Connect GND to DAI_PB16 input (LED7)

	//Enabling the Buffer using the following sequence: High -&gt; Output, Low -&gt; Input

	SRU(HIGH,DPI_PBEN06_I);				// LED 1
	SRU(HIGH,DPI_PBEN07_I);				// LED 2
	SRU(HIGH,DPI_PBEN08_I);				// LED 3
	SRU(HIGH,DPI_PBEN13_I);				// LED 4
	SRU(HIGH,DPI_PBEN14_I);				// LED 5
	SRU(HIGH,PBEN15_I);					// LED 6
	SRU(HIGH,PBEN16_I);					// LED 7
}

#define set_LED_1 SRU(HIGH,DPI_PB06_I)
#define set_LED_2 SRU(HIGH,DPI_PB07_I)
#define set_LED_3 SRU(HIGH,DPI_PB08_I)
#define set_LED_4 SRU(HIGH,DPI_PB13_I)
#define set_LED_5 SRU(HIGH,DPI_PB14_I)
#define set_LED_6 SRU(HIGH,DPI_PB15_I)
#define set_LED_7 SRU(HIGH,DPI_PB16_I)

#define clear_LED_1 SRU(LOW,DPI_PB06_I)
#define clear_LED_2 SRU(LOW,DPI_PB07_I)
#define clear_LED_3 SRU(LOW,DPI_PB08_I)
#define clear_LED_4 SRU(LOW,DPI_PB13_I)
#define clear_LED_5 SRU(LOW,DPI_PB14_I)
#define clear_LED_6 SRU(LOW,DPI_PB15_I)
#define clear_LED_7 SRU(LOW,DPI_PB16_I)

// =======================================================
// init HW
// =======================================================

void initHW(TFkt_ADSPuartCB cbRXFunction) {

	// uart stuff
	*pPICR2 &amp;= ~(0x3E0); //Sets the UART0 receive interrupt to P13

	*pPICR2 |= (0x13&lt;&lt;5);


    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

	*pUART0LCR=0;
    *pUART0IER   = UARTRBFIE;    // enables UART0 receive interrupt
	interrupt(SIG_P13,UARTisr);


    // init LEDs
    LEDSRUinit();

    // init UART
    initUART (cbRXFunction);
}

void startHW() {
    // Finally setup the sport to receive / transmit the data
    InitSPORT();
}


// =======================================================
// processing
// =======================================================


#ifndef INT24_MAX
	#define INT24_MIN (-16777215-1)
	#define INT24_MAX (16777215)
#endif

#define dAD1835_ChannelAmount (2)
#define dAD1835_leftChannelOffset (1)
#define dAD1835_rightChannelOffset (0)

#define dAD1835_ChannelFlag_left ('l')
#define dAD1835_ChannelFlag_right ('r')

// the adsp codec channel type
typedef struct SCodecChannel {
	unsigned int 	size;			//!&lt; size of the channel
	char			channelFlag;	//!&lt; l=left r=right channel
} TCodecChannel;

// the codec channel list
typedef struct SCodecChannelList {
	TCodecChannel *		pCC;
	int					number;
} TCodecChannelList;

// find the channel struct by a given channel
inline TCodecChannel * ADSP_getChannel (int channel) {
	extern TCodecChannelList gADSPcodecChannels;
	if ((channel &lt; 0) || (channel &gt;= gADSPcodecChannels.number)) return NULL;
	return &amp;gADSPcodecChannels.pCC[channel];
}

// wait for the sample frame
inline void ADSP_waitForSamples () {
	if (!gProcessBufferReady) {
		set_LED_1;
		while (!gProcessBufferReady) {

		};
		gProcessBufferReady = 0;
		clear_LED_1;
	}
}

// ADSP ADC 24Bit value format
// 011...11		+FS
// 0......0		0
// 111...11		-FS
//
// reads some samples from the input channel
void ADSP_readSamplesFromChannel (TCodecChannel * pIC, float * pBuffer, unsigned int amount) {
	// wait for new samples
	ADSP_waitForSamples ();

	// after that get the pointer to the buffer
	int * pBinSRC  = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pIC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}

//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBuffer = ((float) ((int)(*pBinSRC)&lt;&lt;8)) * (1.0/2147483648.0);
		pBuffer++;
		pBinSRC += dAD1835_ChannelAmount;
	}
}


// writes some samples to the output channel
void ADSP_writesSamplesToChannel (TCodecChannel * pOC, float * pBuffer, unsigned int amount) {
	int * pBinSRC = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	float tv;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pOC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}
//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBinSRC = ((int)(2147483648.0 * pBuffer[i]))&gt;&gt;8;
		pBinSRC += dAD1835_ChannelAmount;
	}
}

TCodecChannel gADSPcodecChannel []= {
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left},	// ADC left input
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left}	// DAC4 &amp; DAC3 left output
};

TCodecChannelList gADSPcodecChannels = {
		gADSPcodecChannel,
		sizeof(gADSPcodecChannel) / sizeof(TCodecChannel)
};
</Code><Code idCode="125">// ===============================
// AP uuid = 5
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pN = pAP-&gt;pNodeList;
	TAPNode * pNpar = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) {
			pNpar-&gt;pNext = pN;
			free(pN);
		}
	pNpar = pN;
	pN = pN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	const THAL_Variable * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	const THALFunction * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	const THALFunctionParam * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				rec;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		rec = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((!rec) || (rec == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="126">void main(void)
{

    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

    // Finally setup the sport to receive / transmit the data
    InitSPORT();

    // Be in infinite loop and do nothing until done.
/*    for(;;)
    {
     while(blockReady)
          processBlock(src_pointer[int_cntr]);
    }
*/
	#define dfBufferL (256)
    float fBuffer[dfBufferL];

    TCodecChannel iC = {0,NUM_SAMPLES};
    TCodecChannel oC = {0,NUM_SAMPLES};

    for (;;) {
    	readSamplesFromChannel(&amp;iC,fBuffer,dfBufferL);
    	writesSamplesFromChannel(&amp;oC,fBuffer,dfBufferL);
    	clear_LED(1);
    }
}
</Code><Code idCode="127">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPgenericRationalVector * pRV = (TAPgenericRationalVector *) pParams[1].fp_pD;

	TCodecChannel * pC;
	
	// the channels at the AP starts with 1; at the ADSP with 0
	pC = ADSP_getChannel((int)pParams[0].fp_integer-1);
	if (!pC) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}

	ADSP_readSamplesFromChannel(pC,pRV-&gt;pVal,pRV-&gt;num);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="128">// ===============================
// function implementation for writeSample(var id = 61)
// description: writes a sample to a output
// ===============================

void HALfunc_ID61_writeSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter value descr: the value to be written to the output
	void ** pvalue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="129">// ===============================
// function implementation for convoluteVectorBiquad(var id = 111)
// description: convolute biquad with a vector of inputs and generate an output vector
// ===============================

void HALfunc_ID111_convoluteVectorBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPInterpreterVariable ** px = &amp;( pParams[0].fp_pV);
// parameter bqa descr: biquad array
	TAPInterpreterVariable ** pbqa = &amp;( pParams[1].fp_pV);
// parameter y descr: output
	TAPInterpreterVariable ** py = &amp;( pParams[2].fp_pV);
};
</Code><Code idCode="130">// ===============================
// function implementation for shiftVectorDelay(var id = 151)
// description: shifts a vector into a delay and the content of the delay to a vector
// ===============================

void HALfunc_ID151_shiftVectorDelay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPInterpreterVariable ** px = &amp;( pParams[0].fp_pV);
// parameter delay descr: the delay
	TAPInterpreterVariable ** pdelay = &amp;( pParams[1].fp_pV);
// parameter y descr: output
	TAPInterpreterVariable ** py = &amp;( pParams[2].fp_pV);
};
</Code><Code idCode="131">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="132">// ===============================
// AP uuid = 6
// ===============================

#define WAVsampleCache (65536)

// the wav modul global var
TStjWAVmodule gWAVModule;


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system

	// init wav module
	TStjWAVOpenInfo wavIOs[] = {
			{1,&quot;input.wav&quot;,1,44100,0,WAVsampleCache},
			{2,&quot;bypass.wav&quot;,0,44100,0,WAVsampleCache},
			{3,&quot;subbass.wav&quot;,0,44100,0,WAVsampleCache},
			{4,&quot;lowerVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{5,&quot;upperVoice.wav&quot;,0,44100,0,WAVsampleCache},
			{6,&quot;harmonics.wav&quot;,0,44100,0,WAVsampleCache},
	};

	if (WAVmoduleInit (sizeof(wavIOs) / sizeof(TStjWAVOpenInfo),wavIOs,&amp;gWAVModule)) {
		return -2;
	}

	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close wav module
	WAVmoduleExit(&amp;gWAVModule);

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="133">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO


#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif // of dAPuseFileIO

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;

	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,endian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);

	free (varL);
	free (instrL);
#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="134">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
#define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

#ifndef dAPuseExternalAPCode
// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif

#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO

#ifndef dAPuseExternalAPCode
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#else
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifndef dAPuseExternalAPCode
	free (varL);
	free (instrL);
#endif

#endif // of dAPuseFileIO

exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="135">// ===============================
// AP uuid = 7
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	initHW(drv_2_cbAPClient);

	startHW();

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}


// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}


// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}
</Code><Code idCode="136">// ===============================
// function implementation for readSample(var id = 60)
// description: reading a sample from an input
// ===============================

void HALfunc_ID60_readSample(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t* pchannel = &amp;( pParams[0].fp_integer);
// parameter resValue descr: the result of the action
	void ** presValue = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="137">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	// pParams[0].fp_integer
// parameter resValue descr: the result of the action
	TAPgenericRationalVector * pRV = (TAPgenericRationalVector *) pParams[1].fp_pD;

	TCodecChannel * pC;

	// the channels at the AP starts with 1; at the ADSP with 0
	pC = ADSP_getChannel((int)pParams[0].fp_integer-1);
	if (!pC) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
		return;
	}

	ADSP_writesSamplesToChannel(pC,pRV-&gt;pVal,pRV-&gt;num);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="138">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="139">// ===============================
// function implementation for convoluteVectorBiquad(var id = 111)
// description: convolute biquad with a vector of inputs and generate an output vector
// ===============================

void HALfunc_ID111_convoluteVectorBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPvarRational * pxA = (TAPvarRational *) pParams[0].fp_pD;
// parameter bqa descr: biquad array
	TAPvarBiquad * pbqa = (TAPvarBiquad *) pParams[1].fp_pD;
// parameter y descr: output
	TAPvarRational * pyA = (TAPvarRational *) pParams[2].fp_pD;

	float * px;
	float * py;
	int i, j, imax, jmax;
	float d1, y;
	TAPBiquadDF2 * pF;

	py = pyA-&gt;pR;
	px = pxA-&gt;pR;
	imax = pxA-&gt;num;
	jmax = pbqa-&gt;num;

	for (i = 0; i &lt; imax; i++) {
		y = *px;
		pF = pbqa-&gt;pB;
		for (j = 0; j &lt; jmax; j++) {
			// filter
			d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + y); // y = x
			y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
			y *= pF-&gt;k;

			pF-&gt;s2 = pF-&gt;s1;
			pF-&gt;s1 = d1;
			// output is input for the next filter
			pF++;
		}

		// save result to the output
		*py = y;
		px++;
		py++;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="140">// ############################################
// block based processing without overlapped operations
// ############################################

#define dStjFrameWAVinitialFrameAmount (1024)

typedef struct SStjFrameWAVOpenInfo {
	unsigned int	channelNumber;			//!&lt; logical channel
	char *			szFileName;				//!&lt; name of the file
	unsigned int	isInput;				//!&lt; if &lt;&gt;0 then this file is an input

	unsigned int	sampleRate;				//!&lt; the sample rate
	unsigned int	fileChannelNumber;		//!&lt; number of the channel at the file (starting at 1)
} TStjFrameWAVOpenInfo;

typedef struct SStjFrameWAVFile {
	unsigned int	channel;				//!&lt; the channel
	SNDFILE *		pSndF;					//!&lt; the file
	unsigned int	isInput;				//!&lt; if 0 the channel is an input channel


	float *			pFrameBuffer;			//!&lt; the buffer witch is filled with the frames
	int				fileChannels;			//!&lt; the amount of sample channels at the file
	int				activeChannel;			//!&lt; the channel used to read
	int				frameAmount;			//!&lt; amount of frame
} TStjFrameWAVFile;

typedef struct SStjFrameWAVmodule {
	TStjFrameWAVFile *	pChannels;
	unsigned int		number;
} TStjFrameWAVmodule;

//! close the set of wav files
void FrameWAVmoduleExit (TStjFrameWAVmodule * pM);

//! initis a set of wav files for writing / reading
int FrameWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	);

//! looking for the right channel
TStjFrameWAVFile * FrameWAVmoduleFindChannel (
		TStjFrameWAVmodule *	pM,		//!&lt; the module
		int				channel	//!&lt; channel to search for
	);

//! reads a sample from a channel
int FrameWAVmoduleGetInput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be read
		float *					pFrame			//!&lt;(out) pointer to the sample buffer witch is filled
	);

//! writes a sample to an output
int FrameWAVmoduleSetOutput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be write
		float *					pFrame			//!&lt;(in) pointer to the sample buffer witch is filled
	);

//! close the set of wav files
void FrameWAVmoduleExit (TStjFrameWAVmodule * pM) {
	//1. close all sound files
	int i;

	TStjFrameWAVFile * pWF = pM-&gt;pChannels;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		sf_close(pWF-&gt;pSndF);
		if (pWF-&gt;pFrameBuffer) free (pWF-&gt;pFrameBuffer);
		pWF++;
	}
	//2. free array
	free (pM-&gt;pChannels);

	//3. set all vars of the struct to default
	pM-&gt;number = 0;
	pM-&gt;pChannels = NULL;
}


//! initis a set of wav files for writing / reading
int FrameWAVmoduleInit (
		int 					number,		//!&lt;(in) amount of files
		TStjFrameWAVOpenInfo *	pWAVFiles,	//!&lt;(in) file description
		TStjFrameWAVmodule *	pModul		//!&lt;(in/out) modul descriptor witch is filled
	) {

	pModul-&gt;pChannels = malloc (sizeof(TStjFrameWAVFile) * number);
	if (!pModul-&gt;pChannels) {
		return -1;
	}
	memset (pModul-&gt;pChannels,0,sizeof(TStjFrameWAVFile) * number);
	pModul-&gt;number = number;

	int 				i;
	SF_INFO 			info;
	TStjFrameWAVFile * 	pWF = pModul-&gt;pChannels;

	for (i = 0;i &lt; number;i++) {
		// open sndfile interface
		memset (&amp;info,0,sizeof(SF_INFO));
		if (pWAVFiles[i].isInput) {
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_READ, &amp;info);
		} else {
			info.samplerate = pWAVFiles[i].sampleRate;
			info.channels = 1;
			info.format = SF_FORMAT_WAV | SF_FORMAT_FLOAT;
			pWF-&gt;pSndF = sf_open (pWAVFiles[i].szFileName,SFM_WRITE, &amp;info);
		}
		if (!pWF-&gt;pSndF) {
			goto error;
		}
		pWF-&gt;isInput = (unsigned int) pWAVFiles[i].isInput;
		pWF-&gt;channel = (unsigned int) pWAVFiles[i].channelNumber;


		if (pWAVFiles[i].isInput) {
			pWF-&gt;pFrameBuffer = malloc (sizeof(float)*info.channels*dStjFrameWAVinitialFrameAmount);
			if (!pWF-&gt;pFrameBuffer) {
				goto error;
			}
			pWF-&gt;frameAmount = dStjFrameWAVinitialFrameAmount;
		}

		// the file channel starts at 1 - here we start at 0
		pWF-&gt;activeChannel = pWAVFiles[i].fileChannelNumber - 1;
		pWF-&gt;fileChannels = (int) info.channels;

		pWF++;
	}
	return 0;
error:
	FrameWAVmoduleExit(pModul);
	return -2;
}

//! looking for the right channel
TStjFrameWAVFile * FrameWAVmoduleFindChannel (
		TStjFrameWAVmodule *	pM,		//!&lt; the module
		int						channel	//!&lt; channel to search for
		) {
	TStjFrameWAVFile * pWF = pM-&gt;pChannels;
	int i;
	for (i = 0; i &lt; pM-&gt;number;i++) {
		if (pWF-&gt;channel == channel) return pWF;
		pWF++;
	}
	return NULL;
}

//! reads a sample from a channel
int FrameWAVmoduleGetInput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be read
		float *					pFrame			//!&lt;(out) pointer to the sample buffer witch is filled
	) {
	TStjFrameWAVFile * pWF = FrameWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an input
	if (!pWF-&gt;isInput) {
		return -2;
	}

	// check the temp buffer size
	if (pWF-&gt;frameAmount &lt; sampleNumber) {
		pWF-&gt;pFrameBuffer = realloc(pWF-&gt;pFrameBuffer,sizeof(float)*pWF-&gt;fileChannels*sampleNumber);
		if (!pWF-&gt;pFrameBuffer) {
			return -3;
		}
		pWF-&gt;frameAmount = sampleNumber;
	}

	// fill the buffer
	int am = (int) sf_readf_float (pWF-&gt;pSndF,pWF-&gt;pFrameBuffer, sampleNumber);

	if (am &lt;= 0) {
		return -4;
	}

	// copy buffer
	int i;
	float * pD = pFrame;
	float * pS = pWF-&gt;pFrameBuffer;
	// add the offset so we start at the right pos at the frame
	pS += pWF-&gt;activeChannel;
	for (i = 0; i &lt; am; i++) {
		*pD = *pS;
		pD++;
		pS+= pWF-&gt;fileChannels;
	}
	// and fill the rest with 0.
	for (;i &lt; sampleNumber; i++) {
		*pD = 0.0f;
		pD++;
	}
	return 0;
}

//! writes a sample to an output
int FrameWAVmoduleSetOutput (
		TStjFrameWAVmodule *	pM,				//!&lt;(in) the module
		int						channel,		//!&lt;(in) the channel
		int						sampleNumber,	//!&lt;(in) number of samples to be write
		float *					pFrame			//!&lt;(in) pointer to the sample buffer witch is filled
	) {
	TStjFrameWAVFile * pWF = FrameWAVmoduleFindChannel(pM,channel);
	// channel not found
	if (!pWF) {
		return -1;
	}
	// channel is not an output
	if (pWF-&gt;isInput) {
		return -2;
	}
	// the last samples at the frame are new
	if (sampleNumber != sf_write_float (pWF-&gt;pSndF,pFrame, sampleNumber)) return -3;
	return 0;
}
</Code><Code idCode="141">// ===============================
// function implementation for readSampleFrame(var id = 62)
// description: reading a frames of sample from an input
// ===============================

void HALfunc_ID62_readSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer witch receives the samples
	TAPvarRational * pRA = (TAPvarRational *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleGetInput(&amp;gFrameWAVModule,(int)channel,pRA-&gt;num,pRA-&gt;pR)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="142">// ===============================
// function implementation for writeSampleFrame(var id = 63)
// description: writes a frame of samples to a output
// ===============================

void HALfunc_ID63_writeSampleFrame(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter channel descr: the channel
	int32_t channel = pParams[0].fp_integer;
// parameter frameBuffer descr: the buffer which is writen to the channel
	TAPvarRational * pRA = (TAPvarRational *) pParams[1].fp_pD;

	extern TStjFrameWAVmodule gFrameWAVModule;

	if (FrameWAVmoduleSetOutput(&amp;gFrameWAVModule,(int)channel,pRA-&gt;num,pRA-&gt;pR)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="143">// ===============================
// AP uuid = 8
// ===============================

// the global var for the Frame WAV modul
TStjFrameWAVmodule gFrameWAVModule;

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	TStjFrameWAVOpenInfo WI[] = {
			{1,&quot;x.wav&quot;,1,48000,1},
			{2,&quot;y.wav&quot;,0,48000,1}
	};

	if (FrameWAVmoduleInit(2,WI,&amp;gFrameWAVModule)) return -2;


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
	// closes the wav frame modul
	FrameWAVmoduleExit(&amp;gFrameWAVModule);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="144">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	TAP AP;
	int rc;

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);

	return EXIT_SUCCESS;
}
</Code><Code idCode="145">// ======================================================
// MSP 430 API
// ======================================================

#define   dMSP430_LED1_ON         P3OUT &amp;= ~BIT6
#define   dMSP430_LED1_OFF        P3OUT |= BIT6
#define   dMSP430_LED2_ON         P3OUT &amp;= ~BIT7
#define   dMSP430_LED2_OFF        P3OUT |= BIT7
#define   dMSP430_B1              BIT5&amp;P1IN         //B1 - P1.5
#define   dMSP430_B2              BIT6&amp;P1IN         //B2 - P1.6
#define   dMSP430_B3              BIT7&amp;P1IN         //B3 - P1.7
#define   dMSP430_E_HIGH          P4OUT |= BIT1
#define   dMSP430_E_LOW           P4OUT &amp;= ~BIT1
#define   dMSP430_RS_HIGH         P4OUT |= BIT3
#define   dMSP430_RS_LOW          P4OUT &amp;= ~BIT3
#define   dMSP430_LCD_Data        P4OUT
#define   dMSP430_LCD_LIGHT_ON    P4OUT |= BIT0
#define   dMSP430_LCD_LIGHT_OFF   P4OUT &amp;= ~BIT0

#define   dMSP430_INPUT           0
#define   dMSP430_OUTPUT          0xff
#define   dMSP430_ON              1
#define   dMSP430_OFF             0
#define   dMSP430_BUF_SIZE        25

#define   dMSP430__100us     	7                 //7 cycles *12 + 20 = 104 / 104*1us = 104us

//NAND FLASH
#define   dMSP430_MAX_BLOCK_NUMB		1024

#define   dMSP430_TRANS_LDY 		50
#define   dMSP430_WRITE_DLY		400
#define   dMSP430_ERASE_DLY		4000

#define   dMSP430_OUT_PORT		P5OUT
#define   dMSP430_IN_PORT		        P5IN
#define   dMSP430_IO_DIR			P5DIR

#define   dMSP430__CE_ON			P2OUT &amp;= ~BIT0
#define   dMSP430__CE_OFF			P2OUT |= BIT0
#define   dMSP430__RE_ON			P2OUT &amp;= ~BIT1
#define   dMSP430__RE_OFF			P2OUT |= BIT1
#define   dMSP430__WE_ON			P2OUT &amp;= ~BIT2
#define   dMSP430__WE_OFF			P2OUT |= BIT2

#define   dMSP430_ALE_ON			P2OUT |= BIT3
#define   dMSP430_ALE_OFF			P2OUT &amp;= ~BIT3
#define   dMSP430_CLE_ON			P2OUT |= BIT4
#define   dMSP430_CLE_OFF			P2OUT &amp;= ~BIT4

#define   dMSP430_R_B				P2IN &amp; BIT7
#define   dMSP430_DALLAS			P2IN &amp; BIT5

#define   dMSP430_READ_SPARE			0x50
#define   dMSP430_READ_0				0x00
#define   dMSP430_READ_1				0x01
#define   dMSP430_READ_STATUS			0x70

#define   dMSP430_WRITE_PAGE			0x80
#define   dMSP430_WRITE_AKN			0x10

#define   dMSP430_ERASE_BLOCK			0x60
#define   dMSP430_ERASE_AKN			0xD0

#define   dMSP430_DEV_ID				0x90

#define   dMSP430_SAMSUNG_ID			0xECE6


// ========================================
// helper
// ========================================

// delay cpu cycles
void msp430_Delay (unsigned int cycles)
{
	unsigned char k;
	for (k=0 ; k != cycles; k++);	//20+a*12 cycles (for 1MHz)
}

// delay a given time
void msp430_DelayN100us(unsigned char n)
{
	unsigned char j;
	for (j=0; j!=n; ++j) msp430_Delay (dMSP430__100us);
}

// ========================================
// LCD
// ========================================

enum eMSP430_LCDcommands {
	eMSP430_LCDcom_clear		= 0x01,
	eMSP430_LCDcom_returnHome	= 0x02,
	eMSP430_LCDcom_entryMode	= 0x04,
	eMSP430_LCDcom_display		= 0x08,
	eMSP430_LCDcom_cursorDisplay= 0x10,
	eMSP430_LCDcom_function		= 0x20,
	eMSP430_LCDcom_setCGram		= 0x40,
	eMSP430_LCDcom_setDDram		= 0x80
};


void msp430_LCD_E()
{
	dMSP430_E_HIGH;		    //toggle E for LCD
	_NOP();
	_NOP();
	dMSP430_E_LOW;
}

// sends a char to the display
void msp430_LCD_sendChar (unsigned char d)
{
	unsigned char temp;

	msp430_DelayN100us(5);                 //.5ms
	temp = d &amp; 0xf0;		//get upper nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;
	dMSP430_RS_HIGH;        	        //set LCD to data mode
	msp430_LCD_E();                           //toggle E for LCD
	temp = d &amp; 0x0f;
	temp = temp &lt;&lt; 4;               //get down nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;
	dMSP430_RS_HIGH;   	                //set LCD to data mode
	msp430_LCD_E();                           //toggle E for LCD
}

// sends a command to the LCD controller
void msp430_LCD_sendCmd (unsigned char e)
{
	unsigned char temp;

	msp430_DelayN100us(10);                //10ms
	temp = e &amp; 0xf0;		//get upper nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;               //send CMD to LCD
	dMSP430_RS_LOW;     	                //set LCD to CMD mode
	msp430_LCD_E();                           //toggle E for LCD
	temp = e &amp; 0x0f;
	temp = temp &lt;&lt; 4;               //get down nibble
	dMSP430_LCD_Data &amp;= 0x0f;
	dMSP430_LCD_Data |= temp;
	dMSP430_RS_LOW;            	        //set LCD to CMD mode
	msp430_LCD_E();                           //toggle E for LCD
}

// cmd clear
inline void msp430_LCD_cmdClear () {
	msp430_LCD_sendCmd(eMSP430_LCDcom_clear);
}

// cmd cur. home
inline void msp430_LCD_cmdCurHome () {
	msp430_LCD_sendCmd(eMSP430_LCDcom_returnHome);
}

// cmd entry mode (if cursor is shifted)
inline void msp430_LCD_cmdEntry (
		unsigned char incrFlag,		//!&lt; if 1 increment cursor, else decrement
		unsigned char enable		//!&lt; if set incr/decr is enabled
		) {
	unsigned char cmd;

	cmd = eMSP430_LCDcom_entryMode;
	if (incrFlag) cmd |= 0x2;
	if (enable) cmd |= 0x1;
	msp430_LCD_sendCmd(cmd);
}

// cmd set display on, show cursor, flash cursor
inline void msp430_LCD_cmdDisplay (
		unsigned char displayOn,	//!&lt; if 1 display is turned on
		unsigned char cursorOn,		//!&lt; if 1 the cursor is set on
		unsigned char cursorFlashOn	//!&lt; if 1 the cursor flashes
		) {
	unsigned char cmd;

	cmd = eMSP430_LCDcom_display;
	if (displayOn) cmd |= 0x4;
	if (cursorOn) cmd |= 0x2;
	if (cursorFlashOn) cmd |= 0x1;
	msp430_LCD_sendCmd(cmd);
}

// cmd shift cursor
inline void msp430_LCD_cmdShiftCursor (
		unsigned char leftFlag,	//!&lt; if 1 cursor is shift left
		unsigned char num		//!&lt; number of shifts
		) {
	unsigned char cmd,n;

	cmd = eMSP430_LCDcom_cursorDisplay;
	if (!leftFlag) cmd |= 0x4;
	for (n = 0; n &lt; num; n++) {
		msp430_LCD_sendCmd(cmd);
	}
}

// cmd shift display
inline void msp430_LCD_cmdShiftDisplay (
		unsigned char leftFlag,	//!&lt; if 1 cursor is shift left
		unsigned char num		//!&lt; number of shifts
		) {
	unsigned char cmd,n;

	cmd = eMSP430_LCDcom_cursorDisplay | 0x8;
	if (!leftFlag) cmd |= 0x4;
	for (n = 0; n &lt; num; n++) {
		msp430_LCD_sendCmd(cmd);
	}
}

// cmd shift display
inline void msp430_LCD_cmdFunction (
		unsigned char datamode,		//!&lt; 0=4bit 1=8bit mode
		unsigned char displayLines	//!&lt; 0=1 line, 1=2 lines
		) {
	unsigned char cmd;

	cmd = eMSP430_LCDcom_function;
	if (datamode) cmd |= 0x10;
	if (displayLines) cmd |= 0x08;
		msp430_LCD_sendCmd(cmd);
}


// init the LCD display
void msp430_LCD_init()
{
	dMSP430_RS_LOW;

	//Delay 100ms
	msp430_DelayN100us(250);
	msp430_DelayN100us(250);
	msp430_DelayN100us(250);
	msp430_DelayN100us(250);

	// setup
	dMSP430_LCD_Data |= BIT4 | BIT5;            //D7-D4 = 0011
	dMSP430_LCD_Data &amp;= ~BIT6 &amp; ~BIT7;

	msp430_LCD_E();                               //toggle E for LCD
	msp430_DelayN100us(100);                   //10ms
	msp430_LCD_E();                               //toggle E for LCD
	msp430_DelayN100us(100);                   //10ms
	msp430_LCD_E();                               //toggle E for LCD
	msp430_DelayN100us(100);                   //10ms
	dMSP430_LCD_Data &amp;= ~BIT4;                  //D7-D4 = 0010
	msp430_LCD_E();                               //toggle E for LCD

	msp430_LCD_cmdFunction(0,1);
	msp430_LCD_cmdDisplay(1,1,1);
	msp430_LCD_cmdClear();
}

// writes a string at the display
void msp430_LCD_print (
		unsigned char 	x,
		unsigned char 	y,
		char * 			szStr
	) {
	msp430_LCD_cmdClear();
	msp430_LCD_cmdCurHome();

	while (*szStr) {
		msp430_LCD_sendChar(*szStr);
		szStr++;
	}
}


// ========================================
// UART
// ========================================

// type for the fifo structure
typedef struct Sstj32BitFIFO {
	uint32_t *		buffer;
	uint32_t *		pBufferEnd; // pointer with the end value of the buffer
	uint32_t * 		pW;		// write pointer
	uint32_t * 		pR;		// read pointer
	// write element
	unsigned int	eC;		// element counter
	// status
	unsigned int	num;	// amount of elements at the buffer
	unsigned int	numMax;	// maximum of elements
} Sstj32BitFIFO;

// inits the fifo
inline int stjFIFO_init (
		Sstj32BitFIFO * pFIFO,
		int 			elements
	) {
	pFIFO-&gt;buffer = malloc(elements*sizeof(uint32_t));
	if (!pFIFO-&gt;buffer) return -1;

	pFIFO-&gt;numMax = elements;

	// setup the fifo
	pFIFO-&gt;pBufferEnd = pFIFO-&gt;buffer + elements;
	pFIFO-&gt;pW = pFIFO-&gt;buffer;
	pFIFO-&gt;pR = pFIFO-&gt;buffer;

	pFIFO-&gt;eC = 3;

	pFIFO-&gt;num = 0;
	while (elements) {
		elements--;
		*pFIFO-&gt;pW = 0;
		pFIFO-&gt;pW++;
	}
	pFIFO-&gt;pW = pFIFO-&gt;buffer;
	return 0;
}

// frees the fifo
inline int stjFIFO_free (
		Sstj32BitFIFO * pFIFO
	) {
	free (pFIFO-&gt;buffer);
	pFIFO-&gt;buffer = NULL;

	pFIFO-&gt;numMax = 0;
	return 0;
}


// writes a char to the buffer
inline void stjFIFO_writeChar(Sstj32BitFIFO * pFIFO, uint8_t d) {
	*pFIFO-&gt;pW |= d;
	// some checks

	// 1. have we written 4 bytes?
	if (pFIFO-&gt;eC) {
		// no - do some shift stuff
		pFIFO-&gt;eC--;
		*(pFIFO-&gt;pW) &lt;&lt;= 8;
	} else {
		pFIFO-&gt;eC = 3;
		// yes - set that we got a new element
		pFIFO-&gt;num++;
		pFIFO-&gt;pW++;
		if (pFIFO-&gt;pW == pFIFO-&gt;pBufferEnd) {
			pFIFO-&gt;pW = pFIFO-&gt;buffer;
		}
	}
}

// writes a char to the buffer
inline void stjFIFO_writeCharWithRotation(Sstj32BitFIFO * pFIFO, uint8_t d) {
	*pFIFO-&gt;pW |= (((uint32_t)d) &lt;&lt; 24);
	// some checks

	// 1. have we written 4 bytes?
	if (pFIFO-&gt;eC) {
		// no - do some shift stuff
		pFIFO-&gt;eC--;
		*(pFIFO-&gt;pW) &gt;&gt;= 8;
	} else {
		pFIFO-&gt;eC = 3;
		// yes - set that we got a new element
		pFIFO-&gt;num++;
		pFIFO-&gt;pW++;
		if (pFIFO-&gt;pW == pFIFO-&gt;pBufferEnd) {
			pFIFO-&gt;pW = pFIFO-&gt;buffer;
		}
	}
}


// read a element(uint32_t) from the buffer
inline int stjFIFO_readElement (Sstj32BitFIFO * pFIFO, uint32_t * pRes) {
	// if there are no entries report error
	if (!pFIFO-&gt;num) return -1;
	// ok let's read a value
	*pRes = *pFIFO-&gt;pR;
	*pFIFO-&gt;pR = 0;
	pFIFO-&gt;pR++;
	pFIFO-&gt;num--;
	if (pFIFO-&gt;pR == pFIFO-&gt;pBufferEnd) {
		pFIFO-&gt;pR = pFIFO-&gt;buffer;
	}

	return 0;
}

Sstj32BitFIFO gMsp430_uartFIFO;

// init UART0 port
void msp430_UART_init(int fifoElements)
{

	P3SEL |= 0x30;                        // P3.4 = USART0 TXD, P3.5 = USART0 RXD
	P3DIR |= 0x10;                        // P3.4 output direction

	// setup UART0
	UCTL0 = CHAR;                         // 8-bit character

	UTCTL0 = SSEL1;                       // UCLK = XT2
	UBR00 = 0x41;                         // 8 000 000/9600
	UBR10 = 0x03;                         //
	UMCTL0 = 0x0;

	ME1 |= UTXE0 + URXE0;                 // Enabled USART0 TXD/RXD
	IE1 |= URXIE0;                        // Enabled USART0 RX interrupt

	// setup the fifo
	stjFIFO_init(&amp;gMsp430_uartFIFO,fifoElements);
}

//  UART rx isq
#pragma vector=UART0RX_VECTOR
__interrupt void msp430_UART_RXisr (void)
{
	unsigned char v;
	_NOP();
	// save value
	v = RXBUF0;
	stjFIFO_writeChar(&amp;gMsp430_uartFIFO, v);
}

// send a bytes via uart
void msp430_UART_send (unsigned char * pD, unsigned int amount)
{
	unsigned int c;

	for (c = 0; c &lt; amount; c++) {
		// wait till tx buffer is ready
		while ((IFG1 &amp; UTXIFG0) == 0);
		// copy data
		TXBUF0 = *pD;
		pD++;
	}
	// wait till transfer has finished
	while ((IFG1 &amp; UTXIFG0) == 0);
}


// ========================================
// AD/DA converter
// ========================================

// init DA converter
void msp430_DAC_init ()
{
	DAC12_0CTL = DAC12SREF1 + /*DAC12RES + */ DAC12IR + DAC12AMP_7;                          //Ve REF+, 8-bit resolution
	DAC12_1CTL = DAC12SREF1 + /*DAC12RES + */ DAC12IR + DAC12AMP_7;                          //Ve REF+, 8-bit resolution

//  DAC12_0CTL = DAC12SREF1 + DAC12RES + DAC12IR + DAC12AMP_7;                          //Ve REF+, 8-bit resolution
//  DAC12_1CTL = DAC12SREF1 + DAC12RES + DAC12IR + DAC12AMP_7;
}

// init AD converter
void msp430_ADC_init ()
{
	ADC12CTL0 = SHT0_0 + ADC12ON;         // Set sampling time, turn on ADC12
	ADC12CTL1 = SHP;                      // Use sampling timer
	//ADC12IE = 0x01;                       // Enable interrupt
	ADC12MCTL0 = SREF_7;                  //VR+ = VeREF+ and VR– = VREF–/VeREF–
	ADC12CTL0 |= ENC;                     // Conversion enabled
	P6SEL = BIT5 + BIT4 + BIT3 + BIT2 + BIT1 + BIT0;                        // P6.4 ADC option select
}

// set AD channel
void msp430_setADChannel (unsigned int channel)
{
	ADC12CTL0 &amp;= ~ENC;                                    //disable convertion
	ADC12MCTL0 &amp;= 0xfff8;                                 //clear select chanel bits
	ADC12MCTL0 |= channel;                                      //select chanel
	ADC12CTL0 |= ENC;                                     //enable convertion
	ADC12CTL0 |= ADC12SC;                                 //Sampling open
	while ((ADC12CTL1 &amp; ADC12BUSY) != 0);
}

// ========================================
// NAND FLASH
// ========================================

//pull flash pins to inactive condition
void msp430_Flash_inactive() {
	dMSP430_IO_DIR=dMSP430_INPUT;         //IO is inputs
	dMSP430__CE_OFF;              //=1
	dMSP430__RE_OFF;              //=1
	dMSP430__WE_OFF;              //=1
	dMSP430_ALE_OFF;              //=0
	dMSP430_CLE_OFF;              //=0
}

// write a data byte to the flash
void msp430_Flash_writeByte (unsigned char d) {
	dMSP430_IO_DIR=dMSP430_OUTPUT;        //IO is outputs
	dMSP430__WE_ON;
	dMSP430_OUT_PORT=d;
	dMSP430__WE_OFF;              //latch data
}

// reads a byte from the flash
unsigned char msp430_Flash_readByte()
{
	unsigned char f;

	dMSP430_IO_DIR=dMSP430_INPUT;         //IO is inputs
	dMSP430__RE_ON;
	f=dMSP430_IN_PORT;
	dMSP430__RE_OFF;              //read data
	return f;
}

// write a block to the flash
unsigned char msp430_Flash_write(
		unsigned char page,
		unsigned char colAddr,
        unsigned char rowAddLow,
        unsigned char rowAddHigh,
        unsigned char num,
        unsigned char * pD
	) {
	unsigned char k, l;

	msp430_Flash_inactive();
	dMSP430_CLE_ON;
	dMSP430__CE_ON;
	msp430_Flash_writeByte(page);
	dMSP430_CLE_OFF;
	dMSP430_ALE_ON;
	msp430_Flash_writeByte(colAddr);
	msp430_Flash_writeByte(rowAddLow);
	msp430_Flash_writeByte(rowAddHigh);
	dMSP430_ALE_OFF;
	for (k=0; k != num; k++) {
		msp430_Flash_writeByte(*pD);
		pD++;
	}
	dMSP430_CLE_ON;
	msp430_Flash_writeByte(dMSP430_WRITE_AKN);
	while ((dMSP430_R_B) == 0);
	msp430_Flash_writeByte(dMSP430_READ_STATUS);
	dMSP430_CLE_OFF;
	l = msp430_Flash_readByte();
	msp430_Flash_inactive();
	return l;
}

// read a block of bytes from the flash
void msp430_Flash_read (
		unsigned char colAddr,
        unsigned char rowAddLow,
        unsigned char rowAddHigh,
        unsigned char num,
        unsigned char * pD
	)
{
	unsigned char n;

	msp430_Flash_inactive();
	dMSP430_CLE_ON;
	dMSP430__CE_ON;
	msp430_Flash_writeByte(dMSP430_READ_0);
	dMSP430_CLE_OFF;
	dMSP430_ALE_ON;
	msp430_Flash_writeByte(colAddr);
	msp430_Flash_writeByte(rowAddLow);
	msp430_Flash_writeByte(rowAddHigh);
	dMSP430_ALE_OFF;
	while ((dMSP430_R_B) == 0);
	for (n=0; n != num; n++) {
		*pD = msp430_Flash_readByte();
		pD++;
	}
	msp430_Flash_inactive();
}

unsigned char msp430_Flash_erase(
        unsigned char blockAddLow,
        unsigned char blockAddHigh
	) {
	unsigned char m;

	msp430_Flash_inactive();
	dMSP430_CLE_ON;
	dMSP430__CE_ON;
	msp430_Flash_writeByte(dMSP430_ERASE_BLOCK);
	dMSP430_CLE_OFF;
	dMSP430_ALE_ON;
	msp430_Flash_writeByte(blockAddLow);
	msp430_Flash_writeByte(blockAddHigh);
	dMSP430_ALE_OFF;
	dMSP430_CLE_ON;
	msp430_Flash_writeByte(dMSP430_ERASE_AKN);
	while ((dMSP430_R_B) == 0);
	msp430_Flash_writeByte(dMSP430_READ_STATUS);
	dMSP430_CLE_OFF;
	m = msp430_Flash_readByte();
	msp430_Flash_inactive();
	return m;
}

// ========================================
// HW init
// ========================================

void msp430_start() {
	// Stop watchdog timer
	WDTCTL = WDTPW + WDTHOLD;

	//XT2-ON
	BCSCTL1 &amp;= ~BIT7;
	//XT2 is SMCLK
	BCSCTL2 |= BIT3;

	//hardware init
	// 1. configure I/O Pins

	P1DIR=BIT0;

	//NAND FLASH init
	P2OUT=0x07;
	P2DIR=0x1F;

	//LED1
	P3OUT = BIT6 | BIT7;
	//LED2
	P3DIR = BIT6 | BIT7;

	//LCD init
	P4OUT = 0;
	P4DIR = 0xff;
}

void msp430_initHW (int fifoElements) {
	//configure modules

	//1 first the UART!
	msp430_UART_init(fifoElements);
	//2nd the LCD, if switched with UART the port sends a ghost sign because Port 3 is used by LCD and UART
	msp430_LCD_init();
	//3th DAC
	msp430_DAC_init();
	// 4th ADC
	msp430_ADC_init();

	// Enable interrupts
	_EINT();
}
</Code><Code idCode="146">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
//#define dAPuseExternalAPCode

#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}

#endif

int main()
{
	TAP AP;
	int rc;

	InitHW(); 	// hardware config

	rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	if (rc) {
		//Write_LCD_str(&quot;audio processor init failed with error code %i!&quot;,rc);
		LCD_print(&quot;AP failed&quot;);
		goto exit;
	}
	LCD_print(&quot;AP started&quot;);

#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	APdelete(&amp;AP);
	LCD_print(&quot;AP ended&quot;);

	return 0;
}
</Code><Code idCode="147">// ===============================
// AP uuid = 9
// ===============================

// no RX handling so far yet
void UART_RXhandler (unsigned char data) {
	
}

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="148">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable ** ps = &amp;( pParams[0].fp_pV);
// parameter i descr: index of the string at the array
	int32_t* pi = &amp;( pParams[1].fp_integer);
// parameter length descr: length of the string
	int32_t* plength = &amp;( pParams[2].fp_integer);
};
</Code><Code idCode="149">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable ** ps = &amp;( pParams[0].fp_pV);
// parameter i descr: index of the string at the array
	int32_t* pi = &amp;( pParams[1].fp_integer);
// parameter p descr: position at the string where to start from
	int32_t* pp = &amp;( pParams[2].fp_integer);
// parameter v1 descr: chars coded as 4 byte integer
	int32_t* pv1 = &amp;( pParams[3].fp_integer);
// parameter v2 descr: chars coded as 4 byte integer
	int32_t* pv2 = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="150">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable * pV = pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int index = (int)pParams[1].fp_integer;
// parameter length descr: length of the string
	int length = (int) pParams[2].fp_integer;


	// Boundary check
//	TAPstringVector * pSV =	pV-&gt;pData;
//	if ((index &lt; 0) || (index &gt;= pSV-&gt;num)) {
//		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
//		return;
//	}
	// is performed by the AL compiler

	// get APstring
	TAPstring * pS = &amp;((TAPstringVector *)pV-&gt;pData)-&gt;pStr[index];
	// resize and check result
	if (APstring_resize(pS,length)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -2;
		return;
	}
	// and go to next instruction
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="151">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPInterpreterVariable * pV = pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int i = (int) pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int p = (int) pParams[2].fp_integer;
// parameter v1 descr: chars coded as 4 byte integer
//	uint32_t* pv1 = &amp;( pParams[3].fp_raw);
// parameter v2 descr: chars coded as 4 byte integer
//	uint32_t* pv2 = &amp;( pParams[4].fp_raw);
	char *pSrc = (char *)&amp;(pParams[3].fp_raw);

	// dynamic adjust amount of bytes to be copied
	// int amount =   ((dAPInterpreterFuncMaxParams-3) * sizeof(int)/sizeof(char));

	// get string boundary check is performed by the ALC compiler
	TAPstring * pS = &amp;((TAPstringVector *)pV-&gt;pData)-&gt;pStr[i];

	APstring_fill(pS,p,((dAPInterpreterFuncMaxParams-3) * sizeof(uint32_t)/sizeof(char)),pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="152">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gALCdumpEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gALCdumpEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

TAPMsgDrv 	gDrvL [1];
TAP 		AP;

void * APIPthread(void * pArgs) {
	APInterpreterProcessState(AP.IP);

	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

int main()
{
	WSADATA			wsaData;
	pthread_t		IPthread;
	pthread_t		MSthread;


	int rc;
	int endianS = eAP_littleEndian;

    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	printf(&quot;WSAStartup failed!&quot;);
    	return -1;
    }

	APdrviver_1_init(&amp;gDrvL[0]);

	time_t t;

	time(&amp;t);
	srand((unsigned int)t);              /* Zufallsgenerator initialisieren */

	int uuid = rand();

	printf (&quot;AP uuid %i\n&quot;,uuid);

	// start up gtk+
	APgtk_start ();

	//rc = APinit(&amp;AP,815,gDrvL,1,1000,eAP_littleEndian);
	rc = APinit(&amp;AP,(TAPNodeID)uuid,gDrvL,1,1000,endianS);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
	if (rc) {
		printf(&quot;load programm failed with %i&quot;, rc);
		goto exit;
	}
#endif

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif

	rc = APInterpreterSetState (AP.IP,endianS,eAPInterpreterState_run);

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	printf(&quot;press a key to exit&quot;);
	getch();

	rc = APInterpreterSetState (AP.IP,endianS,eAPInterpreterState_halt);


exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}
</Code><Code idCode="153">// ===============================
// variable implementation for a string(var id = 3)
// ===============================
// --------------------------------------
// TAPstring
// --------------------------------------

// AP string type
typedef struct SAPstring {
	char * 		szTxt;	//!&lt; pointer to the vector of chars
	int 		len;	//!&lt; length of the string
} TAPstring;

// creates a AP string
int APstring_create (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string structure witch should be filled
		int 			len		//!&lt;(in) length of the string
	) {
	(pStr-&gt;szTxt) = malloc ((len+1)*sizeof(char));
	if (!pStr-&gt;szTxt) return -1;
	*(pStr-&gt;szTxt) = 0;
	pStr-&gt;len = len;
	return 0;
}

// frees a AP string
void APstring_free (
		TAPstring * 	pStr	//!&lt;(in) pointer to the string
	) {
	free ((pStr-&gt;szTxt));
	pStr-&gt;szTxt = NULL;
	pStr-&gt;len = 0;
}

// resizes the string
int APstring_resize (
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				newLen	//!&lt;(in) new length of the string
	) {
	char * pNS = realloc(pStr-&gt;szTxt,(newLen+1));
	if (!pNS) return -1;
	pStr-&gt;szTxt = pNS;
	pStr-&gt;len = newLen;
	return 0;
}

// fills the string from an extern source
void APstring_fill(
		TAPstring * 	pStr,	//!&lt;(in) pointer to the string
		int				iStart,	//!&lt;(in) start index at the string
		int				imax,	//!&lt;(in) end index of the string
		char *			pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i;
	char * pDest = pStr-&gt;szTxt +  iStart;
	// clip str
	if (imax &gt; pStr-&gt;len) imax = pStr-&gt;len - iStart;

	for (i = 0;i &lt; imax; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}

// --------------------------------------
// TAPstringVector
// --------------------------------------

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		pStr;	//!&lt; pointer to the first string at the vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;pStr = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;pStr) {
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * pS = pR-&gt;pStr;
	for (i = 0; i &lt; num; i++) {
		pS-&gt;szTxt = NULL;
		pS-&gt;len = 0;
		pS++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	TAPstring * pS = pSV-&gt;pStr;

	for (i = 0; i &lt; pSV-&gt;num; i++) {
		APstring_free(pS);
		pS++;
	}
	free(pSV-&gt;pStr);
	free(pSV);
}

// --------------------------------------
// AP var interface
// --------------------------------------

// transmit the data
void HALimpl_3_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
return APstringVector_create((int) numberOfElements);
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="154">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	int							sysEndian;				// endian of the system

	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;sysEndian = ((TAP *)pAP)-&gt;sysEndian;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pIP-&gt;sysEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}


// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="155">// ========| start of WIN Socket module |==================

// =============================
// pre defines from StjSockets
// =============================


enum eAdminMsgTypes {
	eAdminMsgType_login 	= 'i',
	eAdminMsgType_logout	= 'o',
	eAdminMsgType_exit		= 'e',
	eAdminMsgType_ack		= 'a',
	eAdminMsgType_nack		= 'n'
};

typedef struct SstjSocket_addr {
	struct sockaddr_in	Addr;
	int					len;
} TstjSocket_addr;


typedef struct SstjSocket_loginMsg {
	uint8_t		msgID;
	uint16_t	uuid;
	uint16_t	dataOutPort;
	uint16_t	dataInPort;
} TstjSocket_loginMsg;

typedef uint8_t TstjSocket_loginRAWmsg [7];

// creates a addinfo struct with the address of the local
struct addrinfo * stjSocket_getLocalSocketAddress (uint16_t port);

// creates a UPD server
int stjSocket_createServer (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	);


// creates a UDP client witch connects to a local server
int stjSocket_createClient (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	);

// closes socket &amp; address
void stjSocket_close (
		SOCKET				S,		//!&lt;(in) socket
		TstjSocket_addr	*	pAI		//!&lt;(in) address info
	);

// sends some data to an address
int stjSocket_send (
		SOCKET	 			S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	);

// receives some data and filles the address with the sender
int stjSocket_recv (
		SOCKET 				S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	);

// =============================
// pre defines from APclient
// =============================

typedef int (* TpfktAPClientRecvCallback) (void *pUserData, uint16_t number, uint8_t * pData);

typedef struct SAPClient {
	uint16_t					uuid;			//!&lt; uuid of the client

	SOCKET 						sAdmin;			//!&lt; admin socket
	uint16_t	 				adminPort;		//!&lt; admin port
	TstjSocket_addr				aAdmin;			//!&lt; socket address of the admin

	SOCKET						sDataIn;		//!&lt; data in socket
	uint16_t					dataInPort;		//!&lt; port of the data in socket
	TstjSocket_addr				aDataIn;		//!&lt; socket address of the data port

	SOCKET						sDataOut;		//!&lt; data out socket
	uint16_t					dataOutPort;	//!&lt; port of the data out socket
	TstjSocket_addr				aDataOut;		//!&lt; socket address of the data port

	pthread_t					recvThread;		//!&lt; receive thread
	uint8_t	*					recvBuffer;		//!&lt; temporaly receive buffer
	uint16_t					recvBufferSize;	//!&lt; size in bytes of the receive buffer
	void *						pUserData;		//!&lt; user data (can be NULL)
	TpfktAPClientRecvCallback	fktRecvCB;		//!&lt; receive call back funtion
} TAPClient;

// creates an admin client
int APclient_create (
		TAPClient *					pC,					//!&lt;(in/out) pointer to a client structure to be filled
		uint16_t 					adminPort,			//!&lt;(in) the port of the admin server port
		uint16_t					recvBufferSize,		//!&lt;(in) size in bytes of the receive buffer
		void *						pUserData,			//!&lt;(in) user data
		TpfktAPClientRecvCallback	fktCB				//!&lt;(in) callback function when receiving data
	);

//! free's the client
int APclient_close (
		TAPClient *		pC			//!&lt;(in) pointer to a client structure
	);


int APclient_send (
		TAPClient *		pC,			//!&lt;(in) pointer to a client structure
		uint16_t		num,		//!&lt;(in) amount of bytes to send
		uint8_t *		pData		//!&lt;(in) pointer to the data
	);

// =============================
// StjSockets implementation
// =============================

// ======================================
// defines
// ======================================

#define dMaxHostNameChars (254)

// creates a UPD server
int stjSocket_createServer (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	) {
	// create socket
	*pS=socket(AF_INET,SOCK_DGRAM,0);
	if (!*pS) goto mainErrorWithMsg;

	// create address
	pAI-&gt;Addr.sin_family=AF_INET; // AF_UNSPEC
	pAI-&gt;Addr.sin_port=htons(port);
	pAI-&gt;Addr.sin_addr.s_addr=ADDR_ANY;
	pAI-&gt;len = sizeof(SOCKADDR_IN);

	// bind socket to adress
	if (SOCKET_ERROR == bind(*pS,(SOCKADDR*)&amp;(pAI-&gt;Addr),pAI-&gt;len)) goto mainErrorWithMsg;
    return 0;
mainErrorWithMsg:
   	printf (&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
   	return -1;
}

// creates a UDP client witch connects to a local server
int stjSocket_createClient (
		uint16_t 			port,	//!&lt;(in) port
		SOCKET *			pS,		//!&lt;(out) socket
		TstjSocket_addr	*	pAI		//!&lt;(out) address info
	) {
	char 				szPath[dMaxHostNameChars] = &quot;&quot;;
	struct hostent *	pHostInfo;

	// resolve hostname
    if (gethostname(szPath,dMaxHostNameChars)) goto mainErrorWithMsg;

	pHostInfo = gethostbyname(szPath);
	if (!pHostInfo) goto mainErrorWithMsg;

	// create socket
	*pS=socket(AF_INET,SOCK_DGRAM,0);
	if (!*pS) goto mainErrorWithMsg;

	// get the local ip from the host
	char * szLocalIP;
	szLocalIP = inet_ntoa (*(struct in_addr *)*pHostInfo-&gt;h_addr_list);

	unsigned long addr = inet_addr(szLocalIP);
	if ((INADDR_NONE == addr) || (INADDR_ANY == addr)) {
		closesocket(*pS);
		printf (&quot;unknown inet address\\nerror: %s\\n&quot;,gai_strerror(WSAGetLastError()));
		return -2;
	}

	// create address
	pAI-&gt;Addr.sin_family=AF_INET; // AF_UNSPEC
	pAI-&gt;Addr.sin_port=htons(port);
	pAI-&gt;Addr.sin_addr.s_addr= addr;
	pAI-&gt;len = sizeof(SOCKADDR_IN);

    return 0;
mainErrorWithMsg:
   	printf (&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
   	return -1;
}

// closes socket &amp; address
void stjSocket_close (
		SOCKET				S,		//!&lt;(in) socket
		TstjSocket_addr	*	pAI		//!&lt;(in) address info
	) {
	// pAI is self build so we don't need a free call
	//freeaddrinfo(gMsgServer.aiAdmin);
	closesocket(S);
}

// sends some data to an address
int stjSocket_send (
		SOCKET	 			S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	) {
	int n;
	n = sendto (S, (const char *) pData, dataSize, 0,(struct sockaddr *)&amp;(pAddr-&gt;Addr), pAddr-&gt;len);
	if (n != dataSize) {
		fprintf (stderr,&quot;sending data failed (%i bytes send)!(error: %s)!\\n&quot;,n,gai_strerror(WSAGetLastError()));
		return -1;
	}
	return 0;
}

// receives some data and filles the address with the sender
int stjSocket_recv (
		SOCKET 				S,			//!&lt; socket
		void *				pData,		//!&lt; data to send
		int					dataSize,	//!&lt; amount of bytes
		TstjSocket_addr	*	pAddr		//!&lt; address
	) {
	int n;
	n = recvfrom(S, (char *) pData, dataSize, 0,(struct sockaddr *)&amp;(pAddr-&gt;Addr), &amp;pAddr-&gt;len);
	if (n != dataSize) {
		fprintf (stderr,&quot;receiving data failed (%i bytes received)!(error: %s)!\\n&quot;,n,gai_strerror(WSAGetLastError()));
		return -1;
	}
	return 0;
}

// =============================
// APClient implementation
// =============================
// =====================================
// pre defs
// =====================================

// the thread function for receiving data
void * APclient_RecvThread (void *);


// =====================================
// functions
// =====================================


// creates an admin client
int APclient_create (
		TAPClient *					pC,					//!&lt;(in/out) pointer to a client structure to be filled
		uint16_t 					adminPort,			//!&lt;(in) the port of the admin server port
		uint16_t					recvBufferSize,		//!&lt;(in) size in bytes of the receive buffer
		void *						pUserData,			//!&lt;(in) user data
		TpfktAPClientRecvCallback	fktCB				//!&lt;(in) callback function when receiving data
	) {
	uint8_t					msgID;

	// 0. save the user data
	pC-&gt;pUserData = pUserData;

	// 1. create a socket to communicate with the admin port
	if (stjSocket_createClient(
			adminPort,
			&amp;(pC-&gt;sAdmin),
			&amp;(pC-&gt;aAdmin)
		)) {
		return -1;
	}

	pC-&gt;adminPort = adminPort;
	// 2. setup
	// request login
	msgID = eAdminMsgType_login;
	if (stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	// get the ports
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (msgID != eAdminMsgType_login) {
		fprintf(stderr,&quot;admin send wrong message back\\n&quot;);
		goto abortAndError;
	}

	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;uuid),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;dataInPort),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;dataOutPort),2,&amp;(pC-&gt;aAdmin))) goto receivedFailed;


	printf(&quot;data in: %u\\ndata out: %u\\n&quot;,(unsigned int)pC-&gt;dataInPort,(unsigned int)pC-&gt;dataOutPort);

	// create data sockets
	if (stjSocket_createServer(
			pC-&gt;dataInPort,
			&amp;(pC-&gt;sDataIn),
			&amp;(pC-&gt;aDataIn)
		)) goto DataSocketCreationError;

	// create recv buffer &amp; threads
	pC-&gt;recvBuffer = malloc((size_t)recvBufferSize);
	if (!pC) goto abortAndError;
	pC-&gt;recvBufferSize = recvBufferSize;
	pC-&gt;fktRecvCB = fktCB;

	// now we can start the handling thread
	pthread_create(&amp;pC-&gt;recvThread,NULL,APclient_RecvThread,pC);

	// send ack to server
	msgID = eAdminMsgType_ack;
	if (stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;

	// wait till server is ready
	if (stjSocket_recv(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (eAdminMsgType_ack != msgID) {
		fprintf(stderr,&quot;admin error\\n&quot;);
		return -10;
	}

	// now open the client data port
	if (stjSocket_createClient(
			pC-&gt;dataOutPort,
			&amp;(pC-&gt;sDataOut),
			&amp;(pC-&gt;aDataOut)
		)) goto DataSocketCreationError;

	// some info
    printf (&quot;client setup with uuid=%u data-in port:%u data-out port:%u\\n&quot;,(unsigned int)pC-&gt;uuid,(unsigned int)pC-&gt;dataInPort,(unsigned int)pC-&gt;dataOutPort);
    fflush(stdout);
	return 0;

abortAndError:
	msgID = eAdminMsgType_nack;
	stjSocket_send(pC-&gt;sAdmin,&amp;msgID,1,&amp;(pC-&gt;aAdmin));
	return -2;

sendFailed:
	fprintf(stderr,&quot;sending to admin failed\\n&quot;);
	fprintf (stderr,&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
	return -3;

receivedFailed:
	fprintf(stderr,&quot;receiving from admin failed\\n&quot;);
	fprintf (stderr,&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
	return -4;

DataSocketCreationError:
	fprintf(stderr,&quot;creating data sockets failed\\n&quot;);
	fprintf (stderr,&quot;error: %s\\n&quot;,gai_strerror(WSAGetLastError()));
	return -4;
}

//! free's the client
int APclient_close (
		TAPClient *		pC			//!&lt;(in/out) pointer to a client structure to be filled
	) {
	// vars
	uint8_t				msgID;

	// request logout
	msgID = eAdminMsgType_logout;
	if (stjSocket_send(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sAdmin,(char *)&amp;(pC-&gt;uuid),2,&amp;(pC-&gt;aAdmin))) goto sendFailed;
	// wait till server finished it
	if (stjSocket_recv(pC-&gt;sAdmin,(char *)&amp;msgID,1,&amp;(pC-&gt;aAdmin))) goto receivedFailed;
	if (msgID != eAdminMsgType_ack) {
		fprintf(stderr,&quot;logout failed\\n&quot;);
	}

	stjSocket_close(pC-&gt;sAdmin,&amp;(pC-&gt;aAdmin));
	stjSocket_close(pC-&gt;sDataIn,&amp;(pC-&gt;aDataIn));
	stjSocket_close(pC-&gt;sDataOut,&amp;(pC-&gt;aDataOut));

	// wait till thread is gone
	pthread_join(pC-&gt;recvThread,NULL);


	return 0;
sendFailed:
	fprintf(stderr,&quot;sending to admin failed\\n&quot;);
	return -3;

receivedFailed:
	fprintf(stderr,&quot;receiving from admin failed\\n&quot;);
	return -4;
}

// the thread function for receiving data
void * APclient_RecvThread (
		void *	pArg
	) {
	uint16_t			msgLen;
	uint8_t *			pNB;

	TAPClient *			pC = pArg;

	// get data
	for (;;) {
		// read amount of data to be received
		if (stjSocket_recv(pC-&gt;sDataIn,&amp;msgLen,2,&amp;(pC-&gt;aDataIn))) goto recvError;
		// check if we have enough memory allocated at the buffer
		if (msgLen &gt; pC-&gt;recvBufferSize) {
			pNB = realloc(pC-&gt;recvBuffer,msgLen);
			if (pNB) {
				pC-&gt;recvBuffer = pNB;
				pC-&gt;recvBufferSize = msgLen;
			} else {
				fprintf (stderr,&quot;realloc memory failed&quot;);
				goto recvError;
			}
		}
		// transmit data
		if (stjSocket_recv(pC-&gt;sDataIn,pC-&gt;recvBuffer,msgLen,&amp;(pC-&gt;aDataIn))) goto recvError;
		// and handle the data
		pC-&gt;fktRecvCB(pC-&gt;pUserData, msgLen, pC-&gt;recvBuffer);

	}
	pthread_exit((void *)0);
	return NULL;

recvError:
	// close data connections
	fprintf (stderr,&quot;receiving data failed!&quot;);
	pthread_exit((void *)-3);
	return NULL;
}


int APclient_send (
		TAPClient *		pC,			//!&lt;(in) pointer to a client structure
		uint16_t		num,		//!&lt;(in) amount of bytes to send
		uint8_t *		pData		//!&lt;(in) pointer to the data
	) {
	if (stjSocket_send(pC-&gt;sDataOut,&amp;pC-&gt;uuid,2,&amp;(pC-&gt;aDataOut))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sDataOut,&amp;num,2,&amp;(pC-&gt;aDataOut))) goto sendFailed;
	if (stjSocket_send(pC-&gt;sDataOut,pData,(int)num,&amp;(pC-&gt;aDataOut))) goto sendFailed;

	return 0;
sendFailed:
	fprintf(stderr,&quot;sending data to server failed\\n&quot;);
	return -1;

}
// ========| end of WIN Socket module |==================</Code><Code idCode="156"></Code><Code idCode="157">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drv_open_1 (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_close_1 (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_destroy_1 (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_ACK_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_NACK_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_startPrg_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_sendVariable_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_sendInstruction_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_endPrg_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_stop_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_step_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_run_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_updateVariable_1 (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_login_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_logout_1 (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="158">// ===============================
// driver uuid =1
// ===============================

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="159">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t * data) {
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t functionID, int32_t * parameter) {
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t vtID, int32_t * data) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="160">// ===============================
// driver uuid =1
// ===============================

// ------------------------------
// drv own functions
// ------------------------------

#define dAPClientServerAdminPort (50000)
#define dAPClientInitBuffer (1024)

// struct for the drv data
typedef struct SAPTCPIPdrv {
	TAPClient 					cl;			//!&lt; tcp/ip client
	TAPMsgHeader				txHeader;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TAPTCPIPdrv;

// ------------------------------
// drv own functions
// ------------------------------

int drv_1_sendHeader (
		TAPClient * pCl,
		uint32_t * pH,
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	pH[eAPMsgHeaderPosition_msgTypeID] = msgId;
	pH[eAPMsgHeaderPosition_msgNumber] = num;
	pH[eAPMsgHeaderPosition_receiver] = recv;
	pH[eAPMsgHeaderPosition_length] = length;
	if (APclient_send(pCl,sizeof(TAPMsgHeader),(uint8_t *)pH)) return -1;
	return 0;
}

// call back function of the TCP/IP driver
int drv_1_cbAPClient (void *pvDC, uint16_t number, uint8_t * pData) {
	TAPReceiveStateMachine * pSM = pvDC;
	return pSM-&gt;state (pSM, (uint32_t *) pData, number / sizeof(uint32_t));
}

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = NULL;

	pDC = malloc(sizeof(TAPTCPIPdrv));
	if (!pDC) return -1;
	if (APclient_create(&amp;(pDC-&gt;cl),dAPClientServerAdminPort,dAPClientInitBuffer,&amp;(pDC-&gt;rxSM),drv_1_cbAPClient)) return -2;
	// init header
	pDC-&gt;txHeader[eAPMsgHeaderPosition_endian] = ((TAP *) pAP)-&gt;sysEndian;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgTypeID] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgNumber] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = pDC;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;pDC-&gt;rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		APclient_close(&amp;pDC-&gt;cl);
	}
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		free(pDC);
		pDrv-&gt;pDrvData = NULL;
	}
	return 0;
}
//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_ACK, receiver, mNum, 0);
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_NACK, receiver, mNum, 0);
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_startPrg, receiver, mNum, 0) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;globalVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;localVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;instructionNumber)
		) return -10;
	return 0;
}

//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendVariable, receiver, mNum, 3) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;varTypeID) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;num)
		) return -10;
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t)*dAPInterpreterFuncMaxParams,(uint8_t *)fbc)
		) return -10;
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_endPrg, receiver, mNum, 0);
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_stop, receiver, mNum, 0);
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_step, receiver, mNum, 0);
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_run, receiver, mNum, 0);
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t i, uint32_t * data) {
	return -1;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_login, receiver, mNum, 0);
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_logout, receiver, mNum, 0);
}
</Code><Code idCode="161"></Code><Code idCode="162">// -------------------------------------------
// AP gtk helper
// -------------------------------------------

PangoFontDescription * gAPgtkMonoSpaceFont = NULL;


// a helper for destroying &quot;undestroyed&quot; UI's
void APgtk_helper_destroy (GtkWidget * pWG) {
	if (pWG) {
		if (pWG-&gt;object.parent_instance.ref_count) {
			gtk_widget_destroy(pWG);
		}
	}
}

// -------------------------------------------
// AP panel
// -------------------------------------------

// struct for a panel
typedef struct SAPgtkPanel {
	GtkWidget *		pWnd;		//!&lt; pointer to the window
	GtkWidget *		pBox;		//!&lt; placement box
} TAPgtkPanel;


// create a panel
int gtkAP_local_PanelCreate (
		TAPgtkPanel * 	pP,		//!&lt;(in/out) structure to be filled
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {
	// Create a new window
	pP-&gt;pWnd = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	if (!pP-&gt;pWnd) return -1;

	// UI's are at fixed positions
	pP-&gt;pBox = gtk_fixed_new();
	if (!pP-&gt;pBox) return -2;

	gtk_container_add(GTK_CONTAINER(pP-&gt;pWnd), pP-&gt;pBox);

	// setup main wnd
	gtk_window_set_title (GTK_WINDOW (pP-&gt;pWnd), &quot;AP Panel&quot;);
	gtk_window_set_default_size (GTK_WINDOW (pP-&gt;pWnd),xle, yle);
	gtk_window_move(GTK_WINDOW (pP-&gt;pWnd),x, y);

	// It's a good idea to do this for all windows
	//gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;destroy&quot;, GTK_SIGNAL_FUNC (gtk_exit), NULL);
	gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;destroy&quot;, GTK_SIGNAL_FUNC (gtk_widget_destroy), NULL);

	//gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;delete_event&quot;, GTK_SIGNAL_FUNC (gtk_exit), NULL);
	gtk_signal_connect (GTK_OBJECT (pP-&gt;pWnd), &quot;delete_event&quot;, GTK_SIGNAL_FUNC (gtk_widget_destroy), NULL);

	// Sets the border width of the window
	gtk_container_set_border_width (GTK_CONTAINER (pP-&gt;pWnd), 1);

	gtk_widget_realize(pP-&gt;pWnd);

	gtk_widget_show_all(pP-&gt;pWnd);

	return(0);
}


// destroys a panel
void gtkAP_local_PanelDestroy (
		TAPgtkPanel * 	pP
	) {
	APgtk_helper_destroy(pP-&gt;pWnd);
	APgtk_helper_destroy(pP-&gt;pBox);
	pP-&gt;pWnd = NULL;
	pP-&gt;pBox = NULL;
}

// -------------------------------------------
// AP button
// -------------------------------------------

// struct for a AP button
typedef struct SAPgtkButton {
	GtkWidget *		pB;				//!&lt; pointer to the button
	int				pressCounter;	//!&lt; counter of the press event
} TAPgtkButton;

// call back to handle click calls
void gtkAP_cb_ButtonClicked (GtkWidget *widget, gpointer data) {
	TAPgtkButton * pB = (TAPgtkButton *) data;
	pB-&gt;pressCounter++;
}

// creates a AP button
int gtkAP_local_ButtonCreate (
		TAPgtkButton * 	pB,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {


	pB-&gt;pressCounter = 0;
	// create button
	pB-&gt;pB = gtk_button_new_with_label  (&quot;&quot;);
	if (!pB-&gt;pB) return -1;

	// bind it to the window
	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pB-&gt;pB, x, y);
	gtk_widget_set_size_request(pB-&gt;pB, xle, yle);

	gtk_widget_modify_font(gtk_bin_get_child (GTK_BIN(pB-&gt;pB)),gAPgtkMonoSpaceFont);

	gtk_widget_show (pB-&gt;pB);

	// set msg handler
	g_signal_connect(G_OBJECT(pB-&gt;pB), &quot;clicked&quot;, G_CALLBACK(gtkAP_cb_ButtonClicked), pB);


	return 0;
}

// destroys a button
void gtkAP_local_ButtonDestroy (
		TAPgtkButton * 	pB
	) {
	APgtk_helper_destroy(pB-&gt;pB);

	pB-&gt;pB = NULL;
	pB-&gt;pressCounter = 0;
}

// -------------------------------------------
// AP LED
// -------------------------------------------

// struct for a AP led
typedef struct SAPgtkLED {
	GtkWidget *		pLED;				//!&lt; pointer to the LED
	int				onFlag;
	double			onColor[3];
	double			offColor[3];
} TAPgtkLED;


static gboolean APgtk_cb_LEDexpose (
		GtkWidget *			da,
		GdkEventExpose *	event,
		gpointer        	data
	)
{
  cairo_t *		cr;
  TAPgtkLED	* 	pLED = (TAPgtkLED	*) data;
  double 		r;
  cr = gdk_cairo_create (da-&gt;window);
  gdk_cairo_rectangle (cr, &amp;event-&gt;area);
  cairo_clip (cr);
  if (pLED-&gt;onFlag) {
	  cairo_set_source_rgb (cr, pLED-&gt;onColor[0], pLED-&gt;onColor[1], pLED-&gt;onColor[2]);
  } else {
	  cairo_set_source_rgb (cr, pLED-&gt;offColor[0], pLED-&gt;offColor[1], pLED-&gt;offColor[2]);
  }
  //cairo_rectangle(cr, event-&gt;area.x, event-&gt;area.y, event-&gt;area.width, event-&gt;area.height);
  r = (event-&gt;area.width &gt; event-&gt;area.height) ? event-&gt;area.width : event-&gt;area.height;
  r /= 2.f;
  cairo_arc (cr,event-&gt;area.x+r, event-&gt;area.y+r,r, 0.f, 2.f * M_PI);

  cairo_fill(cr);
  cairo_destroy (cr);
  return TRUE;
}

// creates a AP button
int gtkAP_local_LEDCreate (
		TAPgtkLED * 	pLED,	//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	pLED-&gt;onFlag = 0;
	pLED-&gt;offColor[0] = 0.0;
	pLED-&gt;offColor[1] = 0.0;
	pLED-&gt;offColor[2] = 0.0;
	pLED-&gt;onColor[0] = 1.0;
	pLED-&gt;onColor[1] = 1.0;
	pLED-&gt;onColor[2] = 1.0;


	pLED-&gt;pLED = gtk_drawing_area_new ();
	if (!pLED-&gt;pLED) return -1;
	gtk_widget_set_size_request (pLED-&gt;pLED, xle, yle);

	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pLED-&gt;pLED, x, y);

	g_signal_connect (pLED-&gt;pLED, &quot;expose-event&quot;,  G_CALLBACK (APgtk_cb_LEDexpose), pLED);

	gtk_widget_show (pLED-&gt;pLED);

	return 0;
}

// destroys a button
void gtkAP_local_LEDDestroy (
		TAPgtkLED * 	pLED
	) {
	APgtk_helper_destroy(pLED-&gt;pLED);

	pLED-&gt;pLED = NULL;
	pLED-&gt;onFlag = 0;
	pLED-&gt;offColor[0] = 0.0;
	pLED-&gt;offColor[1] = 0.0;
	pLED-&gt;offColor[2] = 0.0;
	pLED-&gt;onColor[0] = 0.0;
	pLED-&gt;onColor[1] = 0.0;
	pLED-&gt;onColor[2] = 0.0;
}


// -------------------------------------------
// AP Display
// -------------------------------------------

// struct for a AP led
typedef struct SAPgtkDisplay {
	GtkWidget *		pD;				//!&lt; pointer to the display
	GtkWidget *		pF;				//!&lt; frame around the label
	int				charsPerLine;
	int				lineCount;
} TAPgtkDisplay;


// creates a AP display
int gtkAP_local_DisplayCreate (
		TAPgtkDisplay *	pD,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	pD-&gt;pD = NULL;
	pD-&gt;charsPerLine = 10;
	pD-&gt;lineCount = 4;

	pD-&gt;pD = gtk_label_new (&quot;&quot;);
	if (!pD-&gt;pD) return -1;
	pD-&gt;pF = gtk_frame_new(NULL);
	if (!pD-&gt;pF) return -2;

	//gtk_widget_set_size_request (pD-&gt;pD, xle-2, yle-2);
	gtk_widget_set_size_request (pD-&gt;pF, xle, yle);

	//gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pD-&gt;pD, x, y);
	gtk_fixed_put(GTK_FIXED(pP-&gt;pBox), pD-&gt;pF, x, y);
	gtk_container_add(GTK_CONTAINER(pD-&gt;pF), pD-&gt;pD);

	//gtk_widget_modify_font(gtk_bin_get_child (GTK_BIN(pD-&gt;pD)),gAPgtkMonoSpaceFont);
	gtk_widget_modify_font(pD-&gt;pD,gAPgtkMonoSpaceFont);

	/*
	// change colors
	GdkColor color;
	gdk_color_parse (&quot;yellow&quot;, &amp;color);
	gtk_widget_modify_fg (pD-&gt;pD, GTK_STATE_NORMAL, &amp;color);
	// background only works for the main wnd!
	gdk_color_parse (&quot;green&quot;, &amp;color);
	gtk_widget_modify_bg(pP-&gt;pWnd, GTK_STATE_NORMAL, &amp;color);
	 */

	gtk_widget_show (pD-&gt;pD);
	gtk_widget_show (pD-&gt;pF);

	return 0;
}

// destroys a display
void gtkAP_local_DisplayDestroy (
		TAPgtkDisplay * 	pD
	) {
	APgtk_helper_destroy(pD-&gt;pD);

	pD-&gt;pD = NULL;
	pD-&gt;charsPerLine = 10;
	pD-&gt;lineCount = 2;
}


// destroys a button
void gtkAP_local_DisplaySetText(
		TAPgtkDisplay * 	pD,
		char *				szTxt
	) {
	const char const cLF = 0xA;
	char szdummyBuffer[pD-&gt;lineCount*pD-&gt;charsPerLine+1];
	char * pC = szdummyBuffer;
	int x = 0;
	int y = 0;

	while (*szTxt) {
		// check if we have a line break
		if (*szTxt == cLF) {
			y++;
			x = 0;
			// check if we reached the end
			if (y == pD-&gt;lineCount) {
				*pC = 0;
				goto printLines;
			}
		}

		// copy char
		*pC = *szTxt;
		szTxt++;
		pC++;
		x++;

		// check if we reached the end of the line
		if (x == pD-&gt;charsPerLine) {
			y++;
			x=0;
			// check if we reached the end
			if (y &lt; pD-&gt;lineCount) {
				*pC = cLF;
				pC++;
			} else {
				*pC = 0;
				goto printLines;
			}
		}

	}
	*pC = 0;
printLines:
	gtk_label_set_text(GTK_LABEL(pD-&gt;pD),szdummyBuffer);
}

// ===========================================
// AP gtk+ interface
// ===========================================

enum eAPgtkActionID {
	eAPgtkActionID_exit				= 1,
	eAPgtkActionID_redrawUI			= 10,
	eAPgtkActionID_setDisplayText	= 11,
	eAPgtkActionID_createPanel		= 20,
	eAPgtkActionID_deletePanel		= 21,
	eAPgtkActionID_createButton		= 30,
	eAPgtkActionID_deleteButton		= 31,
	eAPgtkActionID_createLED		= 40,
	eAPgtkActionID_deleteLED		= 41,
	eAPgtkActionID_createDisplay	= 50,
	eAPgtkActionID_deleteDisplay	= 51,

};

typedef struct SAPgtk_command {
	sem_t		ps;			//!&lt; process finsh semaphore
	GMutex *	gm;			//!&lt; guarding mutex
	int			newCmdFlag;	//!&lt; is set to indicate that there is a new command

	int 		cmd; 		//!&lt; command
	void *		pData1;
	void *		pData2;
	int 		x;
	int			y;
	int			xle;
	int			yle;


} TAPgtk_command;


TAPgtk_command			gAPgtkMsg;
GThread *				gAPgtkThread;

void APgtk_setMsg (
		int		id,
		void *	pD1,
		void *	pD2,
		int		x,
		int		y,
		int		xle,
		int		yle
) {
	g_mutex_lock(gAPgtkMsg.gm);
	// set the command
	gAPgtkMsg.cmd = id;
	gAPgtkMsg.pData1 = pD1;
	gAPgtkMsg.pData2 = pD2;
	gAPgtkMsg.x = x;
	gAPgtkMsg.y = y;
	gAPgtkMsg.xle = xle;
	gAPgtkMsg.yle = yle;
	gAPgtkMsg.newCmdFlag = 1;
	g_mutex_unlock(gAPgtkMsg.gm);

	sem_wait(&amp;gAPgtkMsg.ps);
}

gpointer APgtk_threadFunc (gpointer Args) {
	// init gtk and bind it to the thread
	if (FALSE ==  gtk_init_check(NULL, NULL)) return ((gpointer)-1);

	gAPgtkMonoSpaceFont = pango_font_description_from_string(&quot;monospace&quot;);

	// process messages &amp; user actions
	for (;;) {
		// check for message
		g_mutex_lock(gAPgtkMsg.gm);
		if (gAPgtkMsg.newCmdFlag) {
			switch (gAPgtkMsg.cmd) {
				case eAPgtkActionID_exit:
					goto exit;
					break;
				case eAPgtkActionID_redrawUI:
					gtk_widget_queue_draw (GTK_WIDGET(gAPgtkMsg.pData1));
					break;

				case eAPgtkActionID_setDisplayText:
					gtkAP_local_DisplaySetText(gAPgtkMsg.pData1,gAPgtkMsg.pData2);
					break;

				case eAPgtkActionID_createPanel:
					gtkAP_local_PanelCreate (
							gAPgtkMsg.pData1,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deletePanel:
					gtkAP_local_PanelDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createButton:
					gtkAP_local_ButtonCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteButton:
					gtkAP_local_ButtonDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createLED:
					gtkAP_local_LEDCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteLED:
					gtkAP_local_LEDDestroy(gAPgtkMsg.pData1);
					break;

				case eAPgtkActionID_createDisplay:
					gtkAP_local_DisplayCreate(
							gAPgtkMsg.pData1,
							gAPgtkMsg.pData2,
							gAPgtkMsg.x,
							gAPgtkMsg.y,
							gAPgtkMsg.xle,
							gAPgtkMsg.yle
						);
					break;
				case eAPgtkActionID_deleteDisplay:
					gtkAP_local_DisplayDestroy(gAPgtkMsg.pData1);
					break;
			}
			gAPgtkMsg.newCmdFlag = 0;
			sem_post(&amp;gAPgtkMsg.ps);
		}
		g_mutex_unlock(gAPgtkMsg.gm);

		// message handling
		if (TRUE == gtk_events_pending ()) {
			gtk_main_iteration ();
		}

	}
	goto end;
exit:
	sem_post(&amp;gAPgtkMsg.ps);
	g_mutex_unlock(gAPgtkMsg.gm);
end:
	pango_font_description_free(gAPgtkMonoSpaceFont);
	gAPgtkMonoSpaceFont = NULL;
	return NULL;
}

int APgtk_start () {

	if (!g_thread_supported ()) g_thread_init (NULL);

	gAPgtkMsg.newCmdFlag = 0; // no cmd ready
	gAPgtkMsg.gm = g_mutex_new ();
	sem_init(&amp;gAPgtkMsg.ps,0,0);

	gAPgtkThread = g_thread_create(APgtk_threadFunc, NULL,TRUE, NULL);
	return 0;
}


void APgtk_end () {
	APgtk_setMsg(eAPgtkActionID_exit, NULL, NULL, 0, 0, 0, 0);
	g_thread_join(gAPgtkThread);
	g_mutex_free(gAPgtkMsg.gm);
	sem_destroy(&amp;gAPgtkMsg.ps);
}

// ----------------------------
// AP interface
// ----------------------------

// create a panel
int gtkAP_PanelCreate (
		TAPgtkPanel * 	pP,		//!&lt;(in/out) structure to be filled
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createPanel, pP, NULL, x, y, xle, yle);

	return(0);
}


// destroys a panel
void gtkAP_PanelDestroy (
		TAPgtkPanel * 	pP
	) {
	APgtk_setMsg (eAPgtkActionID_deletePanel, pP, NULL, 0,0,0,0);
}


// create a button
int gtkAP_ButtonCreate (
		TAPgtkButton * 	pB,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createButton, pB, pP, x, y, xle, yle);

	return(0);
}


// destroys a button
void gtkAP_ButtonDestroy (
		TAPgtkButton * 	pB
	) {
	APgtk_setMsg (eAPgtkActionID_deleteButton, pB, NULL, 0,0,0,0);
}

// create a LED
int gtkAP_LEDCreate (
		TAPgtkLED * 	pLED,	//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createLED, pLED, pP, x, y, xle, yle);

	return(0);
}


// destroys a LED
void gtkAP_LEDDestroy (
		TAPgtkLED * 	pLED
	) {
	APgtk_setMsg (eAPgtkActionID_deleteLED, pLED, NULL, 0,0,0,0);
}


// create a display
int gtkAP_DisplayCreate (
		TAPgtkDisplay * pD,		//!&lt;(in/out) structure to be filled
		TAPgtkPanel * 	pP,		//!&lt;(in) panel witch holds the button
		int				x,		//!&lt;(in) x position of the window
		int				y,		//!&lt;(in) y position of the window
		int				xle,	//!&lt;(in) x length of the window
		int				yle		//!&lt;(in) x length of the window
	) {

	APgtk_setMsg (eAPgtkActionID_createDisplay, pD, pP, x, y, xle, yle);

	return(0);
}


// destroys a display
void gtkAP_DisplayDestroy (
		TAPgtkDisplay * 	pD
	) {
	APgtk_setMsg (eAPgtkActionID_deleteDisplay, pD, NULL, 0,0,0,0);
}

// destroys a display
void gtkAP_DisplaySetText (
		TAPgtkDisplay * 	pD,
		char *				pT
	) {
	APgtk_setMsg (eAPgtkActionID_setDisplayText, pD, pT, 0,0,0,0);
}


// ===========================================
// AP gtk general types and interface
// ===========================================

// AP gtk+ type enums
enum eAPgtkUItypes {
	eAPgtkUItype_unknown	= 0,
	eAPgtkUItype_panel		= 1,
	eAPgtkUItype_button		= 2,
	eAPgtkUItype_LED		= 3,
	eAPgtkUItype_display	= 4
};

// AP UI type
typedef struct SAPgtkUI {
	int		uuid;
	int 	x;
	int		y;
	int		xle;
	int		yle;
	int		typeID;
	union 	uAPgtkUI {
		TAPgtkPanel		panel;
		TAPgtkButton	button;
		TAPgtkDisplay	display;
		TAPgtkLED		led;
	} ui;
} TAPgtkUI;

// set the coordinates of the ui
void APgtkUI_setCoordinates (
		TAPgtkUI *	pUI,
		int 		x,
		int			y,
		int			xle,
		int			yle
	) {
	pUI-&gt;x = x;
	pUI-&gt;y = y;
	pUI-&gt;xle = xle;
	pUI-&gt;yle = yle;
}

// creates visible ui
int APgtkUI_createUI (
		TAPgtkUI *	pUI,
		TAPgtkUI *	pParentUI,
		int			uuid,
		int			typeID
	) {
	pUI-&gt;typeID = typeID;
	pUI-&gt;uuid = uuid;
	switch (typeID) {
		case eAPgtkUItype_panel:
			return gtkAP_PanelCreate(
					&amp;(pUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_button:
			return gtkAP_ButtonCreate(
					&amp;(pUI-&gt;ui.button),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_LED:
			return gtkAP_LEDCreate(
					&amp;(pUI-&gt;ui.led),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
		case eAPgtkUItype_display:
			return gtkAP_DisplayCreate(
					&amp;(pUI-&gt;ui.display),
					&amp;(pParentUI-&gt;ui.panel),
					pUI-&gt;x,
					pUI-&gt;y,
					pUI-&gt;xle,
					pUI-&gt;yle
				);
	}
	return -100;
}

// destroy visible ui
void APgtkUI_destroyUI (
		TAPgtkUI *	pUI
	) {
	switch (pUI-&gt;typeID) {
		case eAPgtkUItype_panel:
			gtkAP_PanelDestroy(&amp;(pUI-&gt;ui.panel));
			break;
		case eAPgtkUItype_button:
			gtkAP_ButtonDestroy(&amp;(pUI-&gt;ui.button));
			break;
		case eAPgtkUItype_LED:
			gtkAP_LEDDestroy(&amp;(pUI-&gt;ui.led));
			break;
		case eAPgtkUItype_display:
			gtkAP_DisplayDestroy(&amp;(pUI-&gt;ui.display));
			break;
	}
	pUI-&gt;typeID = eAPgtkUItype_unknown;
	pUI-&gt;uuid = 0;
}

// redraws a ui
void APgtkUI_redrawUI (
		TAPgtkUI *	pUI
	) {
	switch (pUI-&gt;typeID) {
		case eAPgtkUItype_panel:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.panel.pWnd, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_button:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.button.pB, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_LED:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.led.pLED, NULL, 0,0,0,0);
			break;
		case eAPgtkUItype_display:
			APgtk_setMsg (eAPgtkActionID_redrawUI, pUI-&gt;ui.display.pD, NULL, 0,0,0,0);
			break;
	}
}


// AP UI array type
typedef struct SAPgtkUIvector {
	TAPgtkUI * 	pUI;
	int			number;
} TAPgtkUIvector;


TAPgtkUIvector * APgtkUI_createVector (
		int number,
		int uiType
	) {
	TAPgtkUIvector * 	pV;
	int					i;

	pV = malloc (sizeof(TAPgtkUIvector));
	if (!pV) return NULL;
	pV-&gt;pUI = malloc (sizeof(TAPgtkUI)*number);
	if (!pV-&gt;pUI) {
		free (pV);
		return NULL;
	}
	memset (pV-&gt;pUI,0,sizeof(TAPgtkUI)*number);

	pV-&gt;number = number;
	for (i = 0; i &lt; number; i++) {
		pV-&gt;pUI[i].typeID = uiType;
	}

	return pV;
}

void APgtkUI_destroyVector (
		TAPgtkUIvector * pUIv
	) {
	int i;
	for (i = 0; i &lt; pUIv-&gt;number; i++) {
		APgtkUI_destroyUI(&amp;(pUIv-&gt;pUI[i]));
	}
	free (pUIv-&gt;pUI);;
	free (pUIv);
}
</Code><Code idCode="163">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter xPos descr: x position in pixel
	int32_t* pxPos = &amp;( pParams[0].fp_integer);
// parameter yPos descr: y position in pixel
	int32_t* pyPos = &amp;( pParams[1].fp_integer);
// parameter xLen descr: x width
	int32_t* pxLen = &amp;( pParams[2].fp_integer);
// parameter yLen descr: y height
	int32_t* pyLen = &amp;( pParams[3].fp_integer);
// parameter uiVar descr: UI element
	TAPInterpreterVariable ** puiVar = &amp;( pParams[4].fp_pV);
};
</Code><Code idCode="164">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="165">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter b descr: button
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="166">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter d descr: display
	void ** pd = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="167">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter l descr: LED
	void ** pl = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="168">// ===============================
// variable implementation for pannel UI(var id = 100)
// ===============================

// transmit the data
void HALimpl_100_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_100_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_100_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_100_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
return NULL;
}
// fill the frame with data
void HALimpl_100_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {

}
</Code><Code idCode="169">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

// transmit the data
void HALimpl_101_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_101_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_101_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_101_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_button);
}
// fill the frame with data
void HALimpl_101_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="170">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

// transmit the data
void HALimpl_102_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_102_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_102_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_102_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_LED);
}
// fill the frame with data
void HALimpl_102_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="171">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

// transmit the data
void HALimpl_103_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_103_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_103_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_103_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_display);
}
// fill the frame with data
void HALimpl_103_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="172">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter xPos descr: x position in pixel
	int32_t xPos = pParams[0].fp_integer;
// parameter yPos descr: y position in pixel
	int32_t yPos = pParams[1].fp_integer;
// parameter xLen descr: x width
	int32_t xLen = pParams[2].fp_integer;
// parameter yLen descr: y height
	int32_t yLen = pParams[3].fp_integer;
// parameter ui descr: UI element
	TAPgtkUIvector * puiVec = (TAPgtkUIvector *) pParams[4].fp_pV;
// parameter uiIndex descr: UI element index
	int32_t uiIndex = pParams[5].fp_integer;
	
	APgtkUI_setCoordinates (
			&amp;(puiVec-&gt;pUI[uiIndex]),
			xPos,
			yPos,
			xLen,
			yLen
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="173">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[1].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[2].fp_integer);
};
</Code><Code idCode="174">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter b descr: button
	void ** pb = &amp;( pParams[1].fp_pD);
// parameter bIndex descr: button index
	int32_t* pbIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="175">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter d descr: display
	void ** pd = &amp;( pParams[1].fp_pD);
// parameter dIndex descr: display index
	int32_t* pdIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="176">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t* puiUUID = &amp;( pParams[0].fp_integer);
// parameter l descr: LED
	void ** pl = &amp;( pParams[1].fp_pD);
// parameter lIndex descr: LED index
	int32_t* plIndex = &amp;( pParams[2].fp_integer);
// parameter p descr: pannel
	void ** pp = &amp;( pParams[3].fp_pD);
// parameter pIndex descr: pannel index
	int32_t* ppIndex = &amp;( pParams[4].fp_integer);
};
</Code><Code idCode="177">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter p descr: pannel
	TAPgtkUIvector * puiVec = (TAPgtkUIvector *) pParams[1].fp_pD;
// parameter pIndex descr: pannel index
	int32_t pIndex = pParams[2].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiVec-&gt;pUI[pIndex]),
			NULL,
			uiUUID,
			eAPgtkUItype_panel
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="178">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter b descr: button
	TAPgtkUIvector * puiB = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiB-&gt;pUI[bIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_button
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="179">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the panel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter b descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter bIndex descr: display index
	int32_t dIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiD-&gt;pUI[dIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_display
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="180">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t uiUUID = pParams[0].fp_integer;
// parameter l descr: LED
	TAPgtkUIvector * puiL = (TAPgtkUIvector *)  pParams[1].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TAPgtkUIvector * puiP = (TAPgtkUIvector *) pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if (APgtkUI_createUI (
			&amp;(puiL-&gt;pUI[lIndex]),
			&amp;(puiP-&gt;pUI[pIndex]),
			uiUUID,
			eAPgtkUItype_LED
		)
	) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -10;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="181">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

// transmit the data
void HALimpl_100_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_100_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_100_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_100_initEnd (void * pVarData) {

}
// fill the frame with data
void HALimpl_100_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_panel);
}

// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="182">// ===============================
// function implementation for uiCheckButtonPressed(var id = 210)
// description: if the button was pressed the CF is set
// ===============================

void HALfunc_ID210_uiCheckButtonPressed(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter b descr: button
	TAPgtkUIvector * puiB = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[1].fp_integer;
// parameter p descr: panel

	if (puiB-&gt;pUI[bIndex].ui.button.pressCounter) {
		puiB-&gt;pUI[bIndex].ui.button.pressCounter--;
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="183">// ===============================
// function implementation for uiSetLED(var id = 211)
// description: set the LED state
// ===============================

void HALfunc_ID211_uiSetLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter l descr: LED
	TAPgtkUIvector * puiL = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[1].fp_integer;
// parameter onFlag descr: if the flag is not zero the LED is turned on
	int32_t  onFlag = pParams[2].fp_integer;

	puiL-&gt;pUI[lIndex].ui.led.onFlag = (!onFlag) ? 0 : 1;
	APgtkUI_redrawUI(&amp;(puiL-&gt;pUI[lIndex]));
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="184">// ===============================
// function implementation for jumpCF(var id = 51)
// description: jumps if the carry flag is set n instructions
// ===============================

void HALfunc_ID51_jumpCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (((TAPInterpreterCPU *)pIPcpu)-&gt;CF) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="185">// ===============================
// function implementation for jumpNCF(var id = 52)
// description: jumps if the carry flag is not set n instructions
// ===============================

void HALfunc_ID52_jumpNCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (!((TAPInterpreterCPU *)pIPcpu)-&gt;CF) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP += pParams[0].fp_integer;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="186">// ===============================
// function implementation for setCF(var id = 55)
// description: sets the carry flag
// ===============================

void HALfunc_ID55_setCF(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter value descr: the value of the CF
	if (pParams[0].fp_integer) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="187">// --------------------------------------
// TAPstringVector
// --------------------------------------

// ap string
typedef struct SAPstring {
	char *	szTxt;	//!&lt; pointer to char buffer
	size_t	maxLen;	//!&lt; length of the char buffer(without the zero at the end)
} TAPstring;

// vector of strings type
typedef struct SAPstringVector {
	TAPstring *		sv;		//!&lt; string vector
	unsigned int	num;	//!&lt; amount of strings at the vector
} TAPstringVector;

// creates a AP string
TAPstringVector * APstringVector_create (
		int		num		//!&lt;(in) number of strings at the vector
	) {
	TAPstringVector * pR;
	int i;

	pR = malloc(sizeof(TAPstringVector));
	if (!pR) return NULL;
	pR-&gt;sv = malloc(sizeof(TAPstring)*num);
	if (!pR-&gt;sv){
		free (pR);
		return NULL;
	}
	// init str
	TAPstring * ps = pR-&gt;sv;
	for (i = 0; i &lt; num; i++) {
		ps-&gt;szTxt = NULL;
		ps-&gt;maxLen = 0;
		ps++;
	}
	pR-&gt;num = num;
	return pR;
}

// frees a AP string
void APstringVector_free (
		TAPstringVector * 	pSV	//!&lt;(in) pointer to the string vector
	) {
	unsigned int i;
	if (pSV-&gt;sv) {
		TAPstring * ps = pSV-&gt;sv;
		for (i = 0; i &lt; pSV-&gt;num; i++) {
			if (ps-&gt;szTxt){
				free(ps-&gt;szTxt);
			}
		}
		free(pSV-&gt;sv);
	}
	free(pSV);
}

// resizes the amount of strings at the string vector
int APstringVector_resizeVector (
		TAPstringVector * 	pSV,	//!&lt;(in) pointer to the string vector
		int					num		//!&lt;(in) number of strings at the vector
	) {
	if (pSV-&gt;num == num) return 0;
	unsigned int	i;
	TAPstring * 	ps;

	if (pSV-&gt;sv) {
		ps = pSV-&gt;sv;
		for (i = 0; i &lt; pSV-&gt;num; i++) {
			if (ps-&gt;szTxt){
				free(ps-&gt;szTxt);
			}
		}
		free(pSV-&gt;sv);
	}
	pSV-&gt;sv = malloc(sizeof(TAPstring)*num);
	if (!pSV-&gt;sv){
		return -1;
	}
	// init str
	ps = pSV-&gt;sv;
	for (i = 0; i &lt; num; i++) {
		ps-&gt;szTxt = NULL;
		ps-&gt;maxLen = 0;
		ps++;
	}
	pSV-&gt;num = num;
	return 0;
}

// resizes a string at the vector
int APstringVector_resize (
		TAPstringVector * 	pSV,	//!&lt;(in) pointer to the string vector
		int					index,	//!&lt;(in) index of the string at the stringarray
		size_t				newLen	//!&lt;(in) new length of the string
	) {
	TAPstring * ps = pSV-&gt;sv + index;
	if (ps-&gt;maxLen &lt; newLen) {
		// allocate new string
		char * nsz = malloc(sizeof(char) * (newLen +1));
		if (!nsz) return -1;
		if (ps-&gt;szTxt) {
			// copy old string
			strcpy(nsz,ps-&gt;szTxt);
			// release old string
			free(ps-&gt;szTxt);
			ps-&gt;szTxt = NULL;
		} else {
			*nsz = 0;
		}
		// set the new string
		ps-&gt;szTxt =nsz;
		// remember the length
		ps-&gt;maxLen = newLen;
	} else {
		if(ps-&gt;szTxt) {
			// trail old string
			ps-&gt;szTxt[newLen] = 0;
		}
	}
	return 0;
}

// fills the string from an extern source
void APstringVector_fill(
		TAPstringVector * 	pSV,	//!&lt;(in) pointer to the string vector
		int					index,	//!&lt;(in) index of the string at the stringarray
		int					iStart,	//!&lt;(in) start index at the string
		int					iEnd,	//!&lt;(in) end index of the string
		char *				pSource	//!&lt;(in) source from where the chars are copied
	) {
	int i, imax;
	char * pDest = pSV-&gt;sv[index].szTxt;
	pDest += iStart;
	// clip str
	imax = pSV-&gt;sv[index].maxLen;
	if (iEnd &gt; imax) {
		iEnd = imax;
	}

	for (i = iStart;i &lt; iEnd; i++) {
		*pDest = *pSource;
		pDest++;
		pSource++;
	}
	*pDest = 0;
}


// concat string 2 with string 1
int APstringVector_concat(
		TAPstringVector * 	pSV1,		//!&lt;(in) pointer to the first string vector
		int					indexSV1,	//!&lt;(in) index of the string at the stringarray
		TAPstringVector * 	pSV2,		//!&lt;(in) pointer to the second string vector
		int					indexSV2	//!&lt;(in) index of the string at the stringarray
	) {
	TAPstring * ps1 = pSV1-&gt;sv + indexSV1;
	TAPstring * ps2 = pSV2-&gt;sv + indexSV2;
	// get new size
	size_t sl1;
	size_t sl2;
	sl1 = ps1-&gt;szTxt ? strlen(ps1-&gt;szTxt) : 0;
	sl2 = ps2-&gt;szTxt ? strlen(ps2-&gt;szTxt) : 0;
	size_t newL = sl1 + sl2;
	// reallocate?
	if (ps1-&gt;maxLen &lt; newL) {
		if (APstringVector_resize(pSV1, indexSV1, newL)) return -1;
	}
	// copy string 2 at the end of string 1
	strcpy(ps1-&gt;szTxt + sl1,ps2-&gt;szTxt);

	return 0;
}


// assigns string 2 to string 1
int APstringVector_assign(
		TAPstringVector * 	pSV1,		//!&lt;(in) pointer to the first string vector
		int					indexSV1,	//!&lt;(in) index of the string at the stringarray
		TAPstringVector * 	pSV2,		//!&lt;(in) pointer to the second string vector
		int					indexSV2	//!&lt;(in) index of the string at the stringarray
	) {
	TAPstring * ps1 = pSV1-&gt;sv + indexSV1;
	TAPstring * ps2 = pSV2-&gt;sv + indexSV2;
	// get new size
	size_t sl2 = strlen(ps2-&gt;szTxt);
	// reallocate?
	if (ps1-&gt;maxLen &lt; sl2) {
		if (APstringVector_resize(pSV1, indexSV1, sl2)) return -1;
	}
	// copy string 2 at the end of string 1
	strcpy(ps1-&gt;szTxt,ps2-&gt;szTxt);

	return 0;
}


// print a floating point number into the string
void APstringVector_printFloat(
		TAPstringVector * 	pSV,			//!&lt;(in) pointer to the first string vector
		int					indexSV,		//!&lt;(in) index of the string at the stringarray
		float				number			//!&lt;(in) number to be printed
	) {
	TAPstring * ps = pSV-&gt;sv + indexSV;
	snprintf(ps-&gt;szTxt, ps-&gt;maxLen+1, &quot;%f&quot;, (double)number);
}

// print a integer number into the string
void APstringVector_printInt(
		TAPstringVector * 	pSV,			//!&lt;(in) pointer to the first string vector
		int					indexSV,		//!&lt;(in) index of the string at the stringarray
		int					number			//!&lt;(in) number to be printed
	) {
	TAPstring * ps = pSV-&gt;sv + indexSV;
	snprintf(ps-&gt;szTxt, ps-&gt;maxLen+1, &quot;%i&quot;, number);
}
</Code><Code idCode="188">// ===============================
// variable implementation for a string(var id = 3)
// ===============================

// transmit the data
void HALimpl_3_init (void * pVarData, int frameNumber, void * pData) {

}
// start the init process
void HALimpl_3_initStart (void * pVarData, int frameNumber, int bigEndian) {

}
// get the frame Number and size
int HALimpl_3_frameGetNumber (void * pVarData, int * pframeSize) {
return 0;
}
// end init process
void HALimpl_3_initEnd (void * pVarData) {

}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
	return APstringVector_create((int)numberOfElements);
}
// fill the frame with data
void HALimpl_3_frameFill (void * pVarData, int frameNumber, void * pFrame) {

}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="189">// ===============================
// function implementation for setStringSize(var id = 5)
// description: resets the size of a string
// ===============================

void HALfunc_ID5_setStringSize(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int32_t i = pParams[1].fp_integer;
// parameter length descr: length of the string
	int32_t length = pParams[2].fp_integer;

	if (APstringVector_resize(pSV,(int) i, length)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="190">// ===============================
// function implementation for setStringValues(var id = 6)
// description: set the string
// ===============================

void HALfunc_ID6_setStringValues(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[0].fp_pV;
// parameter i descr: index of the string at the array
	int i = (int) pParams[1].fp_integer;
// parameter p descr: position at the string where to start from
	int p = (int) pParams[2].fp_integer;

	char * pSrc =(char *) &amp;pParams[3].fp_raw;

	int pe = p + (dAPInterpreterFuncMaxParams-3) * sizeof(int32_t);
	
	APstringVector_fill(pSV,i,p,pe,pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="191">// ===============================
// function implementation for uiSetDisplay(var id = 212)
// description: set the text of a display
// ===============================

void HALfunc_ID212_uiSetDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	TAPgtkUIvector * puiD = (TAPgtkUIvector *)  pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter s descr: the string
	TAPstringVector * pSV = (TAPstringVector *) pParams[2].fp_pD;
// parameter iString descr: index of the string at the array
	int32_t iString = pParams[3].fp_integer;

	gtkAP_DisplaySetText (
			&amp;(puiD-&gt;pUI[dIndex].ui.display),
			pSV-&gt;sv[iString].szTxt
		);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="192">// ===============================
// variable implementation for a string(var id = 3)
// ===============================

// updates a variable the AP
int HALimpl_3_recvUpdate (void * pVarData, void * pMsg) {
	int32_t *			pD = (int32_t *) pMsg;
	TAPstringVector *	pSV = pVarData;
	TAPstring *			ps;
	int					i, num,imax;

	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	//1. get amount of strings at the string vector
	APendianConversation32Bit((uint32_t *)pD,eAP_littleEndian);
	num = (int) *pD;

	if (APstringVector_resizeVector(pSV,num)) {
		return -1;
	}

	pD++;
	ps = pSV-&gt;sv;
	//2. resize and fill the strings
	for (i = 0; i &lt; num; i++) {
		// get length
		APendianConversation32Bit((uint32_t *)pD,eAP_littleEndian);
		if (APstringVector_resize(pSV,i,(size_t)*pD)) {
			return -2;
		}
		imax = (int) *pD;
		pD++;
		for (i = 0;i &lt;imax; i++)  {
			ps-&gt;szTxt[i] = (char) *pD;
			pD++;
		}
		ps-&gt;szTxt[i] = 0;
		ps++;
	}
	return 0;
}
// create a new variable
void * HALimpl_3_create (unsigned int numberOfElements) {
	return APstringVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_3_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	// msgdata = (stringAmount)[(strlen)(string + fill byes), ...]
	// some vars
	unsigned int		indx;
	int 				stl;
	TAPstring * 		ps;
	TAPstringVector * 	pSV = (TAPstringVector *)pVarData;
	TAPMsgDrv * 		pMD = (TAPMsgDrv *) pDrv;
	int32_t 			uint32Amount = 1; // vector size
	int32_t				sendVal;
	char *				psz;
	// ok get the size of the message
	ps = pSV-&gt;sv;
	for (indx = 0;indx &lt; pSV-&gt;num; indx++) {
		// one element for the length
		uint32Amount++;
		// the string data
		stl = ps-&gt;szTxt ? strlen(ps-&gt;szTxt) : 0;
		uint32Amount+=stl;
		// next string
		ps++;
	}
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, uint32Amount);
	// send amount of elements
	sendVal = (int32_t) pSV-&gt;num;
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
	ps = pSV-&gt;sv;
	for (indx = 0; indx &lt; pSV-&gt;num; indx++) {
		if (ps-&gt;szTxt) {
			// get length
			sendVal = (int32_t) strlen(ps-&gt;szTxt);
			// send length
			pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
			// send string
			psz = ps-&gt;szTxt;
			while (*psz) {
				sendVal = (int32_t) *psz;
				pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
				psz++;
			}
		} else {
			sendVal = 0;
			// send length
			pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;sendVal);
		}
		ps++;
	}
	return 0;
}
// decode data for the HAL functions
void * HALimpl_3_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_3_delete (void * pVarData) {
	APstringVector_free(pVarData);
}
</Code><Code idCode="193">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

// updates a variable the AP
int HALimpl_100_recvUpdate (void * pVarData, void * pMsg) {
	return -1;
}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_panel);
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="194">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

// updates a variable the AP
int HALimpl_101_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_button);
}

// updates the vars at the other APs
int HALimpl_101_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}</Code><Code idCode="195">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

// updates a variable the AP
int HALimpl_102_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_LED);
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}
</Code><Code idCode="196">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

// updates a variable the AP
int HALimpl_103_recvUpdate (void * pVarData, void * pMsg) {
return -1;
}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	return APgtkUI_createVector(numberOfElements, eAPgtkUItype_display);
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	APgtkUI_destroyVector(pVarData);
}</Code><Code idCode="197">// ===============================
// function implementation for assignConstInteger(var id = 20)
// description: a = values
// ===============================

void HALfunc_ID20_assignConstInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter iv descr: integer vector
	TAPgenericIntegerVector * piv = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter iStart descr: start index
	int32_t iStart = pParams[1].fp_integer;
// parameter num descr: number of values
	int32_t num = pParams[2].fp_integer;

	int32_t * pSrc =(int32_t *) &amp;pParams[3].fp_raw;

	APgenericIntegerVector_assignConst(piv, (int)iStart, (int)num, pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="198">// ===============================
// function implementation for assignInteger(var id = 21)
// description: a = b
// ===============================

void HALfunc_ID21_assignInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;

	APgenericIntegerVector_assign(pa, pb);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="199">// ===============================
// function implementation for addInteger(var id = 22)
// description: c = a + b
// ===============================

void HALfunc_ID22_addInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_add(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="200">// ===============================
// function implementation for subInteger(var id = 23)
// description: c = a - b
// ===============================

void HALfunc_ID23_subInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_sub(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="201">// ===============================
// function implementation for mulInteger(var id = 24)
// description: c = a * b
// ===============================

void HALfunc_ID24_mulInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_mul(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="202">// ===============================
// function implementation for divInteger(var id = 25)
// description: c = a / b
// ===============================

void HALfunc_ID25_divInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_div(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="203">// ===============================
// function implementation for modInteger(var id = 26)
// description: c = mod(a,b)
// ===============================

void HALfunc_ID26_modInteger(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericIntegerVector* pb = (TAPgenericIntegerVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericIntegerVector* pc = (TAPgenericIntegerVector *)pParams[2].fp_pD;

	APgenericIntegerVector_mod(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="204">// ===============================
// function implementation for comparaIntegerLess(var id = 40)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID40_comparaIntegerLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="205">// ===============================
// function implementation for comparaIntegerMore(var id = 41)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID41_comparaIntegerMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="206">// ===============================
// function implementation for comparaIntegerEqual(var id = 42)
// description: a == b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID42_comparaIntegerEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="207">// ===============================
// function implementation for comparaIntegerNEqual(var id = 43)
// description: a != b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID43_comparaIntegerNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="208">// ===============================
// function implementation for comparaIntegerLessEqual(var id = 44)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID44_comparaIntegerLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="209">// ===============================
// function implementation for comparaIntegerMoreEqual(var id = 45)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID45_comparaIntegerMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: left side number
	void ** pa = &amp;( pParams[0].fp_pD);
// parameter b descr: right side number
	void ** pb = &amp;( pParams[1].fp_pD);
};
</Code><Code idCode="210">// ===============================
// variable implementation for a integer number(var id = 2)
// ===============================

// updates a variable the AP
int HALimpl_2_recvUpdate (void * pVarData, void * pMsgData) {
	uint32_t * pD = (uint32_t *) pMsgData;
	TAPgenericIntegerVector * pIV = pVarData;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	int imax = (int) *((int32_t *)pD);

	int i;

	if (APgenericIntegerVector_resize(pIV,imax)) {
		return -1;
	}

	pD++;

	for (i = 0; i &lt; imax; i++) {
		APendianConversation32Bit(pD,eAP_littleEndian);
		pIV-&gt;pVal[i] = *((int32_t *)pD);
		pD++;
	}
	return 0;
}

// create a new variable
void * HALimpl_2_create (unsigned int numberOfElements) {
	return APgenericIntegerVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_2_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	TAPgenericIntegerVector * pIV = pVarData;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	int32_t dataAmount = 1 + pIV-&gt;num;
	int32_t dummy;
	int indx;
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	// send amount of elements
	dummy = (int32_t) pIV-&gt;num;
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;dummy);
	// send elements
	for (indx = 0; indx &lt; pIV-&gt;num; indx++) {
		pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pIV-&gt;pVal[indx]);
	}
	return 0;
}
// decode data for the HAL functions
void * HALimpl_2_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_2_delete (void * pVarData) {
	APgenericIntegerVector_destroy(pVarData);
}
</Code><Code idCode="211">// ===============================
// function implementation for comparaIntegerLess(var id = 40)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID40_compareIntegerLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="212">// ===============================
// function implementation for comparaIntegerMore(var id = 41)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID41_compareIntegerMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="213">// ===============================
// function implementation for comparaIntegerEqual(var id = 42)
// description: a == b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID42_compareIntegerEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) == 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="214">// ===============================
// function implementation for comparaIntegerNEqual(var id = 43)
// description: a != b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID43_compareIntegerNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) != 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="215">// ===============================
// function implementation for comparaIntegerLessEqual(var id = 44)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID44_compareIntegerLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="216">// ===============================
// function implementation for comparaIntegerMoreEqual(var id = 45)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================

void HALfunc_ID45_compareIntegerMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: a vector
	TAPgenericIntegerVector * pa = (TAPgenericIntegerVector *) pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: b vector
	TAPgenericIntegerVector * pb = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericIntegerVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="217">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter var descr: the variable
	TAPInterpreterVariable ** pvar = &amp;( pParams[0].fp_pV);
};
</Code><Code idCode="218">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter var descr: the variable
	TAPInterpreterVariable ** pvar = &amp;( pParams[0].fp_pV);
// parameter varIndex descr: the variable index
	int* pvarIndex = &amp;( pParams[1].fp_VarIndex);
};
</Code><Code idCode="219">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,IP,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}



// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="220">// ===============================
// function implementation for update(var id = 56)
// description: updates a global variable
// ===============================

void HALfunc_ID56_update(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	if (TX_updateVariable(APInterpreterGetAPfromIP(((TAPInterpreterCPU *)pIPcpu)-&gt;IP),(uint32_t)pParams[0].fp_VarIndex)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -100;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="221">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,IP,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="222">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="223">// ===============================
// driver uuid =1
// ===============================
// ------------------------------
// drv own functions
// ------------------------------

#define dAPClientServerAdminPort (50000)
#define dAPClientInitBuffer (1024)

// struct for the drv data
typedef struct SAPTCPIPdrv {
	TAPClient 					cl;			//!&lt; tcp/ip client
	TAPMsgHeader				txHeader;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TAPTCPIPdrv;

// ------------------------------
// drv own functions
// ------------------------------

int drv_1_sendHeader (
		TAPClient * pCl,
		uint32_t * pH,
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	pH[eAPMsgHeaderPosition_msgTypeID] = msgId;
	pH[eAPMsgHeaderPosition_msgNumber] = num;
	pH[eAPMsgHeaderPosition_receiver] = recv;
	pH[eAPMsgHeaderPosition_length] = length;
	if (APclient_send(pCl,sizeof(TAPMsgHeader),(uint8_t *)pH)) return -1;
	return 0;
}

// call back function of the TCP/IP driver
int drv_1_cbAPClient (void *pvDC, uint16_t number, uint8_t * pData) {
	TAPReceiveStateMachine * pSM = pvDC;
	return pSM-&gt;state (pSM, (uint32_t *) pData, number / sizeof(uint32_t));
}

//open an existing driver and bind it to the AP
int drv_1_open (void * pAP, struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = NULL;

	pDC = malloc(sizeof(TAPTCPIPdrv));
	if (!pDC) return -1;
	if (APclient_create(&amp;(pDC-&gt;cl),dAPClientServerAdminPort,dAPClientInitBuffer,&amp;(pDC-&gt;rxSM),drv_1_cbAPClient)) return -2;
	// init header
	pDC-&gt;txHeader[eAPMsgHeaderPosition_endian] = (uint32_t) gAPendianFlag;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgTypeID] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_msgNumber] = 0;
	pDC-&gt;txHeader[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = pDC;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;pDC-&gt;rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}
//close the driver
int drv_1_close (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		APclient_close(&amp;pDC-&gt;cl);
	}
	return 0;
}
//destroys the driver
int drv_1_destroy (struct SAPMsgDrv *pDrv) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	if (pDC) {
		free(pDC);
		pDrv-&gt;pDrvData = NULL;
	}
	return 0;
}

//sends raw data
int drv_1_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t * pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);
	return APclient_send(&amp;(pDC-&gt;cl),amount*sizeof(uint32_t),(uint8_t *)pData);
}

//a AP is going to be logged out of the system
int drv_1_sendInteger32 (struct SAPMsgDrv *pDrv, int amount, int32_t * pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);

	if (gAPendianFlag == eAP_littleEndian) {
		return APclient_send(&amp;(pDC-&gt;cl),amount*sizeof(uint32_t),(uint8_t *)pData);
	} else {
		int i;
		int32_t v;
		for (i = 0; i &lt; amount; i++) {
			v = *pData;
			APendianConversation32Bit((uint32_t *)&amp;v,eAP_littleEndian);
			if (APclient_send(&amp;(pDC-&gt;cl),sizeof(int32_t),(uint8_t *)&amp;v)) {
				return -1;
			}
			pData++;
		}
	}
	return 0;
}

//a AP is going to be logged out of the system
int drv_1_sendFloat32 (struct SAPMsgDrv *pDrv, int amount, float * pData) {
	TAPTCPIPdrv * pDC = (TAPTCPIPdrv *)(pDrv-&gt;pDrvData);

	return APclient_send(&amp;(pDC-&gt;cl),amount*sizeof(float),(uint8_t *)pData);
}



//acknowledge
int drv_1_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_ACK, receiver, mNum, 0);
}
//not acknowledge
int drv_1_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_NACK, receiver, mNum, 0);
}
//start sending a program
int drv_1_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_startPrg, receiver, mNum, 0) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;globalVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;localVariableNumber) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;instructionNumber)
		) return -10;
	return 0;
}

//sends a variable
int drv_1_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendVariable, receiver, mNum, 3) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;varTypeID) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;num)
		) return -10;
	return 0;
}
//sends an instruction
int drv_1_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;index) ||
			APclient_send(pCl,sizeof(int32_t)*dAPInterpreterFuncMaxParams,(uint8_t *)fbc)
		) return -10;
	return 0;
}
//sings that the program transmission has completed
int drv_1_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_endPrg, receiver, mNum, 0);
}
//stops the AP
int drv_1_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_stop, receiver, mNum, 0);
}
//the AP executes one instruction
int drv_1_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_step, receiver, mNum, 0);
}
//the AP runs the program
int drv_1_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_run, receiver, mNum, 0);
}
//a variable going to be updated
int drv_1_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;
	if (
			drv_1_sendHeader(pCl, pH, eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1) ||
			APclient_send(pCl,sizeof(int32_t),(uint8_t *)&amp;gIndex)
		) return -10;
	return 0;
}
//a AP is going to be logged in to the system
int drv_1_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_login, receiver, mNum, 0);
}
//a AP is going to be logged out of the system
int drv_1_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	TAPClient * pCl = &amp;((TAPTCPIPdrv *)(pDrvData))-&gt;cl;
	uint32_t * pH = ((TAPTCPIPdrv *)(pDrvData))-&gt;txHeader;

	return drv_1_sendHeader(pCl, pH, eAPMsgTypes_logout, receiver, mNum, 0);
}
</Code><Code idCode="224">// ===============================
// driver uuid =2
// ===============================

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	return 0;
}
//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}
//send raw data
int drv_2_sendRaw (struct SAPMsgDrv *pDrv, int amount, void *pData) {
	return 0;
}
//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	return 0;
}
//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	return 0;
}
</Code><Code idCode="225">// ===============================
// AP uuid = 10
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			// filter ack/nack msg
			if (ackMsgAllowed) {
				msgIDok = 1;
			} else {
				if (
						(*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
						(*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
					) {
					msgIDok = 1;
				}
			}
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}
		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	if (!pMS-&gt;messagecounter) {
		sem_wait(&amp;pMS-&gt;waitSem);
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="226">// ===============================
// AP uuid = 10
// ===============================


// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	gAPendianFlag = sysEndian;

	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (int elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, int elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	APendianConversation32Bit((uint32_t *)&amp;state,msgEndian);
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	APendianConversation32Bit((uint32_t *)&amp;instructionsNumber, msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;VariableNumber, msgEndian);

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);
	APendianConversation32Bit((uint32_t *)&amp;varTypeID,msgEndian);


	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APendianConversation32Bit((uint32_t *)&amp;index,msgEndian);

	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	APendianConversation32Bit((uint32_t *)&amp;fid,msgEndian);

	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	// we go for shure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i],msgEndian);
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="227">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

int main()
{
	error msp430 code
	TAP AP;
	int rc;

	TAPMsgDrv UARTdrv;

	msp430_start();

	APdrviver_3_init(&amp;UARTdrv);

	rc = APinit(&amp;AP,430,&amp;UARTdrv,1,20,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}

#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	msp430_LCD_cmdClear();
	msp430_LCD_print(0,0,&quot;AP shout down ...&quot;);
	APdelete(&amp;AP);
	return 0;
}
</Code><Code idCode="228">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// updates a variable the AP
int HALimpl_1_recvUpdate (void * pVarData, void * pMsgData) {
	uint32_t * pD = (uint32_t *) pMsgData;
	TAPgenericRationalVector * pIV = pVarData;
	
	// at the first possion at the message is the global var index
	pD++; // skip it (it's the varindex)
	// and now we are at amount of values
	APendianConversation32Bit(pD,eAP_littleEndian);
	int imax = (int) *((int32_t *)pD);
	int i;

	if (APgenericRationalVector_resize(pIV,imax)) {
		return -1;
	}

	pD++;

	for (i = 0; i &lt; imax; i++) {
		pIV-&gt;pVal[i] = *((float *)pD);
		pD++;
	}
	return 0;
}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
	return APgenericRationalVector_create((int)numberOfElements);
}
// updates the vars at the other APs
int HALimpl_1_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	TAPgenericRationalVector * pRV = pVarData;
	TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
	int32_t dataAmount = (int32_t) 1 + pRV-&gt;num;
	int32_t dummy;
	// send header
	pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
	// send amount of elements
	dummy = (int32_t) pRV-&gt;num;
	pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;dummy);
	// send elements
	pMD-&gt;pfkt_sendFloat32(pMD,pRV-&gt;num,pRV-&gt;pVal);
	return 0;
}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {
	APgenericRationalVector_destroy(pVarData);
}
</Code><Code idCode="229">// ===============================
// AP uuid = 11
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;



}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,			// the message system
		TAPMessageID		msgID,		// if 0 all messages are allowed
		TAPNodeID			sender,		// if 0 all senders are allowed
		uint32_t			mNumber		// if 0 all numbers are allowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;

	TAPMsg * res = NULL;
	// search msg list

	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;

	while (pM) {
		senderOK = 0;
		msgIDok = 0;
		numberOK = 0;

		if (!sender) {
			senderOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
		}
		if (!msgID) {
			msgIDok = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
		}
		if (!mNumber) {
			numberOK = 1;
		} else {
			if (*(pM-&gt;pH)[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
		}

		if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
			res = pM;
			goto exit;
		}
		// the id was wrong but the number was ok &gt;&gt; so the action failed
		if (numberOK) goto fail;
		pAntecessorM = pM;
		pM = pM-&gt;pNext;
	}
fail:
	return NULL;
exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	return res;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// wait for a message
		APMSwaitForNewMessage(pMS);
		// get the message
		pM = APMSgetMsg (pMS,0,0,0);
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
	}
exit:
	AP_MMU_free(pMS-&gt;mmu, pM-&gt;memory);
}
</Code><Code idCode="230">// ===============================
// AP uuid = 11
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	initHW();

	startHW();


	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}


// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
}
</Code><Code idCode="231">#define SRUDEBUG  // Check SRU Routings for errors.

#define DAC4
#define DAC3

// math defines

#ifndef M_E
	#define M_E		2.7182818284590452354
#endif

#ifndef M_LOG2E
	#define M_LOG2E		1.4426950408889634074
#endif

#ifndef M_LOG10E
	#define M_LOG10E	0.43429448190325182765
#endif

#ifndef M_LN2
	#define M_LN2		0.69314718055994530942
#endif

#ifndef M_LN10
	#define M_LN10		2.30258509299404568402
#endif

#ifndef M_PI
	#define M_PI		3.14159265358979323846
#endif

#ifndef M_PI_2
	#define M_PI_2		1.57079632679489661923
#endif

#ifndef M_PI_4
	#define M_PI_4		0.78539816339744830962
#endif

#ifndef M_1_PI
	#define M_1_PI		0.31830988618379067154
#endif

#ifndef M_2_PI
	#define M_2_PI		0.63661977236758134308
#endif

#ifndef M_2_SQRTPI
	#define M_2_SQRTPI	1.12837916709551257390
#endif

#ifndef M_SQRT2
	#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT1_2
	#define M_SQRT1_2	0.70710678118654752440
#endif

// ===============================
// // extra code for group &quot;ADSP 21369&quot;
// ===============================

// The following definition allows the SRU macro to check for errors. Once the routings have
// been verified, this definition can be removed to save some program memory space.
// The preprocessor will issue a warning stating this when using the SRU macro without this
// definition
#define SRUDEBUG  // Check SRU Routings for errors.
#include &lt;SRU.h&gt;


// c includes
#include &lt;stdio.h&gt;

// =======================================================
// AD 1835 defines
// =======================================================

//
//  AD1835.h
//
//  Configuration values for the AD1835A codec
//

#define DACCTRL1   	(0x0000)  // DAC control register 1    (R/W)
#define DACCTRL2   	(0x1000)  // DAC control register 2    (R/W)
#define DACVOL_L1   (0x2000)  // DAC volume - left 1       (R/W)
#define DACVOL_R1   (0x3000)  // DAC volume - right 1      (R/W)
#define DACVOL_L2   (0x4000)  // DAC volume - left 2       (R/W)
#define DACVOL_R2   (0x5000)  // DAC volume - right 2      (R/W)
#define DACVOL_L3   (0x6000)  // DAC volume - left 3       (R/W)
#define DACVOL_R3   (0x7000)  // DAC volume - right 3      (R/W)
#define DACVOL_L4   (0x8000)  // DAC volume - left 4       (R/W)
#define DACVOL_R4   (0x9000)  // DAC volume - right 4      (R/W)
#define ADCPEAKL   	(0xA000)  // ADC left peak              (R)
#define ADCPEAKR   	(0xB000)  // ADC right peak             (R)
#define ADCCTRL1   	(0xC000)  // ADC control 1             (R/W)
#define ADCCTRL2   	(0xD000)  // ADC control 2             (R/W)
#define ADCCTRL3   	(0xE000)  // ADC control 3             (R/W)

#define RD         	(0x0800)
#define WR         	(0x0000)  // Write to register


// DAC control register 1
#define DEEMPH44_1 	(0x0100)  // Deemphasis filter for 44.1 KHz
#define DEEMPH32   	(0x0200)  // Deemphasis filter for 32.0 KHz
#define DEEMPH48   	(0x0300)  // Deemphasis filter for 48.0 KHz

#define DACI2S     	(0x0000)  // DAC receives I2S format
#define DACRJ      	(0x0020)  // DAC receives I2S format
#define DACDSP     	(0x0040)  // DAC receives I2S format
#define DACLJ      	(0x0060)  // DAC receives I2S format
#define DACPACK256 	(0x0080)  // DAC receives I2S format

#define DAC24BIT   	(0x0000)  // 24-bit output word length
#define DAC20BIT   	(0x0008)  // 20-bit output word length
#define DAC16BIT   	(0x0010)  // 16-bit output word length

#define DACPOWERDN 	(0x0004)  // DAC into power-down mode

#define DACFS48    	(0x0000)  // Sample rate = 48 KHz (x8)
#define DACFS96    	(0x0001)  // Sample rate = 96 KHz (x4)
#define DACFS192   	(0x0002)  // Sample rate = 192 KHz (x2)


// DAC control register 2

#define DACREPLICATE  (0x0100)  // Replicate output of DAC 1/2 on 3/4, 5/6 &amp; 7/8
#define DACMUTE_R4    (0x0080)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L4    (0x0040)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R3    (0x0020)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L3    (0x0010)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R2    (0x0008)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L2    (0x0004)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_R1    (0x0002)  // Mute DAC output channel (clear to un-mute)
#define DACMUTE_L1    (0x0001)  // Mute DAC output channel (clear to un-mute)


//-------------------------------------------------------------------------------
//DAC Volume Control - 10-bit granularity (1024 levels)
#define DACVOL_MIN      (0x000)
#define DACVOL_LOW      (0X100)
#define DACVOL_MED      (0X200)
#define DACVOL_HI       (0X300)
#define DACVOL_MAX      (0x3FF)
#define DACVOL_MASK     (0x3FF)  // Volume in dB is in 10 LSBs
                                 //   3FF = 0 dBFS = 1023/1023
                                 //   3FE = -0.01 dBFS = 1022/1023
                                 //      ...
                                 //   002 = -50.7 dBFS = 3/1023
                                 //   001 = -54.2 dBFS = 2/1023

//-------------------------------------------------------------------------------
//  ADC Control 1

#define ADCHPF     (0x0100)  // High pass filter (AC-coupled)
#define ADCPOWERDN (0x0080)  // DAC into power-down mode
#define ADCFS48    (0x0000)  // Sample rate = 48 KHz
#define ADCFS96    (0x0040)  // Sample rate = 96 KHz

//-------------------------------------------------------------------------------
//  ADC Control 2

#define AUXSLAVE   (0x0000)  // Aux input is in slave mode
#define AUXMASTER  (0x0200)  // Aux input is in master mode

#define ADCI2S     (0x0000)  // ADC transmits in I2S format
#define ADCRJ      (0x0040)  // ADC transmits in right-justified format
#define ADCDSP     (0x0080)  // ADC transmits in DSP (TDM) format
#define ADCLJ      (0x00C0)  // ADC transmits in left-justified format
#define ADCPACK256 (0x0100)  // ADC transmits in packed 256 format
#define ADCAUX256  (0x0180)  // ADC transmits in packed 128 format

#define ADC24BIT   (0x0000)  // 24-bit output word length
#define ADC20BIT   (0x0010)  // 20-bit output word length
#define ADC16BIT   (0x0020)  // 16-bit output word length

#define ADCMUTER   (0x0002)  // Mute right channel from ADC
#define ADCMUTEL   (0x0001)  // Mute right channel from ADC

//-------------------------------------------------------------------------------
//  ADC Control 3

#define IMCLKx2    (0x0000)  // Internal MCLK = external MCLK x 2
#define IMCLKx1    (0x0040)  // Internal MCLK = external MCLK
#define IMCLKx23   (0x0080)  // Internal MCLK = external MCLK x 2/3

#define PEAKRDEN   (0x0020)  // Enable reads of peak ADC levels
#define PEAKLEVELMASK  (0x003F)  // Six significant bit of level
									// 000000 = 0dBFS, -1dB/LSB


// =======================================================
// talk through interface
// =======================================================
#define NUM_SAMPLES 1024

// Function prototypes for this talkthrough code

extern void InitPLL_SDRAM(void);
extern void processBlock(unsigned int *);

extern void InitSRU(void);
extern void Init1835viaSPI(void);

extern void InitSPORT(void);
extern void TalkThroughISR(int);
extern void ClearSPORT(void);

extern void SetupSPI1835 (void) ;
extern void DisableSPI1835 (void) ;
extern void Configure1835Register (int i) ;
extern unsigned int Get1835Register (int i) ;

extern void SetupIRQ01 (void) ;
extern void Irq0ISR (int i) ;
extern void Irq1ISR (int i) ;

typedef void (* TFkt_ADSPuartCB) (unsigned int value);

extern void initUART(TFkt_ADSPuartCB cbRXFunction);
extern void UARTisr();
extern void sendUARTuint32Values(unsigned int *pD, int amount);

extern void Delay (int i) ;

// =======================================================
// init AD1835
// =======================================================
/* Setup the SPI pramaters here in a buffer first */
unsigned int Config1835Param [] = {
            WR | DACCTRL1 | DACI2S | DAC24BIT | DACFS48,
            WR | DACCTRL2 ,//| DACMUTE_R4 | DACMUTE_L4,
            WR | DACVOL_L1 | DACVOL_MAX,
            WR | DACVOL_R1 | DACVOL_MAX,
            WR | DACVOL_L2 | DACVOL_MAX,
            WR | DACVOL_R2 | DACVOL_MAX,
            WR | DACVOL_L3 | DACVOL_MAX,
            WR | DACVOL_R3 | DACVOL_MAX,
            WR | DACVOL_L4 | DACVOL_MAX,
            WR | DACVOL_R4 | DACVOL_MAX,
            WR | ADCCTRL1 | ADCFS48,
            WR | ADCCTRL2 | ADCI2S | ADC24BIT,
            WR | ADCCTRL3 | IMCLKx2
        } ;

volatile int spiFlag ;

//Set up the SPI port to access the AD1835
void SetupSPI1835 ()
{
    /* First configure the SPI Control registers */
    /* First clear a few registers     */
    *pSPICTL = (TXFLSH | RXFLSH) ;
    *pSPIFLG = 0;
    *pSPICTL = 0;

    /* Setup the baud rate to 500 KHz */
    *pSPIBAUD = 100;

    /* Setup the SPI Flag register to FLAG3 : 0xF708*/
    *pSPIFLG = 0xF708;

    /* Now setup the SPI Control register : 0x5281*/
    *pSPICTL = (SPIEN | SPIMS | MSBF | WL16 | TIMOD1) ;

}

//Disable the SPI Port
void DisableSPI1835 ()
{
    *pSPICTL = (TXFLSH | RXFLSH);
}

//Send a word to the AD1835 via SPI
void Configure1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI to indicate that it has finished.
    while (1)
    {
        if (*pSPISTAT &amp; SPIF)
            break ;
    }
    Delay (100) ;
}

//Receive a register setting from the AD1835
unsigned int Get1835Register (int val)
{
    *pTXSPI = val ;
    Delay(100);

    //Wait for the SPI port to indicate that it has finished
    while (1)
    {
        if (SPIF &amp; *pSPISTAT)
            break ;
    }
    Delay (100) ;
    return *pRXSPI ;
//  return i ;
}

//Set up all AD1835 registers via SPI
void Init1835viaSPI()
{
    int configSize = sizeof (Config1835Param) / sizeof (int) ;
    int i ;

    SetupSPI1835 () ;

    for (i = 0; i &lt; configSize; ++i)
    {
        Configure1835Register (Config1835Param[i]) ;
    }

    DisableSPI1835 () ;

}

//Delay loop
void Delay (int i)
{
    for (;i&gt;0;--i)
        asm (&quot;nop;&quot;) ;
}

// =======================================================
// PLL for SDRAM init
// =======================================================
void InitPLL_SDRAM(){

int i, pmctlsetting;

//Change this value to optimize the performance for quazi-sequential accesses (step &gt; 1)
#define SDMODIFY 1

    pmctlsetting= *pPMCTL;
    pmctlsetting &amp;= ~(0xFF); //Clear

    // CLKIN= 24.576 MHz, Multiplier= 27, Divisor= 1, INDIV=1, CCLK_SDCLK_RATIO= 2.
    // Core clock = (24.576 MHz * 27) /2 = 331.776 MHz
    pmctlsetting= SDCKR2|PLLM27|INDIV|DIVEN;
    *pPMCTL= pmctlsetting;
    pmctlsetting|= PLLBP;
    *pPMCTL= pmctlsetting;

    //Wait for around 4096 cycles for the pll to lock.
    for (i=0; i&lt;4096; i++)
          asm(&quot;nop;&quot;);

    *pPMCTL ^= PLLBP;       //Clear Bypass Mode
    *pPMCTL |= (CLKOUTEN);  //and start clkout


    // Programming SDRAM control registers and enabling SDRAM read optimization
    // CCLK_SDCLK_RATIO= 2.5
    // RDIV = ((f SDCLK X t REF )/NRA) - (tRAS + tRP )
    // (166*(10^6)*64*(10^-3)/4096) - (7+3) = 2583

    *pSDRRC= (0xA17)|(SDMODIFY&lt;&lt;17)|SDROPT;

    //===================================================================
    //
    // Configure SDRAM Control Register (SDCTL) for PART MT48LC4M32B2
    //
    //  SDCL3  : SDRAM CAS Latency= 3 cycles
    //  DSDCLK1: Disable SDRAM Clock 1
    //  SDPSS  : Start SDRAM Power up Sequence
    //  SDCAW8 : SDRAM Bank Column Address Width= 8 bits
    //  SDRAW12: SDRAM Row Address Width= 12 bits
    //  SDTRAS7: SDRAM tRAS Specification. Active Command delay = 7 cycles
    //  SDTRP3 : SDRAM tRP Specification. Precharge delay = 3 cycles.
    //  SDTWR2 : SDRAM tWR Specification. tWR = 2 cycles.
    //  SDTRCD3: SDRAM tRCD Specification. tRCD = 3 cycles.
    //
    //--------------------------------------------------------------------

    *pSDCTL= SDCL3|DSDCLK1|SDPSS|SDCAW8|SDRAW12|SDTRAS7|SDTRP3|SDTWR2|SDTRCD3;

    // Note that MS2 &amp; MS3 pin multiplexed with flag2 &amp; flag3.
    // MSEN bit must be enabled to access SDRAM, but LED7 cannot be driven with sdram
    *pSYSCTL |=MSEN;

    // Mapping Bank 2 to SDRAM
    // Make sure that jumper is set appropriately so that MS2 is connected to
    // chip select of 16-bit SDRAM device
    *pEPCTL |=B2SD;
    *pEPCTL &amp;= ~(B0SD|B1SD|B3SD);

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL0) Bank 0 for the ISSI IS61LV5128
    //
    //  WS2 : Wait States = 2 cycles
    //  HC1  : Bus Hold Cycle (at end of write access)= 1 cycle.
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //SRAM Settings
    *pAMICTL0 = WS2|HC1|AMIEN|BW8;

    //===================================================================
    //
    // Configure AMI Control Register (AMICTL) Bank 1 for the AMD AM29LV08
    //
    //  WS23 : Wait States= 23 cycles
    //  AMIEN: Enable AMI
    //  BW8  : External Data Bus Width= 8 bits.
    //
    //--------------------------------------------------------------------

    //Flash Settings
    *pAMICTL1 = WS23|AMIEN|BW8;
}

// =======================================================
// serial Port
// =======================================================
/*
   Here is the mapping between the SPORTS and the DACS
   ADC -&gt; DSP  : SPORT0A : I2S
   DSP -&gt; DAC1 : SPORT1A : I2S
   DSP -&gt; DAC2 : SPORT1B : I2S
   DSP -&gt; DAC3 : SPORT2A : I2S
   DSP -&gt; DAC4 : SPORT2B : I2S
*/

unsigned int PCI = 0x00080000 ;
unsigned int OFFSET = 0x00080000 ;

// TCB blocks for Chaining
//Each block will be used for:
//      Filling from the ADC
//      Processing filled data
//      Sending to DAC
//
//Each one is doing only one of these steps for each SPORT interrupt.

//For this example the startup state is
// Start to 1st interrupt: gBlock_A is filled first, gBlock_C is sent
// 1st int to 2nd int: gBlock_C filled, gBlock_A processed, gBlock_B sent
// 2nd int to 3rd int: gBlock_B filled, gBlock_C processed, gBlock_A sent
// 3rd int to 4th int: gBlock_A filled, gBlock_B processed, gBlock_C sent
unsigned int gBlock_A[NUM_SAMPLES] ;
unsigned int gBlock_B[NUM_SAMPLES] ;
unsigned int gBlock_C[NUM_SAMPLES] ;

//Set up the TCBs to rotate automatically
int TCB_gBlock_A[4] = { 0, sizeof(gBlock_A), 1, 0};;
int TCB_gBlock_B[4] = { 0, sizeof(gBlock_B), 1, 0};
int TCB_gBlock_C[4] = { 0, sizeof(gBlock_C), 1, 0};

void InitSPORT()
{
    //Proceed from Block A to Block C
    TCB_gBlock_A[0] = (int) TCB_gBlock_C + 3 - OFFSET + PCI ;
    TCB_gBlock_A[3] = (unsigned int) gBlock_A - OFFSET ;

    //Proceed from Block B to Block A
    TCB_gBlock_B[0] = (int) TCB_gBlock_A + 3 - OFFSET + PCI ;
    TCB_gBlock_B[3] = (unsigned int) gBlock_B - OFFSET ;

    //Proceed from Block C to Block B
    TCB_gBlock_C[0] = (int) TCB_gBlock_B + 3 - OFFSET + PCI ;
    TCB_gBlock_C[3] = (unsigned int) gBlock_C - OFFSET ;

    //Clear the Mutlichannel control registers
    *pSPMCTL0 = 0;
    *pSPMCTL1 = 0;
    *pSPMCTL2 = 0;
    *pSPCTL0 = 0 ;
    *pSPCTL1 = 0 ;
    *pSPCTL2 = 0 ;

    //============================================================
    //
    // Configure SPORT 0 for input from ADC
    //
    //------------------------------------------------------------


    *pSPCTL0 = (OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A);

    // Enabling Chaining
    // Block A will be filled first
    *pCPSP0A = (unsigned int) TCB_gBlock_A - OFFSET + 3 ;

    //============================================================
    //
    // Configure SPORTs 1 &amp; 2 for output to DACs 1-4
    //
    //------------------------------------------------------------

    #ifdef DAC1
    *pSPCTL1 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC1
    *pCPSP1A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC2
    *pSPCTL1 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC2
    *pCPSP1B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC3
    *pSPCTL2 = (SPTRAN | OPMODE | SLEN24 | SPEN_A | SCHEN_A | SDEN_A) ;
    // write to DAC3
    *pCPSP2A = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif

    #ifdef DAC4
    *pSPCTL2 |= (SPTRAN | OPMODE | SLEN24 | SPEN_B | SCHEN_B | SDEN_B) ;
    // write to DAC4
    *pCPSP2B = (unsigned int) TCB_gBlock_C - OFFSET + 3 ;
    #endif
}


// =======================================================
// init SRU
// =======================================================

void InitSRU(){

//-----------------------------------------------------------------------------
//
//  MCLK: The output of the 12.288 MHz xtal is either directly connected to the
//        codec, but also connected to DAI_P06, or just to DAI_P17. This is
//        determined by switch SW3 For this example we route the MCLK into
//        DAI_P17 and supply the clock to the ADC via DAI_P06  by routing the
//        signal through the SRU.

//  Tie the pin buffer input LOW.
    SRU(LOW,DAI_PB17_I);

//  Tie the pin buffer enable input LOW
    SRU(LOW,PBEN17_I);

//-----------------------------------------------------------------------------
//
//  Connect the ADC: The codec drives a BCLK output to DAI pin 7, a LRCLK
//          (a.k.a. frame sync) to DAI pin 8 and data to DAI pin 5.
//
//          Connect the ADC to SPORT0, using data input A
//
//          All three lines are always inputs to the SHARC so tie the pin
//          buffer inputs and pin buffer enable inputs all low.


//------------------------------------------------------------------------
//  Connect the ADC to SPORT0, using data input A

    //  Clock in on pin 7
    SRU(DAI_PB07_O,SPORT0_CLK_I);

    //  Frame sync in on pin 8
    SRU(DAI_PB08_O,SPORT0_FS_I);

    //  Data in on pin 5
    SRU(DAI_PB05_O,SPORT0_DA_I);

//------------------------------------------------------------------------
//    Tie the pin buffer inputs LOW for DAI pins 5, 7 and 8.  Even though
//    these pins are inputs to the SHARC, tying unused pin buffer inputs
//    LOW is &quot;good coding style&quot; to eliminate the possibility of
//    termination artifacts internal to the IC.  Note that signal
//    integrity is degraded only with a few specific SRU combinations.
//    In practice, this occurs VERY rarely, and these connections are
//    typically unnecessary.


    SRU(LOW,DAI_PB05_I);
    SRU(LOW,DAI_PB07_I);
    SRU(LOW,DAI_PB08_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs LOW for DAI pins 5, 6, 7 and 8 so
//  that they are always input pins.

    SRU(LOW,PBEN05_I);
    SRU(LOW,PBEN07_I);
    SRU(LOW,PBEN08_I);

//-----------------------------------------------------------------------------
//
//  Connect the DACs: The codec accepts a BCLK input from DAI pin 13 and
//          a LRCLK (a.k.a. frame sync) from DAI pin 14 and has four
//          serial data outputs to DAI pins 12, 11, 10 and 9
//
//          Connect DAC1 to SPORT1, using data output A
//          Connect DAC2 to SPORT1, using data output B
//          Connect DAC3 to SPORT2, using data output A
//          Connect DAC4 to SPORT2, using data output B
//
//          Connect the clock and frame sync inputs to SPORT1 and SPORT2
//          should come from the ADC on DAI pins 7 and 8, respectively
//
//          Connect the ADC BCLK and LRCLK back out to the DAC on DAI
//          pins 13 and 14, respectively.
//
//          All six DAC connections are always outputs from the SHARC
//          so tie the pin buffer enable inputs all high.
//

//------------------------------------------------------------------------
//  Connect the pin buffers to the SPORT data lines and ADC BCLK &amp; LRCLK

    SRU(SPORT2_DB_O,DAI_PB09_I);
    SRU(SPORT2_DA_O,DAI_PB10_I);
    SRU(SPORT1_DB_O,DAI_PB11_I);
    SRU(SPORT1_DA_O,DAI_PB12_I);

//------------------------------------------------------------------------
//  Connect the clock and frame sync input from the ADC directly
//    to the output pins driving the DACs.

    SRU(DAI_PB07_O,DAI_PB13_I);
    SRU(DAI_PB08_O,DAI_PB14_I);
    SRU(DAI_PB17_O,DAI_PB06_I);

//------------------------------------------------------------------------
//  Connect the SPORT clocks and frame syncs to the clock and
//  frame sync from the SPDIF receiver

    SRU(DAI_PB07_O,SPORT1_CLK_I);
    SRU(DAI_PB07_O,SPORT2_CLK_I);
    SRU(DAI_PB08_O,SPORT1_FS_I);
    SRU(DAI_PB08_O,SPORT2_FS_I);

//------------------------------------------------------------------------
//  Tie the pin buffer enable inputs HIGH to make DAI pins 9-14 outputs.
    SRU(HIGH,PBEN06_I);
    SRU(HIGH,PBEN09_I);
    SRU(HIGH,PBEN10_I);
    SRU(HIGH,PBEN11_I);
    SRU(HIGH,PBEN12_I);
    SRU(HIGH,PBEN13_I);
    SRU(HIGH,PBEN14_I);
//--------------------------------------------------------------------------
// Route SPI signals to AD1835.

    SRU(SPI_MOSI_O,DPI_PB01_I)      //Connect MOSI to DPI PB1.
    SRU(DPI_PB02_O, SPI_MISO_I)     //Connect DPI PB2 to MISO.
    SRU(SPI_CLK_O, DPI_PB03_I)      //Connect SPI CLK to DPI PB3.
    SRU(SPI_FLG3_O, DPI_PB04_I)     //Connect SPI FLAG3 to DPI PB4.
//---------------------------------------------------------------------------
// Tie pin buffer enable from SPI peipherals to determine whether they are
// inputs or outputs

    SRU(SPI_MOSI_PBEN_O, DPI_PBEN01_I);
    SRU(SPI_MISO_PBEN_O, DPI_PBEN02_I);
    SRU(SPI_CLK_PBEN_O, DPI_PBEN03_I);
    SRU(SPI_FLG3_PBEN_O, DPI_PBEN04_I);

//-----------------------------------------------------------------------------
// UART config
    SRU2(UART0_TX_O,DPI_PB09_I); // UART transmit signal is connected to DPI pin 9
    SRU2(HIGH,DPI_PBEN09_I);
    SRU2(DPI_PB10_O,UART0_RX_I); // connect the pin buffer output signal to the UART0 receive
    SRU2(LOW,DPI_PB10_I);
    SRU2(LOW,DPI_PBEN10_I);      // disables DPI pin10 as input
}

// =======================================================
// IRQ's
// =======================================================
void SetupIRQ01 ()
{
    //Enable the pins as IRQ0 and IRQ1
    *pSYSCTL|= IRQ0EN | IRQ1EN;
    asm (&quot;#include &lt;def21369.h&gt;&quot;) ;
    //Set the IRQ pins to be edge sensitive
    asm (&quot;bit set mode2 IRQ0E;&quot;) ;
    asm (&quot;bit set mode2 IRQ1E;&quot;) ;
}

void Irq0ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ0 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol -= 0x3F ;
    rightDAC4Vol -= 0x3F ;

    if (leftDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &gt; 0)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

void Irq1ISR (int i)
{
    int leftDAC4Vol, rightDAC4Vol ;

    // IRQ1 is used to decrease volume
    SetupSPI1835 () ;
    leftDAC4Vol = Get1835Register (RD | DACVOL_L4) ;
    rightDAC4Vol = Get1835Register (RD | DACVOL_R4) ;

    // Now decrease by a step size of 0x3F
    leftDAC4Vol += 0x3F ;
    rightDAC4Vol += 0x3F ;

    if (leftDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_L4 | leftDAC4Vol) ;

    if (rightDAC4Vol &lt; 0x3FF)
        Configure1835Register (WR | DACVOL_R4 | rightDAC4Vol) ;

    DisableSPI1835 () ;
}

// =======================================================
// UART
// =======================================================

// type for the low level receive
typedef struct SADSPuartRecv {
	unsigned int 	val;	//!&lt; the value
	int				i;		//!&lt; the index
	TFkt_ADSPuartCB cb;		//!&lt; the callback function when we received 4 bytes of data
} TADSPuartRecv;

TADSPuartRecv gUARTrx;


// init ADSP uart
//          Bits per Second  -&gt; 19200
//          Data Bits        -&gt; 8
//          Parity           -&gt; odd
//          Stop Bits        -&gt; 2
//          Flow Control     -&gt; None
void initUART(TFkt_ADSPuartCB cbRXFunction) {
	// Sets the Baud rate for UART0
	*pUART0LCR = UARTDLAB;  //enables access to Divisor register to set baud rate
//	*pUART0DLL = 0x1c;      //0x21c = 540 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
//    *pUART0DLH = 0x02;

	*pUART0DLL = 0x38;      //1080 = 0x438 for divisor value and gives a baud rate of19200 for core clock 331.776MHz
	*pUART0DLH = 0x04;



    // Configures UART0 LCR
//    *pUART0LCR = UARTWLS8| 				// word length 8
//                 UARTPEN| 				// parity enable ODD parity
//                 UARTSTB ; 				// Two stop bits
	*pUART0LCR = UARTWLS8;	// 8Bit 1StopBit NoParity

    //enables UART0 in receive mode
    *pUART0RXCTL = UARTEN;
    //enables UART0 in core driven mode
    *pUART0TXCTL = UARTEN;

    // set rx callback function and the state machine
    gUARTrx.val = 0;
    gUARTrx.i = 3;
    gUARTrx.cb = cbRXFunction;
}

// UART isr
void UARTisr() {
	unsigned int v;
	v = *pUART0RBR;
	// shift register
	gUARTrx.val &lt;&lt;= 8;
	gUARTrx.val |= v;
	if (gUARTrx.i) {
		gUARTrx.i--;
	} else {
		gUARTrx.cb(gUARTrx.val);
		gUARTrx.i = 3;
		gUARTrx.val = 0;
	}
}

// UART send
void sendUARTuint32Values(unsigned int *pD, int amount) {
	unsigned int	v;
	int				i;
	int				j;

	for (i = 0; i &lt; amount; i++) {
		v = *pD;
		for (j = 0; j &lt; 4; j++) {
			// wait till the transmitter is ready
			while ((*pUART0LSR &amp; UARTTHRE) == 0);
			// mask all other bytes out and send the lowest byte
			*pUART0THR = v &amp; 0xFF;
			v &gt;&gt;= 8;
		}
		pD++;
	}
	// wait till the transmitter is ready
	while ((*pUART0LSR &amp; UARTTHRE) == 0);
}


// =======================================================
// SPORT IRQs
// =======================================================

    //Pointer to the blocks

unsigned int *gpProcessBuffer[3] = {gBlock_A,gBlock_C,gBlock_B};

// Counter to choose which buffer to process
volatile int gProcessBufferCounter=2;
// Semaphore to indicate to main that a block is ready for processing
volatile int gProcessBufferReady=0;

void TalkThroughISR(int sig_int)
{
    //Increment the block pointer
    gProcessBufferCounter++;
    gProcessBufferCounter %= 3;

    gProcessBufferReady = 1;
}

// =======================================================
// LED func
// =======================================================

void LEDSRUinit () {
	// Init LED Ports
	SRU(LOW,DPI_PB06_I);				// Connect GND to DPI_PB06 input (LED1)
	SRU(LOW,DPI_PB07_I);	    		// Connect GND to DPI_PB07 input (LED2)
	SRU(LOW,DPI_PB08_I);	    		// Connect GND to DPI_PB08 input (LED3)
	SRU(LOW,DPI_PB13_I);	    		// Connect GND to DPI_PB13 input (LED4)
	SRU(LOW,DPI_PB14_I);	    		// Connect GND to DPI_PB14 input (LED5)
	SRU(LOW,DAI_PB15_I);		  		// Connect GND to DAI_PB15 input (LED6)
	SRU(LOW,DAI_PB16_I);  				// Connect GND to DAI_PB16 input (LED7)

	//Enabling the Buffer using the following sequence: High -&gt; Output, Low -&gt; Input

	SRU(HIGH,DPI_PBEN06_I);				// LED 1
	SRU(HIGH,DPI_PBEN07_I);				// LED 2
	SRU(HIGH,DPI_PBEN08_I);				// LED 3
	SRU(HIGH,DPI_PBEN13_I);				// LED 4
	SRU(HIGH,DPI_PBEN14_I);				// LED 5
	SRU(HIGH,PBEN15_I);					// LED 6
	SRU(HIGH,PBEN16_I);					// LED 7
}

#define set_LED_1 SRU(HIGH,DPI_PB06_I)
#define set_LED_2 SRU(HIGH,DPI_PB07_I)
#define set_LED_3 SRU(HIGH,DPI_PB08_I)
#define set_LED_4 SRU(HIGH,DPI_PB13_I)
#define set_LED_5 SRU(HIGH,DPI_PB14_I)
#define set_LED_6 SRU(HIGH,DPI_PB15_I)
#define set_LED_7 SRU(HIGH,DPI_PB16_I)

#define clear_LED_1 SRU(LOW,DPI_PB06_I)
#define clear_LED_2 SRU(LOW,DPI_PB07_I)
#define clear_LED_3 SRU(LOW,DPI_PB08_I)
#define clear_LED_4 SRU(LOW,DPI_PB13_I)
#define clear_LED_5 SRU(LOW,DPI_PB14_I)
#define clear_LED_6 SRU(LOW,DPI_PB15_I)
#define clear_LED_7 SRU(LOW,DPI_PB16_I)

int x = 0;
void cbUARTdummy (unsigned int v) {
	x++;
}

// =======================================================
// init HW
// =======================================================

void initHW() {

	// uart stuff
	*pPICR2 &amp;= ~(0x3E0); //Sets the UART0 receive interrupt to P13

	*pPICR2 |= (0x13&lt;&lt;5);


    //Initialize PLL to run at CCLK= 331.776 MHz &amp; SDCLK= 165.888 MHz.
    //SDRAM is setup for use, but cannot be accessed until MSEN bit is enabled
    InitPLL_SDRAM();

    // Setting up IRQ0 and IRQ1
    SetupIRQ01() ;

    // Need to initialize DAI because the sport signals need to be routed
    InitSRU();

    // This function will configure the codec on the kit
    Init1835viaSPI();

    interrupt (SIG_SP0,TalkThroughISR);
    interrupt (SIG_IRQ0, Irq0ISR) ;
    interrupt (SIG_IRQ1, Irq1ISR) ;

	*pUART0LCR=0;
    *pUART0IER   = UARTRBFIE;    // enables UART0 receive interrupt
	interrupt(SIG_P13,UARTisr);


    // init LEDs
    LEDSRUinit();

    // init UART
    initUART (cbUARTdummy);
    unsigned int vals [] = {1,2,3,4,5,0x11223344,0x55667788};
    sendUARTuint32Values (vals,sizeof(vals)/sizeof(unsigned int));

}

void startHW() {
    // Finally setup the sport to receive / transmit the data
    InitSPORT();
}


// =======================================================
// processing
// =======================================================


#ifndef INT24_MAX
	#define INT24_MIN (-16777215-1)
	#define INT24_MAX (16777215)
#endif

#define dAD1835_ChannelAmount (2)
#define dAD1835_leftChannelOffset (1)
#define dAD1835_rightChannelOffset (0)

#define dAD1835_ChannelFlag_left ('l')
#define dAD1835_ChannelFlag_right ('r')

// the adsp codec channel type
typedef struct SCodecChannel {
	unsigned int 	size;			//!&lt; size of the channel
	char			channelFlag;	//!&lt; l=left r=right channel
} TCodecChannel;

// the codec channel list
typedef struct SCodecChannelList {
	TCodecChannel *		pCC;
	int					number;
} TCodecChannelList;

// find the channel struct by a given channel
inline TCodecChannel * ADSP_getChannel (int channel) {
	extern TCodecChannelList gADSPcodecChannels;
	if ((channel &lt; 0) || (channel &gt;= gADSPcodecChannels.number)) return NULL;
	return &amp;gADSPcodecChannels.pCC[channel];
}

// wait for the sample frame
inline void ADSP_waitForSamples () {
	if (!gProcessBufferReady) {
		set_LED_1;
		while (!gProcessBufferReady) {

		};
		gProcessBufferReady = 0;
		clear_LED_1;
	}
}

// ADSP ADC 24Bit value format
// 011...11		+FS
// 0......0		0
// 111...11		-FS
//
// reads some samples from the input channel
void ADSP_readSamplesFromChannel (TCodecChannel * pIC, float * pBuffer, unsigned int amount) {
	// wait for new samples
	ADSP_waitForSamples ();

	// after that get the pointer to the buffer
	int * pBinSRC  = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pIC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}

//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBuffer = ((float) ((int)(*pBinSRC)&lt;&lt;8)) * (1.0/2147483648.0);
		pBuffer++;
		pBinSRC += dAD1835_ChannelAmount;
	}
}


// writes some samples to the output channel
void ADSP_writesSamplesToChannel (TCodecChannel * pOC, float * pBuffer, unsigned int amount) {
	int * pBinSRC = (int *) gpProcessBuffer[gProcessBufferCounter];
	unsigned int i;
	float tv;
	// point to the first sample
	if (dAD1835_ChannelFlag_right == pOC-&gt;channelFlag) {
		pBinSRC += dAD1835_rightChannelOffset;
	} else {
		pBinSRC += dAD1835_leftChannelOffset;
	}
//	#pragma SIMD_for
	for (i = 0; i &lt; amount; i++) {
		*pBinSRC = ((int)(2147483648.0 * pBuffer[i]))&gt;&gt;8;
		pBinSRC += dAD1835_ChannelAmount;
	}
}

TCodecChannel gADSPcodecChannel []= {
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left},	// ADC left input
		{NUM_SAMPLES/2,dAD1835_ChannelFlag_left}	// DAC4 &amp; DAC3 left output
};

TCodecChannelList gADSPcodecChannels = {
		gADSPcodecChannel,
		sizeof(gADSPcodecChannel) / sizeof(TCodecChannel)
};
</Code><Code idCode="232">// ===============================
// driver uuid =2
// ===============================

// ------------------------------
// drv own functions
// ------------------------------

// struct for the drv data
typedef struct SADSPuartDrv {
	TAPMsgHeader				h;	//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TADSPuartDrv;

TADSPuartDrv gADSPuartDrv;

// ------------------------------
// drv own functions
// ------------------------------

void drv_2_sendHeader (
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgTypeID] = msgId;
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgNumber] = num;
	gADSPuartDrv.h[eAPMsgHeaderPosition_receiver] = recv;
	gADSPuartDrv.h[eAPMsgHeaderPosition_length] = length;
	sendUARTuint32Values(gADSPuartDrv.h,sizeof(TAPMsgHeader)/sizeof(uint32_t));
}

// call back function of the uart driver
int drv_2_cbAPClient (unsigned int d) {
	return gADSPuartDrv.rxSM.state (&amp;(gADSPuartDrv.rxSM), &amp;d, 1);
}

//open an existing driver and bind it to the AP
int drv_2_open (void * pAP, struct SAPMsgDrv *pDrv) {
	// init header
	gADSPuartDrv.h[eAPMsgHeaderPosition_endian] = ((TAP *) pAP)-&gt;sysEndian;
	gADSPuartDrv.h[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	gADSPuartDrv.h[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgTypeID] = 0;
	gADSPuartDrv.h[eAPMsgHeaderPosition_msgNumber] = 0;
	gADSPuartDrv.h[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = &amp;gADSPuartDrv;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;gADSPuartDrv.rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}

//close the driver
int drv_2_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_2_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}


//send raw data
int drv_2_sendRaw (struct SAPMsgDrv *pDrv, int amount, void *pData) {
	sendUARTuint32Values(pData,amount);
	return 0;
}


//acknowledge
int drv_2_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_ACK, receiver, mNum, 0);
	return 0;
}
//not acknowledge
int drv_2_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_NACK, receiver, mNum, 0);
	return 0;
}
//start sending a program
int drv_2_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	drv_2_sendHeader(eAPMsgTypes_startPrg, receiver, mNum, 0);
	sendUARTuint32Values((uint32_t *)&amp;globalVariableNumber,1);
	sendUARTuint32Values((uint32_t *)&amp;localVariableNumber,1);
	sendUARTuint32Values((uint32_t *)&amp;instructionNumber,1);
	return 0;
}

//sends a variable
int drv_2_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	drv_2_sendHeader(eAPMsgTypes_sendVariable, receiver, mNum, 3);
	sendUARTuint32Values((uint32_t *)&amp;index,1);
	sendUARTuint32Values((uint32_t *)&amp;varTypeID,1);
	sendUARTuint32Values((uint32_t *)&amp;num,1);
	return 0;
}
//sends an instruction
int drv_2_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	drv_2_sendHeader(eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1);
	sendUARTuint32Values((uint32_t *)&amp;index,1);
	sendUARTuint32Values(fbc,sizeof(int32_t)*dAPInterpreterFuncMaxParams);
	return 0;
}
//sings that the program transmission has completed
int drv_2_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_endPrg, receiver, mNum, 0);
	return 0;
}
//stops the AP
int drv_2_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_stop, receiver, mNum, 0);
	return 0;
}
//the AP executes one instruction
int drv_2_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_step, receiver, mNum, 0);
	return 0;
}
//the AP runs the program
int drv_2_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_run, receiver, mNum, 0);
	return 0;
}
//a variable going to be updated
int drv_2_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	drv_2_sendHeader(eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1);
	sendUARTuint32Values((uint32_t *)&amp;gIndex,1);
	return 0;
}
//a AP is going to be logged in to the system
int drv_2_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_login, receiver, mNum, 0);
	return 0;
}
//a AP is going to be logged out of the system
int drv_2_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_2_sendHeader(eAPMsgTypes_logout, receiver, mNum, 0);
	return 0;
}
</Code><Code idCode="233">// ===============================
// AP uuid = 12
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	initHW();

	startHW();

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:

	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}


// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {

	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 1; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
}
</Code><Code idCode="234">// ===============================
// AP uuid = 11
// ===============================

// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;

	msp430_initHW(10);

	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}

// ================================
// MMU functions
// ================================

typedef struct SAPrealMMUMemory {
	uint32_t *					pData;			// the data
	int							count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	uint32_t *				memory;				// the memory block
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	uint32_t  * 			pUnusedData;		// pointer to the unused memory
	int						elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	int						totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	uint32_t * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(uint32_t));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}

// create a mmu
TAPMMU AP_MMU_create (int elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;


	pMMU-&gt;memory = (uint32_t *) malloc (elementsNumber*sizeof(uint32_t));
	pMMU-&gt;pUnusedData = pMMU-&gt;memory;

	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;

	pMMU-&gt;totalAvailable = elementsNumber;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);
}

// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, int elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;
	return pM;
error:
	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;
}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

extern void drv_3_feedRecvStateM (void);

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;
	int cc; // cycle counter

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	cc = 10;
	while (eAPInterpreterState_run == pIP-&gt;state) {
		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			return -1;
		}
		// process msg receiving
		drv_3_feedRecvStateM ();

		// check message system after x cycles
		if (!cc) {
			APMessageProcess(pIP-&gt;pAP);
			cc = 100;
		} else {
			cc--;
		}

	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			rc = APInterpreterStateRun(IP);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			return -10;
	}
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) return -2;

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)) return -1;
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) return -2;
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) return -3;
		pP++;
		pRawInstr++;
		pIFP++;
	}
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}


typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received


} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;


	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	// we go for sure that we get enough memory
	// if mod(sizeof(TAPMsg)/sizeof(uint32_t)) != 0 we need one uint32_t more -&gt; +1
	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(uint32_t) + 1+ eAPMsgHeaderPosition_headerElementNumber + dataElementsNumber);
	if (!m) return NULL;

	// set the pointers
	uint32_t * pRD = (uint32_t *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((uint32_t *) pRD + sizeof(TAPMsg)/sizeof(uint32_t)+1);
	pM-&gt;pData = (uint32_t *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(uint32_t);
	pM-&gt;pNext = NULL;
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

}

// unchains a received message
void APMSunchainMessage (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM,
		TAPMsg *			pAntecessorM
) {
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
}


// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// temp vars
	TAPMsg * pM;
	TAPMsg * pAntecessorM;
	uint32_t * pH;

	// result var
	TAPMsg * res = NULL;

checkMessages:
	// search msg list
	pM = pMS-&gt;pOldRXMsg;
	pAntecessorM =  NULL;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	drv_3_feedRecvStateM();
	goto checkMessages;
exit:
	// unchain message
	APMSunchainMessage(pMS,pM,pAntecessorM);
	// now one thread is less waiting for a message
	return res;
error:
	return NULL;
}

// wait till a new message has been received
void APMSwaitForNewMessage (TAPrealMsgSystem * pMS)
{
	volatile int mc;

	mc = pMS-&gt;messagecounter;

	while (mc == pMS-&gt;messagecounter) {
		drv_3_feedRecvStateM();
	}
}

// returns 0 if a new message is available
inline int APMSisMessageAvailble (TAPrealMsgSystem * pMS) {
	return (!pMS-&gt;pOldRXMsg) ? 0 : -1;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}

// if a message is in the queue available it will be processed
void APMessageProcess (TAP * pAP) {
	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID				recvID;

	// search msg list
	pM = pMS-&gt;pOldRXMsg;

	// if there is no message we will return
	if (!pM) return;

	// unchain first message
	APMSunchainMessage(pMS, pM, NULL);

	// check header
	recvID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
	if ((recvID == dAPNodeID_ALL) || (recvID == pAP-&gt;nodeID)) {
		APHandleMsg (pAP,pM);
	}
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
}
</Code><Code idCode="235">// ===============================
// driver uuid =3
// ===============================

// struct for the drv data
typedef struct SMSP430uartDrv {
	TAPMsgHeader				h;			//!&lt; transmit header template
	TAPReceiveStateMachine		rxSM;		//!&lt; receive state machine
} TMSP430uartDrv;

TMSP430uartDrv gMSP430uartDrv;

// ------------------------------
// drv own functions
// ------------------------------

void drv_3_sendHeader (
		uint32_t msgId,
		uint32_t recv,
		uint32_t num,
		uint32_t length
	) {
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgTypeID] = msgId;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgNumber] = num;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_receiver] = recv;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_length] = length;
	msp430_UART_send((unsigned char *)gMSP430uartDrv.h,sizeof(TAPMsgHeader));
}


// function for feeding the recv state machine
void drv_3_feedRecvStateM () {
	uint32_t d;
	while (!stjFIFO_readElement(&amp;gMsp430_uartFIFO ,&amp;d)) {
		gMSP430uartDrv.rxSM.state (&amp;(gMSP430uartDrv.rxSM), &amp;d, 1);
	}
}
//open an existing driver and bind it to the AP
int drv_3_open (void * pAP, struct SAPMsgDrv *pDrv) {
	// init header
	gMSP430uartDrv.h[eAPMsgHeaderPosition_endian] = ((TAP *) pAP)-&gt;sysEndian;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_sender] = ((TAP *) pAP)-&gt;nodeID;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_receiver] = dAPNodeID_ALL;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgTypeID] = 0;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_msgNumber] = 0;
	gMSP430uartDrv.h[eAPMsgHeaderPosition_length] = 0;

	// save driver data
	pDrv-&gt;pDrvData = &amp;gMSP430uartDrv;

	// init receive state machine
	APInitReceiveStateMachine(
			&amp;gMSP430uartDrv.rxSM,
			((TAP *)pAP)-&gt;MS,
			pDrv
		);
	return 0;
}

//close the driver
int drv_3_close (struct SAPMsgDrv *pDrv) {
	return 0;
}
//destroys the driver
int drv_3_destroy (struct SAPMsgDrv *pDrv) {
	return 0;
}


//send raw data
int drv_3_sendRaw (struct SAPMsgDrv *pDrv, int amount, uint32_t *pData) {
	msp430_UART_send((unsigned char *)pData,amount*sizeof(uint32_t));
	return 0;
}


//acknowledge
int drv_3_ACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_ACK, receiver, mNum, 0);
	return 0;
}
//not acknowledge
int drv_3_NACK (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_NACK, receiver, mNum, 0);
	return 0;
}
//start sending a program
int drv_3_startPrg (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t globalVariableNumber, int32_t localVariableNumber, int32_t instructionNumber) {
	drv_3_sendHeader(eAPMsgTypes_startPrg, receiver, mNum, 0);
	msp430_UART_send((unsigned char *)&amp;globalVariableNumber,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;localVariableNumber,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;instructionNumber,sizeof(int32_t));
	return 0;
}

//sends a variable
int drv_3_sendVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, int32_t varTypeID, int32_t num) {
	drv_3_sendHeader(eAPMsgTypes_sendVariable, receiver, mNum, 3);
	msp430_UART_send((unsigned char *)&amp;index,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;varTypeID,sizeof(int32_t));
	msp430_UART_send((unsigned char *)&amp;num,sizeof(int32_t));
	return 0;
}
//sends an instruction
int drv_3_sendInstruction (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t index, uint32_t * fbc) {
	drv_3_sendHeader(eAPMsgTypes_sendInstruction, receiver, mNum, dAPInterpreterFuncMaxParams + 1);
	msp430_UART_send((unsigned char *)&amp;index,sizeof(int32_t));
	msp430_UART_send((unsigned char *)fbc,sizeof(int32_t) * (dAPInterpreterFuncMaxParams+1));
	return 0;
}
//sings that the program transmission has completed
int drv_3_endPrg (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_endPrg, receiver, mNum, 0);
	return 0;
}
//stops the AP
int drv_3_stop (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_stop, receiver, mNum, 0);
	return 0;
}
//the AP executes one instruction
int drv_3_step (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_step, receiver, mNum, 0);
	return 0;
}
//the AP runs the program
int drv_3_run (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_run, receiver, mNum, 0);
	return 0;
}
//a variable going to be updated
int drv_3_updateVariable (void *pDrvData, uint32_t receiver, uint32_t mNum, int32_t gIndex, int32_t dataElements) {
	drv_3_sendHeader(eAPMsgTypes_updateVariable, receiver, mNum, dataElements + 1);
	msp430_UART_send((unsigned char *)&amp;gIndex,sizeof(int32_t));
	return 0;
}
//a AP is going to be logged in to the system
int drv_3_login (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_login, receiver, mNum, 0);
	return 0;
}
//a AP is going to be logged out of the system
int drv_3_logout (void *pDrvData, uint32_t receiver, uint32_t mNum) {
	drv_3_sendHeader(eAPMsgTypes_logout, receiver, mNum, 0);
	return 0;
}</Code><Code idCode="236">// ===============================
// startup code for the audio processor
// ===============================



/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,pAP-&gt;sysEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,pAP-&gt;sysEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

// needed for the printf functions
int putchar(int v) {
	return v;
}

// the main function
int main()
{
	TAP AP;
	int rc;

	TAPMsgDrv UARTdrv;

	msp430_start();

	APdrviver_3_init(&amp;UARTdrv);

	rc = APinit(&amp;AP,430,&amp;UARTdrv,1,50,eAP_littleEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
#endif


	if (rc) goto exit;

	rc = APInterpreterSetState (AP.IP,AP.sysEndian,eAPInterpreterState_run);
	if (rc) goto exit;

	APInterpreterProcessState(AP.IP);
#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif


exit:
	msp430_LCD_cmdClear();
	msp430_LCD_print(0,0,&quot;AP shout down ...&quot;);
	APdelete(&amp;AP);

	return 0;
}
</Code><Code idCode="237">// ===============================
// variable implementation for panel UI(var id = 100)
// ===============================

typedef struct SMSP430_panel {
	unsigned char dummy;
} TMSP430_panel;

// updates a variable the AP
int HALimpl_100_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_100_create (unsigned int numberOfElements) {
	TMSP430_panel * pP;

	if (numberOfElements != 1) return NULL;
	pP = malloc(sizeof(TMSP430_panel));
	if (!pP) return NULL;
	return pP;
}
// updates the vars at the other APs
int HALimpl_100_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_100_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_100_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="238">// ===============================
// variable implementation for button UI(var id = 101)
// ===============================

typedef struct SMSP430_button {
	unsigned char port1Mask;
} TMSP430_button;

// updates a variable the AP
int HALimpl_101_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_101_create (unsigned int numberOfElements) {
	TMSP430_button * pB;

	if (numberOfElements != 1) return NULL;
	pB = malloc(sizeof(TMSP430_button));
	if (!pB) return NULL;
	pB-&gt;port1Mask = 0;
	return pB;
}
// updates the vars at the other APs
int HALimpl_101_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_101_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_101_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="239">// ===============================
// variable implementation for led UI(var id = 102)
// ===============================

typedef struct SMSP430_LED {
	unsigned int port3mask;
} TMSP430_LED;

// updates a variable the AP
int HALimpl_102_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_102_create (unsigned int numberOfElements) {
	TMSP430_LED * pLed;

	if (numberOfElements != 1) return NULL;
	pLed = malloc(sizeof(TMSP430_LED));
	if (!pLed) return NULL;
	pLed-&gt;port3mask = 0;
	return pLed;
}
// updates the vars at the other APs
int HALimpl_102_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_102_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_102_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="240">// ===============================
// variable implementation for display UI(var id = 103)
// ===============================

typedef struct SMSP430_display {
	unsigned char dummy; 
} TMSP430_display;


// updates a variable the AP
int HALimpl_103_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_103_create (unsigned int numberOfElements) {
	TMSP430_display * pDisp;

	if (numberOfElements != 1) return NULL;
	pDisp = malloc(sizeof(TMSP430_display));
	if (!pDisp) return NULL;
	return pDisp;
}
// updates the vars at the other APs
int HALimpl_103_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_103_decodeData (void * pVarData) {
return pVarData;
}
// delete the variable
void HALimpl_103_delete (void * pVarData) {
	free (pVarData);
}
</Code><Code idCode="241">// ===============================
// function implementation for uiSetDim(var id = 200)
// description: sets the dimension of a UI
// ===============================

void HALfunc_ID200_uiSetDim(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="242">// ===============================
// function implementation for uiInitPanel(var id = 201)
// description: inits a panel
// ===============================

void HALfunc_ID201_uiInitPanel(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the pannel
	int32_t uiUUID = pParams[0].fp_integer;
// parameter p descr: panel
	TMSP430_panel * pP = pParams[1].fp_pD;
// parameter pIndex descr: panel index
	int32_t Index = pParams[2].fp_integer;

	if (uiUUID != 1) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -102;
		return;
	}

	// do nothing
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="243">// ===============================
// function implementation for uiInitButton(var id = 202)
// description: inits a button
// ===============================

void HALfunc_ID202_uiInitButton(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the button
	int32_t UUID = pParams[0].fp_integer;
// parameter b descr: button
	TMSP430_button * pb = pParams[1].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TMSP430_panel * pp = pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if ((bIndex) || (pIndex)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
		return;
	}
	switch (UUID) {
		case 21:
			pb-&gt;port1Mask = BIT5;
			break;
		case 22:
			pb-&gt;port1Mask = BIT6;
			break;
		case 23:
			pb-&gt;port1Mask = BIT7;
			break;
		default:
			((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -102;
			return;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="244">// ===============================
// function implementation for uiInitDisplay(var id = 203)
// description: inits a display
// ===============================

void HALfunc_ID203_uiInitDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the display
	int32_t UUID = pParams[0].fp_integer;
// parameter b descr: button
	TMSP430_display * pd = pParams[1].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TMSP430_panel * pp = pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if ((dIndex) || (pIndex)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
		return;
	}
	if (UUID != 11) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -102;
		return;
	}
	// do nothing
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="245">// ===============================
// function implementation for uiInitLED(var id = 204)
// description: inits a LED
// ===============================

void HALfunc_ID204_uiInitLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter uiUUID descr: uuid of the LED
	int32_t UUID = pParams[0].fp_integer;
// parameter l descr: led
	TMSP430_LED * pl = pParams[1].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[2].fp_integer;
// parameter p descr: panel
	TMSP430_panel * pp = pParams[3].fp_pD;
// parameter pIndex descr: panel index
	int32_t pIndex = pParams[4].fp_integer;

	if ((lIndex) || (pIndex)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
		return;
	}
	switch (UUID) {
		case 31:
			pl-&gt;port3mask = BIT6;
			break;
		case 32:
			pl-&gt;port3mask = BIT7;
			break;
		default:
			((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -102;
			return;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="246">// ===============================
// function implementation for uiCheckButtonPressed(var id = 210)
// description: if the button was pressed the CF is set
// ===============================

void HALfunc_ID210_uiCheckButtonPressed(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter b descr: button
	TMSP430_button * pb = pParams[0].fp_pD;
// parameter bIndex descr: button index
	int32_t bIndex = pParams[1].fp_integer;

	if (bIndex) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
		return;
	}

	if (!(pb-&gt;port1Mask &amp; P1IN)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="247">// ===============================
// function implementation for uiSetLED(var id = 211)
// description: set the LED state
// ===============================

void HALfunc_ID211_uiSetLED(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter l descr: LED
	TMSP430_LED * pl = pParams[0].fp_pD;
// parameter lIndex descr: LED index
	int32_t lIndex = pParams[1].fp_integer;
// parameter onFlag descr: if the flag is not zero the LED is turned on
	int32_t onFlag = pParams[2].fp_integer;

	if (lIndex) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
		return;
	}

	if (onFlag) {
		P3OUT &amp;= ~pl-&gt;port3mask;
	} else {
		P3OUT |= pl-&gt;port3mask;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="248">// ===============================
// function implementation for uiSetDisplay(var id = 212)
// description: set the text of a display
// ===============================

void HALfunc_ID212_uiSetDisplay(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter d descr: display
	TMSP430_display * pd = pParams[0].fp_pD;
// parameter dIndex descr: display index
	int32_t dIndex = pParams[1].fp_integer;
// parameter s descr: the string
	TAPstringVector * pSV = pParams[2].fp_pD;
// parameter iString descr: index of the string at the array
	int iString = (int) pParams[3].fp_integer;

	msp430_LCD_print(0,0,pSV-&gt;sv[iString].szTxt);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="249">// ===============================
// AP uuid = 12
// ===============================



// inits the AP
int APinit (
			TAP *				pAP,
			TAPNodeID			nodeID,
			const TAPMsgDrv *	pDrvList,
			const int			driverNumber,
			size_t				messagePoolSize,
			int					sysEndian
		)
{
	pAP-&gt;nodeID = nodeID;
	pAP-&gt;pNodeList = NULL;
	pAP-&gt;pDrvList = pDrvList;
	pAP-&gt;sysEndian = sysEndian;
	pAP-&gt;driverNumber = driverNumber;
	pAP-&gt;msgSysMMU = AP_MMU_create(messagePoolSize);
	pAP-&gt;IP = APInterpreterCreate(pAP);
	pAP-&gt;MS = APMScreate (pAP-&gt;msgSysMMU,sysEndian);
	pAP-&gt;msgNumber = 0;
	pAP-&gt;APstate = eAPstate_idle;

	if(
		(!pAP-&gt;msgSysMMU)||
		(!pAP-&gt;IP)||
		(!pAP-&gt;MS)
		) return -1;
	// init drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pDrvList;
	int i;
	for (i = 0; i &lt; driverNumber; i++) {
		pDrv-&gt;pfkt_open(pAP, pDrv);
		pDrv++;
	}

	// login the ap to the message system
	return TX_login(pAP);
}

// deletes the AP
void APdelete (TAP * pAP)
{
	// close &amp; destroy drv
	TAPMsgDrv * pDrv = (TAPMsgDrv *)pAP-&gt;pDrvList;
	int i;
	for (i = 0; i &lt; pAP-&gt;driverNumber; i++) {
		pDrv-&gt;pfkt_close(pDrv);
		pDrv-&gt;pfkt_destroy(pDrv);
		pDrv++;
	}

	APMSdelete (pAP-&gt;MS);
	APInterpreterDelete(pAP-&gt;IP);
	AP_MMU_delete(pAP-&gt;msgSysMMU);
}

// find a node at the list
TAPNode * APfindNode(TAP * pAP, TAPNodeID nodeID) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == nodeID) return pN;
		pN = pN-&gt;pNext;
	};
	return NULL;
}

// adds a new node to the node list
int APaddNode(TAP * pAP, TAPNodeID newNodeID, const TAPMsgDrv * pDrv) {
	if (APfindNode(pAP,newNodeID)) return 1;
	TAPNode * pN = (TAPNode *) malloc(sizeof(TAPNode));
	if (!pN) return -1;
	pN-&gt;nodeID = newNodeID;
	pN-&gt;pDrv = pDrv;
	pN-&gt;pNext = pAP-&gt;pNodeList;
	pAP-&gt;pNodeList = pN;
	return 0;
}

// removes a node from the node list
void APremoveNode(TAP * pAP, TAPNodeID nodeID){
	TAPNode * pAntN = pAP-&gt;pNodeList; // antecessor node
	TAPNode * pActN = pAP-&gt;pNodeList; // actual node

	while (pActN) {
		// compare node id's
		if (pActN-&gt;nodeID == nodeID) {
			// unchain

			// check if we at the first position at the list
			if (pAP-&gt;pNodeList == pAntN) {
				// reset the pointer
				pAP-&gt;pNodeList = pActN-&gt;pNext;
			} else {
				// set the antecessor
				pAntN-&gt;pNext = pActN-&gt;pNext;
			}
			// free node
			free(pActN);
			// and abort
			return;
		}
		// the actual element becomes the precessor element
		pAntN = pActN;
		pActN = pActN-&gt;pNext;
	}
}

// get a new message number
unsigned int APgetNewMessageNumber (TAP *pAP) {
	pAP-&gt;msgNumber++;
	return pAP-&gt;msgNumber;
}

// find the driver associated with der nodeID
const TAPMsgDrv * APfindDrvBySenderID (TAP * pAP, TAPNodeID node) {
	TAPNode * pN = pAP-&gt;pNodeList;
	while (pN) {
		if (pN-&gt;nodeID == node) {
			return pN-&gt;pDrv;
		}
		pN = pN-&gt;pNext;
	}
	return NULL;
}

// runs the AP
int APrun(TAP *pAP) {
	pAP-&gt;APstate = eAPstate_run;
	return 0;
}


typedef struct SAPrealMMUMemory {
	int * 						pData;			// the data
	size_t						count;			// amount of data elements
	struct SAPrealMMUMemory *	pNext;			// next element
	struct SAPrealMMUMemory *	pPrev;			// previous element
} TAPrealMMUMemory;

//the mmu type
typedef struct SAPrealMMU {
	int * 					memory;				// the memory bolck
	TAPrealMMUMemory *		pStart;				// first element
	TAPrealMMUMemory *		pEnd;				// second element
	TAPrealMMUMemory *		pUnusedList;		// list with the unused elements
	int * 					pUnusedData;		// pointer to the unused memory
	size_t					elementsAvailable; 	// amount of elements witch are available without using the garbage collector
	size_t					totalAvailable;		// total amount of free bytes

} TAPrealMMU;

// ========================================
// memory entry functions
// ========================================

// a little macro for unchaining an element
#define DMemoryEntryUnchain(pM) \
	if (pM-&gt;pNext) pM-&gt;pNext-&gt;pPrev = pM-&gt;pPrev; \
	if (pM-&gt;pPrev) pM-&gt;pPrev-&gt;pNext = pM-&gt;pNext


//creates an memory entry
TAPrealMMUMemory * MemoryEntry_create () {
	TAPrealMMUMemory * pM = NULL;

	pM = (TAPrealMMUMemory *) malloc(sizeof(TAPrealMMUMemory));
	if (!pM) return NULL;
	pM-&gt;pData = NULL;
	pM-&gt;count = 0;
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;

	return pM;
}

//deletes an memory Entry
void MemoryEntry_delete (
		TAPrealMMUMemory * pM	// the memory to delete
		)
{
	// put the entry out of the chain
	DMemoryEntryUnchain(pM);
	// now we delete it
	free(pM);
}

// ========================================
// mmu helper
// ========================================

//alloc if needed a new memory entry
TAPrealMMUMemory * MMU_helper_createMemoryEntry (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	// check if we have to alloc a new memory entry
	if (!pMMU-&gt;pUnusedList) return MemoryEntry_create();
	// no there is some left at the list
	TAPrealMMUMemory * pM;
	// take the first one
	pM = pMMU-&gt;pUnusedList;
	// reset the list
	pMMU-&gt;pUnusedList = pM-&gt;pNext;
	// now unchain the element (for sure)
	DMemoryEntryUnchain(pM);
	// set the element pointers
	pM-&gt;pNext = NULL;
	pM-&gt;pPrev = NULL;
	return pM;
}

//the garbage collector
void MMU_helper_garbageCollector (
		TAPrealMMU *	pMMU 		// MMU structure to init
		)
{
	TAPrealMMUMemory * pM = pMMU-&gt;pStart;
	int * pD = pMMU-&gt;memory;
	while (pM) {
		// check if we have to move the data
		if (pD != pM-&gt;pData) {
			// move the data
			memmove(pD,pM-&gt;pData,pM-&gt;count*sizeof(int));
		}
		// reset the destination pointer
		pD += pM-&gt;count;
		pM = pM-&gt;pNext;
	}
	// compressing memory finished
	// set the mmu vars new
	pMMU-&gt;elementsAvailable = pMMU-&gt;totalAvailable;
	pMMU-&gt;pUnusedData = pD;
}



// create a mmu
TAPMMU AP_MMU_create (size_t elementsNumber) {
	TAPrealMMU * pMMU;

	pMMU = (TAPrealMMU *) malloc (sizeof(TAPrealMMU));
	if (!pMMU) return NULL;



	// setup lists
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
	pMMU-&gt;pUnusedList = NULL;

	pMMU-&gt;elementsAvailable =elementsNumber;
	pMMU-&gt;pUnusedData = (int *) malloc (pMMU-&gt;elementsAvailable);
	pMMU-&gt;totalAvailable = pMMU-&gt;elementsAvailable;
	return pMMU;
}

// destroying the mmu
void AP_MMU_delete (TAPMMU mmu) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	TAPrealMMUMemory * pM;
	TAPrealMMUMemory * pMnext;

// 1. delete al mmu entry's
	// 1.1 unused entry
	pM = pMMU-&gt;pUnusedList;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pUnusedList = NULL;
	// 1.2 used blocks
	pM = pMMU-&gt;pStart;
	while (pM) {
		pMnext = pM-&gt;pNext;
		MemoryEntry_delete(pM);
		pM = pMnext;
	}
	pMMU-&gt;pStart = NULL;
	pMMU-&gt;pEnd = NULL;
// 2. delete mmu memory
	free (pMMU-&gt;memory);


}
// getting memmory from the mmu
TAPMMUmemmory AP_MMU_get (TAPMMU mmu, size_t elements) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;

	// check if there is enough space
	if (pMMU-&gt;totalAvailable &lt; elements) goto error;
	// check if we have to use the garbage collector
	if (pMMU-&gt;elementsAvailable &lt; elements) {
		// start garbage collector
		MMU_helper_garbageCollector(pMMU);
	}
	// we have enough memory so let's allocate some

	// get a new entry
	TAPrealMMUMemory * pM;
	pM = MMU_helper_createMemoryEntry(pMMU);
	if (!pM) return NULL;
	// get some memory
	pM-&gt;pData = pMMU-&gt;pUnusedData;
	pM-&gt;count = elements;
	// refresh data
	pMMU-&gt;pUnusedData += elements;
	pMMU-&gt;totalAvailable -= elements;
	pMMU-&gt;elementsAvailable -= elements;
	// insert memory element at the end of the list and update last element
	pM-&gt;pPrev = pMMU-&gt;pEnd;
	if (pMMU-&gt;pEnd) pMMU-&gt;pEnd-&gt;pNext = pM;
	if (!pMMU-&gt;pStart) pMMU-&gt;pStart = pM;
	pMMU-&gt;pEnd = pM;

	return pM;
error:

	return NULL;
}

// free memmory from the mmu
void AP_MMU_free (TAPMMU mmu, TAPMMUmemmory memory) {
	TAPrealMMU * pMMU = (TAPrealMMU *) mmu;
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;

	if (!pM) return;
	// set mmu settings
	if (pMMU-&gt;pStart == pM) pMMU-&gt;pStart = pM-&gt;pNext;
	if (pMMU-&gt;pEnd == pM) pMMU-&gt;pEnd = pM-&gt;pPrev;
	// unchain element
	DMemoryEntryUnchain (pM);
	// and put it to the chain of unused
	pM-&gt;pNext = pMMU-&gt;pUnusedList;
	pM-&gt;pPrev = NULL;
	if (pMMU-&gt;pUnusedList) {
		pMMU-&gt;pUnusedList-&gt;pPrev = pM;
	}
	pMMU-&gt;pUnusedList = pM;
	// now set the mmu data new
	pMMU-&gt;totalAvailable += pM-&gt;count;

}

// getting access to the MMU data
void * AP_MMU_getData (TAPMMUmemmory memory) {
	TAPrealMMUMemory * pM = (TAPrealMMUMemory *) memory;
	return pM-&gt;pData;
}

// ========================================
// the AP interpreter (thread save)
// ========================================

// the real interpreter
typedef struct SAPrealInterpreter {
	TAP *						pAP;					// pointer to the audio processor
	int							state;					// state of the IP
	int							nextState;				// the next state of the IP
	TAPInterpreterCPU			cpu;					// the IP core
	TAPInterpreterFuncCall *	code;					// the code
	int32_t						instructionCount;		// number of instructions at the code
	TAPInterpreterVariable *	variables;				// the variables
	int32_t						variableCount;			// number of the variables
	pthread_mutex_t				gM;						// a guarding mutex
} TAPrealInterpreter;

// create a new interpreter
TAPInterpreter APInterpreterCreate (void * pAP) {
	TAPrealInterpreter * pIP = NULL;
	pIP = (TAPrealInterpreter *) malloc (sizeof(TAPrealInterpreter));
	if (!pIP) return NULL;

	pIP-&gt;pAP = pAP;
	pIP-&gt;state = eAPInterpreterState_idle;
	pIP-&gt;nextState = eAPInterpreterState_idle;
	pIP-&gt;cpu.IP = pIP;
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pCodeStart = NULL;
	pIP-&gt;cpu.pCodeEnd = NULL;
	pIP-&gt;cpu.pIP = NULL;

	pIP-&gt;code = NULL;
	pIP-&gt;instructionCount = 0;

	pIP-&gt;variables = NULL;
	pIP-&gt;variableCount = 0;

	pIP-&gt;gM = PTHREAD_MUTEX_INITIALIZER;

	return pIP;
}

// cleans the interpreter
void APInterpreterClean (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	// clean code
	if (pIP-&gt;code) {
		free (pIP-&gt;code);
		pIP-&gt;code = NULL;
	}
	pIP-&gt;instructionCount = 0;

	// clean variables
	TAPInterpreterVariable * pV = pIP-&gt;variables;
	int i;
	for (i = 0; i &lt; pIP-&gt;variableCount; i++) {
		if (pV-&gt;pVI) pV-&gt;pVI-&gt;pFkt_delete(pV-&gt;pData);
		pV++;
	}
	if (pIP-&gt;variables) {
		free (pIP-&gt;variables);
		pIP-&gt;variables = NULL;
	}
	pIP-&gt;variableCount = 0;

}

// deletes the interpreter
void APInterpreterDelete (TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	APInterpreterClean(IP);
	free (pIP);
}

int APInterpreterStateRun(TAPInterpreter IP) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	TAPInterpreterFuncCall * pFC;

	// setup cpu
	pIP-&gt;cpu.CF = 0;
	pIP-&gt;cpu.EF = 0;
	pIP-&gt;cpu.pIP = pIP-&gt;code;
	pIP-&gt;cpu.pCodeStart = pIP-&gt;code;
	pIP-&gt;cpu.pCodeEnd = pIP-&gt;code + pIP-&gt;instructionCount;

	// run code
	while (eAPInterpreterState_run == pIP-&gt;state) {

		pthread_mutex_lock(&amp;pIP-&gt;gM);

		pFC = pIP-&gt;cpu.pIP;
		// check if we reached the end of the code
		if (pFC &gt; pIP-&gt;cpu.pCodeEnd) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return 0;
		}
		// execute command
		pFC-&gt;pHALFkt (&amp;(pIP-&gt;cpu), pFC-&gt;param);
		// check error flags
		if (pIP-&gt;cpu.EF) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -1;
		}
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
	}
	return 1;
}


// process the actual state
int APInterpreterProcessState(TAPInterpreter IP){
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	pIP-&gt;state = pIP-&gt;nextState;
	int rc = 0;

	switch (pIP-&gt;state) {
		case eAPInterpreterState_idle:
			break;
		case eAPInterpreterState_loadProgramm:
			break;
		case eAPInterpreterState_run:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			rc = APInterpreterStateRun(IP);
			pthread_mutex_lock(&amp;pIP-&gt;gM);
			if (rc &gt;= 0) pIP-&gt;state = eAPInterpreterState_idle;
			break;
		case eAPInterpreterState_oneStep:
			break;
		case eAPInterpreterState_halt:
			break;
		default:
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -10;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return rc;
}


// set interpreter state
int APInterpreterSetState (TAPInterpreter IP, int msgEndian, int32_t state) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	pthread_mutex_lock(&amp;pIP-&gt;gM);
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;state);
	}
	pIP-&gt;nextState = (int) state;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// setup the interpreter for a new program
int APInterpreterInitNewProgramm (TAPInterpreter IP, int msgEndian, int32_t instructionsNumber, int32_t VariableNumber) {
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;
	int i;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	APInterpreterClean (IP);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;instructionsNumber);
		APendianConversation32Bit((uint32_t *)&amp;VariableNumber);
	}

	pIP-&gt;code = (TAPInterpreterFuncCall *) malloc(sizeof(TAPInterpreterFuncCall)*instructionsNumber);
	pIP-&gt;instructionCount = instructionsNumber;

	pIP-&gt;variables = (TAPInterpreterVariable *) malloc(sizeof(TAPInterpreterVariable) * (VariableNumber));
	for (i = 0; i &lt; VariableNumber;i++) {
		pIP-&gt;variables[i].pData = NULL;
		pIP-&gt;variables[i].pVI = NULL;
	}
	pIP-&gt;variableCount = VariableNumber;

	pthread_mutex_unlock(&amp;pIP-&gt;gM);

	return 0;
}

// load a variable/~array to an index
int APInterpreterLoadVar (TAPInterpreter IP, int msgEndian, int32_t index, int32_t varTypeID, int32_t numberOfElements)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
		APendianConversation32Bit((uint32_t *)&amp;varTypeID);
	}

	if ((index &lt; 0) || (index &gt; pIP-&gt;variableCount)) return -1;

	// set pointer to the runtime variable
	TAPInterpreterVariable * pRTV = pIP-&gt;variables + index;
	THAL_Variable const * pV = HALfindVar(varTypeID);
	if (!pV) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}

	pRTV-&gt;pData = pV-&gt;pFkt_create((unsigned int)numberOfElements);
	//if (!pRTV-&gt;pData) return -3;

	pRTV-&gt;pVI = pV;
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// load a single Instruction to an index
int APInterpreterLoadInstr (TAPInterpreter IP,int msgEndian, int32_t index, int32_t * pRawInstr)
{
	TAPrealInterpreter * pIP = (TAPrealInterpreter *) IP;

	pthread_mutex_lock(&amp;pIP-&gt;gM);

	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;index);
	}
	if ((index &lt; 0) || (index &gt; pIP-&gt;instructionCount)){
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -1;
	}
	TAPInterpreterFuncCall * pIFC = pIP-&gt;code + index;
	memset (pIFC, 0, sizeof(TAPInterpreterFuncCall));

	// get function
	int32_t fid = *pRawInstr;
	if (msgEndian != pIP-&gt;pAP-&gt;sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;fid);
	}
	THALFunction const * pF = HALfindFunction(fid);
	if (!pF) {
		pthread_mutex_unlock(&amp;pIP-&gt;gM);
		return -2;
	}
	pIFC-&gt;pHALFkt = pF-&gt;pfktHAL;

	// convert parameters
	pRawInstr++; // set to the first parameter
	int i;
	THALFunctionParam const * pP = pF-&gt;paramList.pL;
	TuAPInterpreterFunctionParameter * pIFP = pIFC-&gt;param;
	for (i = 0; i &lt; pF-&gt;paramList.number; i++) {
		if (APconvertRawParamData (msgEndian,APInterpreterGetAPfromIP(IP),pRawInstr,pP,pIFP,pIP-&gt;variables)) {
			pthread_mutex_unlock(&amp;pIP-&gt;gM);
			return -3;
		}
		pP++;
		pRawInstr++;
		pIFP++;
	}
	pthread_mutex_unlock(&amp;pIP-&gt;gM);
	return 0;
}

// gets the varaible by it's index
TAPInterpreterVariable * APInterpreterGetVariableByIndex (TAPInterpreter IP, int index) {
	return &amp;(((TAPrealInterpreter *) IP)-&gt;variables[index]);
}

// gets the AP from the IP
void * APInterpreterGetAPfromIP (TAPInterpreter IP) {
	return ((TAPrealInterpreter *) IP)-&gt;pAP;
}

// ========================================
// the AP message system (thread save)
// ========================================

// ========================================
// the AP message system (thread save)
// ========================================

typedef struct SAPrealMsgSystem {
	TAPMsg * 			pOldRXMsg;		// pointer to the oldest received messages
	TAPMsg * 			pNewRXMsg;		// pointer to the newest received messages
	TAPMMU				mmu;			// the mmu
	int					sysEndianness;	// the system endianness
	int					messagecounter;	// a counter for checkin if a new message has been received

	sem_t				waitSem;		// a semaphore to wait for a message
	int					getMsgCounter;	// a counter incremented how many threads calling getMsg and are waiting
	pthread_mutex_t		gM;				// a guarding mutex
} TAPrealMsgSystem;


int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	);

int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	);



// create AP message system
TAPMsgSystem APMScreate (
		TAPMMU				mmu,			// the mmu
		int					sysEndianness	// the system endianness
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) malloc (sizeof(TAPrealMsgSystem));
	if (!pMS) return NULL;
	pMS-&gt;mmu = mmu;
	pMS-&gt;sysEndianness = sysEndianness;
	pMS-&gt;pOldRXMsg = NULL;
	pMS-&gt;pNewRXMsg = NULL;
	pMS-&gt;messagecounter = 0;

	pMS-&gt;gM = PTHREAD_MUTEX_INITIALIZER;
	sem_init (&amp;pMS-&gt;waitSem,0,0);
	pMS-&gt;getMsgCounter = 0;

	return pMS;
}

void APMSdelete (
	TAPMsgSystem ms
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	sem_destroy(&amp;pMS-&gt;waitSem);
	free (pMS);
}


// frees a message from the message system
void APMSdeleteMsg (
	TAPMsgSystem 	ms,
	TAPMsg *		pM
	) {
	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	AP_MMU_free(pMS-&gt;mmu,pM-&gt;memory);

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
}

// get memory for a new message
TAPMsg * APMSgetNewMsg (
		TAPrealMsgSystem *	pMsgSys,
		int					dataElementsNumber,
		const TAPMsgDrv *	pDrv
		) {
	pthread_mutex_lock(&amp;pMsgSys-&gt;gM);

	TAPMMUmemmory m = AP_MMU_get (pMsgSys-&gt;mmu,sizeof(TAPMsg)/sizeof(int) + dataElementsNumber*sizeof(uint32_t)/sizeof(int));
	if (!m) return NULL;

	int * pRD = (int *) AP_MMU_getData(m);
	TAPMsg * pM = (TAPMsg *) pRD;
	pM-&gt;memory = m;
	pM-&gt;extraData.pDrv = pDrv;
	pM-&gt;pH = (TAPMsgHeader *)((int *) pRD + sizeof(TAPMsg)/sizeof(int));
	pM-&gt;pData = (int *)pM-&gt;pH + sizeof(TAPMsgHeader)/sizeof(int);
	pM-&gt;pNext = NULL;

	pthread_mutex_unlock(&amp;pMsgSys-&gt;gM);
	return pM;
}

// insert a new message into the message queue
void APMSInsertMsg (
		TAPrealMsgSystem *	pMS,
		TAPMsg *			pM
	) {
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	if (pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg-&gt;pNext = pM;
	}
	pMS-&gt;pNewRXMsg = pM;
	if (!pMS-&gt;pOldRXMsg) {
		pMS-&gt;pOldRXMsg = pM;
	}
	pMS-&gt;messagecounter++;

	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	sem_post(&amp;pMS-&gt;waitSem);
}

// get oldest message
TAPMsg * APMSgetMsg (
		TAPMsgSystem 		ms,				// the message system
		TAPMessageID		msgID,			// if 0 all messages are allowed
		TAPNodeID			sender,			// if 0 all senders are allowed
		uint32_t			mNumber,		// if 0 all numbers are allowed
		int					ackMsgAllowed
	) {

	TAPrealMsgSystem * pMS = (TAPrealMsgSystem *) ms;
	// flags
	int senderOK;
	int msgIDok;
	int numberOK;
	// result var
	TAPMsg * res = NULL;

	pthread_mutex_lock(&amp;pMS-&gt;gM);
	pMS-&gt;getMsgCounter++;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);

checkMessages:
	pthread_mutex_lock(&amp;pMS-&gt;gM);

	// search msg list
	TAPMsg * pM = pMS-&gt;pOldRXMsg;
	TAPMsg * pAntecessorM =  NULL;
	uint32_t * pH;

	if (!pM) goto waitForMessage;


	senderOK = 0;
	msgIDok = 0;
	numberOK = 0;

	pH = *(pM-&gt;pH);

	if (!sender) {
		senderOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_sender] == sender) senderOK = 1;
	}
	if (!msgID) {
		// filter ack/nack msg
		if (ackMsgAllowed) {
			msgIDok = 1;
		} else {
			if (
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_ACK)  &amp;&amp;
					(pH[eAPMsgHeaderPosition_msgTypeID] != eAPMsgTypes_NACK)
				) {
				msgIDok = 1;
			}
		}
	} else {
		if (pH[eAPMsgHeaderPosition_msgTypeID] == msgID) msgIDok = 1;
	}
	if (!mNumber) {
		numberOK = 1;
	} else {
		if (pH[eAPMsgHeaderPosition_msgNumber] == mNumber) numberOK = 1;
	}
	if ((senderOK) &amp;&amp; (msgIDok) &amp;&amp; (numberOK)) {
		res = pM;
		goto exit;
	}
	pAntecessorM = pM;
	pM = pM-&gt;pNext;
	if (pM) goto checkMessages;
waitForMessage:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	if (sem_wait(&amp;(pMS-&gt;waitSem)) == -1) goto error;

	// if other threads are waiting for a message give the sign to them
	pthread_mutex_lock(&amp;pMS-&gt;gM);
	if (pMS-&gt;getMsgCounter &gt; 1) {
		if (sem_post(&amp;pMS-&gt;waitSem) == -1) goto error;
	}
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	goto checkMessages;

exit:
	if (pAntecessorM) {
		pAntecessorM-&gt;pNext = pM-&gt;pNext;
	} else {
		pMS-&gt;pOldRXMsg = pM-&gt;pNext;
	}
	if (pM == pMS-&gt;pNewRXMsg) {
		pMS-&gt;pNewRXMsg = NULL;
	}

	// now there is one message less left
	pMS-&gt;messagecounter--;
	// now one thread is less waiting for a message
	pMS-&gt;getMsgCounter--;
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return res;
error:
	pthread_mutex_unlock(&amp;pMS-&gt;gM);
	return NULL;
}

// ========================================
// the receive state machine
// ========================================

// the receive state machine state function for receiving the msg header
int SMinitial (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPrealMsgSystem *					pMS = (TAPrealMsgSystem *) pSM-&gt;pMS;
	int 								copyAmount = number;
	int									i;

	// 1. try to copy the data to the header
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	pSM-&gt;elementsLeft -= copyAmount;

	// check if we have to change the statemachine because we received the header
	if (pSM-&gt;elementsLeft) return 0;

	// yes! alloc msg buffer and (opt.) transfer data

	// 2. convert endian
	int msgEndian = pSM-&gt;header[eAPMsgHeaderPosition_endian];
	if (pMS-&gt;sysEndianness != msgEndian) {
		for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
			APendianConversation32Bit(&amp;pSM-&gt;header[i]);
		}
	}
	// 3. now alloc message
	// 3.1 get length
	int msgElementNumber = (int) pSM-&gt;header[eAPMsgHeaderPosition_length];
	// 3.2. get memory
	pSM-&gt;pMsg = APMSgetNewMsg (pMS,msgElementNumber,pSM-&gt;pDrv);
	if (!pSM-&gt;pMsg) return -100;

	// 3.3 check getMemory result
	if (!pSM-&gt;pMsg) return -1;
	// copy message header
	pSM-&gt;pD = (uint32_t *) pSM-&gt;pMsg-&gt;pH;
	for (i = 0; i &lt; eAPMsgHeaderPosition_headerElementNumber;i++) {
		*pSM-&gt;pD = pSM-&gt;header[i];
		pSM-&gt;pD++;
	}
	pSM-&gt;elementsLeft = pSM-&gt;header[eAPMsgHeaderPosition_length];
	// set up the data
	// 1. check if there is an data element
	if (!pSM-&gt;elementsLeft) {
		// no! now finish the message
		return SMmessageFinished(pVoidSM);
	}
	// 2. yes
	// 2.1 setup the sm for the data receiving
	pSM-&gt;state = SMdata;
	// 2.2 now check if we have to copy some data
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return SMdata (pVoidSM,pD,number);
	}
	return 0;
}


// the receive state machine state function for receiving the data
int SMdata (
		void *			pVoidSM,		// pointer to the statemachine
		uint32_t * 		pD,				// pointer to the data
		int				number			// the number of data elements
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	int 								copyAmount = number;
	int									i;
	// 1. transfer the data
	// do some clipping
	if (pSM-&gt;elementsLeft &lt; copyAmount) copyAmount = pSM-&gt;elementsLeft;
	// copy
	for (i = 0; i &lt; copyAmount;i++) {
		*pSM-&gt;pD = *pD;
		pSM-&gt;pD++;
		pD++;
	}
	// set statemachine work data
	pSM-&gt;elementsLeft -= copyAmount;
	// check if we have to change the statemachine
	if (pSM-&gt;elementsLeft) return 0;
	int res = SMmessageFinished (pVoidSM);
	if (res) return res;

	// check if there some bytes left to copy
	number -= copyAmount;
	if (number) {
		// set the data pointer
		pD += copyAmount;
		// and copy the data
		return pSM-&gt;state (pVoidSM,pD,number);
	}
	return 0;

}

// this function is called when all data have been received
int SMmessageFinished (
		void *			pVoidSM		// pointer to the statemachine
	) {
	TAPReceiveStateMachine * 			pSM = (TAPReceiveStateMachine *) pVoidSM;
	TAPMsg *							pM;
	// 1. reset SM
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pM = pSM-&gt;pMsg; // save msg info for inserting
	pSM-&gt;pMsg = NULL;

	// right state function
	pSM-&gt;state = SMinitial;		// the state

	// 2. insert message at the message system
	APMSInsertMsg ((TAPrealMsgSystem *)pSM-&gt;pMS,pM);
	return 0;
}


// inits the state machine
void APInitReceiveStateMachine (
		TAPReceiveStateMachine * 			pSM,	// pointer to the state machine
		TAPMsgSystem						pMS,	// pointer to the message system
		const TAPMsgDrv  *					pDrv	// the driver associated with the statemachine
	) {
	pSM-&gt;state = SMinitial;
	pSM-&gt;pMS = pMS;
	pSM-&gt;pDrv = pDrv;
	// set the helper
	pSM-&gt;elementsLeft = eAPMsgHeaderPosition_headerElementNumber;
	pSM-&gt;pD = pSM-&gt;header;

	// data
	pSM-&gt;pMsg = NULL;
}

int APHandleMsg (
		TAP *		pAP,
		TAPMsg * 	pM
	) {

	TAPMessageID								msgID;
	const THALMsgProcessMessageAssociation *	pMsgIDandFunctAsso;
	int											i;

	// get message id
	msgID = (*(pM-&gt;pH))[eAPMsgHeaderPosition_msgTypeID];
	// search handler
	pMsgIDandFunctAsso = gHALMsgProcessRXHandlers.pL;
	for (i = 0; i &lt; gHALMsgProcessRXHandlers.number;i++) {
		if (((TAPMessageID)pMsgIDandFunctAsso-&gt;msgID) == msgID) {
			return pMsgIDandFunctAsso-&gt;pfktHandle(pAP,pM);
		}
		pMsgIDandFunctAsso++;
	}
	return -1;
}

void APMessageProcessingThread (TAP * pAP) {

	TAPrealMsgSystem *		pMS = (TAPrealMsgSystem *) pAP-&gt;MS;
	TAPMsg *				pM;
	TAPNodeID 				recv;
	while (1) {
		// get the message
		pM = APMSgetMsg (pMS,0,0,0,0);
		if (!pM) goto error;
		// search the message handler
		recv = (*(pM-&gt;pH))[eAPMsgHeaderPosition_receiver];
		if ((recv == dAPNodeID_ALL) || (recv == pAP-&gt;nodeID)) {
			if(APHandleMsg (pAP,pM)) goto exit;
		}
		// free memory
		APMSdeleteMsg (pAP-&gt;MS,pM);
	}
exit:
	// free memory
	APMSdeleteMsg (pAP-&gt;MS,pM);
error:
	return;
}
</Code><Code idCode="250">// =================================================
// a generic biquad filter lib based on the math.h
// =================================================

// -----------------------------------------
// headers
// -----------------------------------------

// the biquad structure at the direct form II
typedef struct SBQF_BiquadDF2 {
	float	k;	// gain
	float	n1;	// numerator
	float	n2;
	float	d1; // denominator
	float	d2;
	float	s1; // delays
	float	s2;
} TBQF_BiquadDF2;

// a cascade of biquad filters
typedef struct SBQF_BiquadCascade {
	unsigned int	num;
	TBQF_BiquadDF2 *	pB;
} TBQF_BiquadCascade;

//! creates a cascade of biquad filters
int BQF_BQFcascadeCreate (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) pointer to a struct to be filled
		unsigned int 			num		//!&lt; amount of filters
	);

//! deletes a cascade of biquad filters
void BQF_BQFcascadeDelete (
		TBQF_BiquadCascade *	pBQC	//!&lt; (in) pointer to a struct to be freed
	);

//! convolut the input with the biquad filter cascade and generate the output (y = BQFc * x)
void BQF_BQFcascadeConvolute (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in) the biqaud cascade
		float * 				px,		//!&lt; (in) input signal vector
		unsigned int			xNum,	//!&lt; (in) amount of elements at the input vector
		float * 				py		//!&lt; (out) output signal vector (size must be more or equal to px)
	);

//! Initializes a element of the biquad cascade as high-pass(HP) filter
int BQF_BQFcascadeInitHP (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as HP
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc		//!&lt; (in) cut off frequency
	);

//! initializes a element of the biquad cascade as low-pass(LP) filter
int BQF_BQFcascadeInitLP (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as LP
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc		//!&lt; (in) cut off frequency
	);

//! initializes a element of the biquad cascade as peak boost/cut filter
int BQF_BQFcascadeInitPeak (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc,		//!&lt; (in) center frequency
		float					q,		//!&lt; (in) quality (Q infinty)
		float					g		//!&lt; (in) gain
	);

//! initializes a element of the biquad cascade as low frequency shelving filter
int BQF_BQFcascadeInitLowFreqShelving (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					f,		//!&lt; (in) cut/boost frequency
		float					q,		//!&lt; (in) quality (Q infinty)
		float					g		//!&lt; (in) gain
	);

//! initializes a element of the biquad cascade as high frequency shelving filter
int BQF_BQFcascadeInitHighFreqShelving (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					f,		//!&lt; (in) cut/boost frequency
		float					q,		//!&lt; (in) quality (Q infinty)
		float					g		//!&lt; (in) gain
	);

// -----------------------------------------
// code
// -----------------------------------------

// math defines
#ifndef M_E
	#define M_E		2.7182818284590452354
#endif

#ifndef M_LOG2E
	#define M_LOG2E		1.4426950408889634074
#endif

#ifndef M_LOG10E
	#define M_LOG10E	0.43429448190325182765
#endif

#ifndef M_LN2
	#define M_LN2		0.69314718055994530942
#endif

#ifndef M_LN10
	#define M_LN10		2.30258509299404568402
#endif

#ifndef M_PI
	#define M_PI		3.14159265358979323846
#endif

#ifndef M_PI_2
	#define M_PI_2		1.57079632679489661923
#endif

#ifndef M_PI_4
	#define M_PI_4		0.78539816339744830962
#endif

#ifndef M_1_PI
	#define M_1_PI		0.31830988618379067154
#endif

#ifndef M_2_PI
	#define M_2_PI		0.63661977236758134308
#endif

#ifndef M_2_SQRTPI
	#define M_2_SQRTPI	1.12837916709551257390
#endif

#ifndef M_SQRT2
	#define M_SQRT2		1.41421356237309504880
#endif

#ifndef M_SQRT1_2
	#define M_SQRT1_2	0.70710678118654752440
#endif



//! creates a cascade of biquad filters
int BQF_BQFcascadeCreate (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) pointer to a struct to be filled
		unsigned int 			num		//!&lt; amount of filters
	) {
	unsigned int i;

	pBQC-&gt;pB = malloc (sizeof(TBQF_BiquadDF2) * num);
	if (!pBQC-&gt;pB) {
		pBQC-&gt;num = 0;
		return -1;
	}
	pBQC-&gt;num = num;

	for (i = 0; i &lt; num; i++) {
		pBQC-&gt;pB[i].k = 0.0f;
		pBQC-&gt;pB[i].n1 = 0.0f;
		pBQC-&gt;pB[i].n2 = 0.0f;
		pBQC-&gt;pB[i].d1 = 0.0f;
		pBQC-&gt;pB[i].d2 = 0.0f;
		pBQC-&gt;pB[i].s1 = 0.0f;
		pBQC-&gt;pB[i].s2 = 0.0f;
	}
	return 0;
}

//! deletes a cascade of biquad filters
void BQF_BQFcascadeDelete (
		TBQF_BiquadCascade *	pBQC	//!&lt; (in) pointer to a struct to be freed
	) {
	free (pBQC-&gt;pB);
	pBQC-&gt;pB = NULL;
	pBQC-&gt;num = 0;
}

//! convolut the input with the biquad filter cascade and generate the output (y = BQFc * x)
void BQF_BQFcascadeConvolute (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in) the biqaud cascade
		float * 				px,		//!&lt; (in) input signal vector
		unsigned int			xNum,	//!&lt; (in) amount of elements at the input vector
		float * 				py		//!&lt; (out) output signal vector (size must be more or equal to px)
	) {
	int 				i, j;
	float 				d1, y;
	TBQF_BiquadDF2 * 	pF;

	for (i = 0; i &lt; xNum; i++) {
		y = *px;
		pF = pBQC-&gt;pB;
		for (j = 0; j &lt; pBQC-&gt;num; j++) {
			// filter
			d1 = - (pF-&gt;d2 * pF-&gt;s2 + pF-&gt;d1 * pF-&gt;s1 + y); // y = x
			y = pF-&gt;n2 * pF-&gt;s2 + pF-&gt;n1 * pF-&gt;s1 +  d1;
			y *= pF-&gt;k;

			pF-&gt;s2 = pF-&gt;s1;
			pF-&gt;s1 = d1;
			// output is input for the next filter
			pF++;
		}

		// save result to the output
		*py = y;
		px++;
		py++;
	}
}

//! initializes a element of the biquad cascade as high-pass(HP) filter
int BQF_BQFcascadeInitHP (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as HP
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc		//!&lt; (in) cut off frequency
	) {
	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}
	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=1/dn;
	float n1=-2/dn;
	float n2=1/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;

	pBQC-&gt;pB[index].n1 = n1 / n0;
	pBQC-&gt;pB[index].n2 = n2 / n0;
	pBQC-&gt;pB[index].d1 = d1 / d0;
	pBQC-&gt;pB[index].d2 = d2 / d0;
	pBQC-&gt;pB[index].k = n0 / d0;
	return 0;
}

//! initializes a element of the biquad cascade as low-pass(LP) filter
int BQF_BQFcascadeInitLP (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as LP
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc		//!&lt; (in) cut off frequency
	) {
	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}
	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float dn = (1+sqrtTwo*k+k2);

	float n0=k2/dn;
	float n1=2*k2/dn;
	float n2=k2/dn;
	float d0=1;
	float d1=(2*(k2-1))/dn;
	float d2=(1-sqrtTwo*k+k2)/dn;

	pBQC-&gt;pB[index].n1 = n1 / n0;
	pBQC-&gt;pB[index].n2 = n2 / n0;
	pBQC-&gt;pB[index].d1 = d1 / d0;
	pBQC-&gt;pB[index].d2 = d2 / d0;
	pBQC-&gt;pB[index].k = n0 / d0;
	return 0;
}

//! initializes a element of the biquad cascade as peak boost/cut filter
int BQF_BQFcascadeInitPeak (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					fc,		//!&lt; (in) center frequency
		float					q,		//!&lt; (in) quality (Q infinty)
		float					g		//!&lt; (in) gain
	) {
// some info:
// @zölzer: g is in DB and is transformed via V0 = 10^(G/20) into v0 (DAFX p.55)
// @my function:
//		1. g is not in dB! g = V0
//		2. g &lt; 1 =&gt; peak boost otherwise peak cut

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}
	if (q == 0.0f) {
		return -2;
	}
	float k=tan(M_PI*fc/fs);
	float k2 = k * k;
	float dn;

	float n0;
	float n1;
	float n2;
	float d0;
	float d1;
	float d2;


	if (g &lt; 1) {
		// boost
		dn = 1.f+1.f/q*k+k2;
		n0 = (1.f+g/q*k+k2) / dn;
		n2 = (1.f-g/q*k+k2) / dn;
		d2 = (1.0f-1.0f/q*k+k2) / dn;
	} else {
		// cut
		dn = (1.f+g/q*k+k2);
		n0 = (1.f+1.f/q*k+k2) / dn;
		n2 = (1.f-1.f/q*k+k2) / dn;
		d2 = (1.0f-g/q*k+k2) / dn;

	}
	n1=2.0f*(k2-1.0f)/dn;
	d0=1.f;
	d1=(2.f*(k2-1.f))/dn;

	pBQC-&gt;pB[index].n1 = n1 / n0;
	pBQC-&gt;pB[index].n2 = n2 / n0;
	pBQC-&gt;pB[index].d1 = d1 / d0;
	pBQC-&gt;pB[index].d2 = d2 / d0;
	pBQC-&gt;pB[index].k = n0 / d0;
	return 0;
}

//! initializes a element of the biquad cascade as low frequency shelving filter
int BQF_BQFcascadeInitLowFreqShelving (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					f,		//!&lt; (in) cut/boost frequency
		float					q,		//!&lt; (in) quality (Q infinty)
		float					g		//!&lt; (in) gain
	) {
// some info:
// @zölzer: g is in DB and is transformed via V0 = 10^(G/20) into v0 (DAFX p.55)
// @my function:
//		1. g is not in dB! g = V0
//		2. g &lt; 1 =&gt; peak boost otherwise peak cut

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}
	if (q == 0.0f) {
		return -2;
	}
	float k=tan(M_PI*f/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float sqrt2V0 = sqrtf(2.f * g);

	float dn;

	float n0;
	float n1;
	float n2;
	float d0;
	float d1;
	float d2;


	if (g &lt; 1) {
		// boost
		dn = 1.f+sqrtTwo*k+k2;
		n0 = (1.f+sqrt2V0*k+g*k2) / dn;
		n1 = (2.f * (g *k2 -1.f)) / dn;
		n2 = (1.f-sqrt2V0*k+g*k2) / dn;
		d1 = (2.f * (k2 -1.f)) / dn;
		d2 = (1.f-sqrtTwo*k+k2) / dn;
	} else {
		// cut
		dn = 1.f+sqrt2V0*k+g*k2;
		n0 = (1.f+sqrtTwo*k+k2) / dn;
		n1 = (2.f * (k2 -1.f)) / dn;
		n2 = (1.f-sqrtTwo*k+k2) / dn;
		d1 = (2.f * (g*k2 -1.f)) / dn;
		d2 = (1.f-sqrt2V0*k+g*k2) / dn;
	}
	d0=1.f;

	pBQC-&gt;pB[index].n1 = n1 / n0;
	pBQC-&gt;pB[index].n2 = n2 / n0;
	pBQC-&gt;pB[index].d1 = d1 / d0;
	pBQC-&gt;pB[index].d2 = d2 / d0;
	pBQC-&gt;pB[index].k = n0 / d0;
	return 0;
}

//! initializes a element of the biquad cascade as high frequency shelving filter
int BQF_BQFcascadeInitHighFreqShelving (
		TBQF_BiquadCascade *	pBQC,	//!&lt; (in/out) the biqaud cascade
		unsigned int			index,	//!&lt; (in) the index of the filter witch should be used as peak filter
		float  					fs,		//!&lt; (in) sample frequency
		float  					f,		//!&lt; (in) cut/boost frequency
		float					q,		//!&lt; (in) quality (Q infinty)
		float					g		//!&lt; (in) gain
	) {
// some info:
// @zölzer: g is in DB and is transformed via V0 = 10^(G/20) into v0 (DAFX p.55)
// @my function:
//		1. g is not in dB! g = V0
//		2. g &lt; 1 =&gt; peak boost otherwise peak cut

	if (index &gt;= pBQC-&gt;num) {
		return -1;
	}
	if (q == 0.0f) {
		return -2;
	}
	float k=tan(M_PI*f/fs);
	float k2 = k * k;
	float sqrtTwo = M_SQRT2;
	float sqrt2V0 = sqrtf(2.f * g);
	float sqrt2divV0 = sqrtf(2.f / g);

	float dn;
	float dn2;

	float n0;
	float n1;
	float n2;
	float d0;
	float d1;
	float d2;


	if (g &lt; 1) {
		// boost
		dn = 1.f+sqrtTwo*k+k2;
		n0 = (g+sqrt2V0*k+k2) / dn;
		n1 = (2.f * (k2 -g)) / dn;
		n2 = (g-sqrt2V0*k+k2) / dn;
		d1 = (2.f * (k2 -1.f)) / dn;
		d2 = (1.f-sqrtTwo*k+k2) / dn;
	} else {
		// cut
		dn = g+sqrt2V0*k+k2;
		dn2 = 1 + sqrt2divV0 * k + k2/g;
		n0 = (1.f+sqrtTwo*k+k2) / dn;
		n1 = (2.f * (k2 -1.f)) / dn;
		n2 = (1.f-sqrtTwo*k+k2) / dn;
		d1 = (2.f * (k2/g -1.f)) / dn2;
		d2 = (1.f-sqrt2divV0*k+k2/g) / dn2;
	}
	d0=1.f;

	pBQC-&gt;pB[index].n1 = n1 / n0;
	pBQC-&gt;pB[index].n2 = n2 / n0;
	pBQC-&gt;pB[index].d1 = d1 / d0;
	pBQC-&gt;pB[index].d2 = d2 / d0;
	pBQC-&gt;pB[index].k = n0 / d0;
	return 0;

}</Code><Code idCode="251">// ===============================
// function implementation for initBiquadAsHP(var id = 100)
// description: inits a biquad filter as an high pass filter
// ===============================

void HALfunc_ID100_initBiquadAsHP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TBQF_BiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = pParams[1].fp_integer;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter fc descr: cut off frequency
	float fc = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;

	if (!BQF_BQFcascadeInitHP(pbqc, (unsigned int) index, fs, fc)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -100;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="252">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

// updates a variable the AP
int HALimpl_10_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_10_create (unsigned int numberOfElements) {
	TBQF_BiquadCascade * pBC = malloc(sizeof(TBQF_BiquadCascade));
	if (!pBC) return NULL;
	pBC-&gt;num = 0;
	pBC-&gt;pB = NULL;
	if (BQF_BQFcascadeCreate(pBC, numberOfElements)) {
		free(pBC);
		return NULL;
	}
	return pBC;
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_10_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_10_delete (void * pVarData) {
	TBQF_BiquadCascade * pBC = (TBQF_BiquadCascade *) pVarData;
	if (pBC) {
		BQF_BQFcascadeDelete(pBC);
		free (pBC);
	}
}
</Code><Code idCode="253">// ===============================
// function implementation for initBiquadAsLP(var id = 101)
// description: inits a biquad filter as a low pass filter
// ===============================
void HALfunc_ID101_initBiquadAsLP(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TBQF_BiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = pParams[1].fp_integer;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter fc descr: cut off frequency
	float fc = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;

	if (!BQF_BQFcascadeInitLP(pbqc, (unsigned int) index, fs, fc)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -101;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="254">// ===============================
// function implementation for initBiquadAsPeakFilter(var id = 102)
// description: inits a biquad filter as peak filter
// ===============================
void HALfunc_ID102_initBiquadAsPeakFilter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TBQF_BiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = pParams[1].fp_integer;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter fc descr: center frequency
	float fc = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter q descr: quality
	float q = *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;
// parameter g descr: gain (not in dB)
	float g = *((TAPgenericRationalVector *) pParams[5].fp_pD)-&gt;pVal;

	if (!BQF_BQFcascadeInitPeak(pbqc, (unsigned int) index, fs, fc, q, g)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -102;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="255">// ===============================
// function implementation for initBiquadAsLowFreqShelvFilter(var id = 103)
// description: inits a biquad filter as low ferquency shelving filter
// ===============================
void HALfunc_ID103_initBiquadAsLowFreqShelvFilter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TBQF_BiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = pParams[1].fp_integer;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter f descr: cut/boost frequency
	float f = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter q descr: quality
	float q = *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;
// parameter g descr: gain (not in dB)
	float g = *((TAPgenericRationalVector *) pParams[5].fp_pD)-&gt;pVal;

	if (!BQF_BQFcascadeInitLowFreqShelving(pbqc, (unsigned int) index, fs, f, q, g)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -103;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="256">// ===============================
// function implementation for initBiquadAsHighFreqShelvFilter(var id = 104)
// description: inits a biquad filter as high ferquency shelving filter
// ===============================
void HALfunc_ID104_initBiquadAsHighFreqShelvFilter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter bq descr: biquad cascade
	TBQF_BiquadCascade * pbqc = ((TAPInterpreterVariable *) pParams[0].fp_pV)-&gt;pData;
// parameter index descr: index at the cascade
	int32_t index = pParams[1].fp_integer;
// parameter fs descr: sample frequnecy
	float fs = *((TAPgenericRationalVector *) pParams[2].fp_pD)-&gt;pVal;
// parameter f descr: cut/boost frequency
	float f = *((TAPgenericRationalVector *) pParams[3].fp_pD)-&gt;pVal;
// parameter q descr: quality
	float q = *((TAPgenericRationalVector *) pParams[4].fp_pD)-&gt;pVal;
// parameter g descr: gain (not in dB)
	float g = *((TAPgenericRationalVector *) pParams[5].fp_pD)-&gt;pVal;

	if (!BQF_BQFcascadeInitHighFreqShelving(pbqc, (unsigned int) index, fs, f, q, g)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -103;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="257">// ===============================
// function implementation for convoluteBiquad(var id = 110)
// description: convolute biquad with an input and generate an output
// ===============================
void HALfunc_ID110_convoluteBiquad(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * pXvec = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter bqa descr: biquad cascade
	TBQF_BiquadCascade * pbqc = (TBQF_BiquadCascade *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * pYvec = (TAPgenericRationalVector *) pParams[2].fp_pD;

	BQF_BQFcascadeConvolute(pbqc,pXvec-&gt;pVal, pXvec-&gt;num, pYvec-&gt;pVal);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="258">/*
 * main template
 *
 *  Created on: 10.08.2011
 *      Author: StJ
 *      changed: 07.03.2012
 */

#ifdef __cplusplus
using namespace std;
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#include &quot;AP.h&quot;

// some basic file defines
// #define dAPuseFileIO
#define dAPuseExternalAPCode

#ifdef dAPuseFileIO
// ==================================
// file IO
// ==================================

// endian check
int is_big_endian(void) {
    union {
        uint32_t i;
        char c[4];
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

// loads the alc from a file
int loadALCfromFile (const char * szFilname,int * pEndianness, int32_t *pVarcount, int32_t * pInstrCount, int32_t ** ppVarList, int32_t ** ppInstructions) {
	FILE *		f;
	int32_t		instrSize;

	*ppInstructions = NULL;
	*ppVarList = NULL;
	*pVarcount = 0;
	*pInstrCount = 0;

	f = fopen (szFilname,&quot;rb&quot;);

	if (!f) return -1;

	uint8_t	idField[4];
	uint8_t endian, sysEndian;;

	if (1 != fread (&amp;idField,sizeof(int8_t)*4,1,f)) goto error;
	if (1 != fread (&amp;endian,sizeof(int8_t),1,f)) goto error;

	if (1 != fread (pVarcount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (pInstrCount,sizeof(int32_t),1,f)) goto error;
	if (1 != fread (&amp;instrSize,sizeof(int32_t),1,f)) goto error;


	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endian != sysEndian) {
		APendianConversation32Bit((uint32_t *)pVarcount);
		APendianConversation32Bit((uint32_t *)pInstrCount);
		APendianConversation32Bit((uint32_t *)&amp;instrSize);
	}

	// check if the size of the instructions saved at the file is equal to the of the engine
	if (((instrSize)-1) != dAPInterpreterFuncMaxParams) {
		goto error;
	}


	*ppVarList = malloc ((sizeof(int32_t)*(dAPInterpreterVariableMaxParams))*(*pVarcount));
	if (!*ppVarList) goto error;

	*ppInstructions = malloc (sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1) *(*pInstrCount));
	if (!*ppInstructions) goto error;

	if (*pVarcount != fread (*ppVarList,sizeof(int32_t)*(dAPInterpreterVariableMaxParams),*pVarcount,f)) goto error;

	if (*pInstrCount != fread (*ppInstructions,sizeof(int32_t)*(dAPInterpreterFuncMaxParams+1),*pInstrCount,f)) goto error;

	fclose (f);

	*pEndianness = endian;
	return 0;

error:
	fclose (f);
	if (*ppInstructions) {
		free (*ppInstructions);
		*ppInstructions = NULL;
	}

	if (*ppVarList) {
		free (*ppVarList);
		*ppVarList = NULL;
	}
	*pVarcount = 0;
	*pInstrCount = 0;
	*pEndianness = 0;
	return -2;
}

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (
		TAPInterpreter	IP,
		int				endianness,
		int32_t 		varCount,
		int32_t			instrCount,
		int32_t *		pVarList,
		int32_t *		pInstructions
		) {
	APInterpreterClean (IP);
	APInterpreterSetState (IP,endianness,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (IP,endianness,instrCount,varCount);

	int32_t vc = varCount;
	int32_t ic = instrCount;
	int sysEndian;
	if (!is_big_endian()) sysEndian = eAP_littleEndian;
		else sysEndian = eAP_bigEndian;
	if (endianness != sysEndian) {
		APendianConversation32Bit((uint32_t *)&amp;vc);
		APendianConversation32Bit((uint32_t *)&amp;ic);
	}

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData * pV = (TBinVarData *) pVarList;
	for (i = 0; i &lt; vc;i++) {
		if (APInterpreterLoadVar (IP,endianness,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}
	int32_t * pInstr = pInstructions;
	for (i = 0; i &lt; ic;i++) {
		if (APInterpreterLoadInstr (IP,endianness,i,pInstr)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}
#endif // of dAPuseFileIO


#ifdef dAPuseExternalAPCode

// loads the ALC - stored in memory - into the AP
int loadProgrammToTheAP (TAP * pAP) {

	extern int const gALCdumpEndian;
	extern int const gALCdumpVarCount;
	extern int const gALCdumpInstrCount;
	extern int const gALCdumpInstrSize;

	// a constant global variable holding the values for the variables
	extern const int32_t gcVars[];
	// a constant global variable holding the values for the instructions
	extern const int32_t gcInstructions[];

	if (gALCdumpInstrSize != (dAPInterpreterFuncMaxParams + 1)) return -1;

	APInterpreterClean (pAP-&gt;IP);
	APInterpreterSetState (pAP-&gt;IP,gALCdumpEndian,eAPInterpreterState_loadProgramm);
	APInterpreterInitNewProgramm (pAP-&gt;IP,gALCdumpEndian,(int32_t)gALCdumpInstrCount,(int32_t)gALCdumpVarCount);

	int32_t i;
	typedef int32_t TBinVarData[2];
	TBinVarData const * pV = (TBinVarData const *) gcVars;
	for (i = 0; i &lt; gALCdumpVarCount;i++) {
		if (APInterpreterLoadVar (pAP-&gt;IP,gALCdumpEndian,i,(*pV)[0],(*pV)[1])) return -10;
		pV++;
	}

	// if the values at the flash or rom we need to make a copy at the RAM to use the AP API functions
	int32_t const * pInstr = gcInstructions;
	int32_t instrCopy[dAPInterpreterFuncMaxParams + 1];
	for (i = 0; i &lt; gALCdumpInstrCount;i++) {
		// copy instruction from the const buffer to an non const buffer
		memcpy (instrCopy, pInstr, sizeof(uint32_t)*(dAPInterpreterFuncMaxParams + 1));
		// load instruction
		if (APInterpreterLoadInstr (pAP-&gt;IP,gALCdumpEndian,i,instrCopy)) return -20;
		pInstr += (dAPInterpreterFuncMaxParams + 1);
	}
	return 0;
}


#endif

TAP 		AP;

void * APIPthread(void * pArgs) {
	APInterpreterProcessState(AP.IP);

	return NULL;
}

void * APMSthread (void * pArgs) {
	APMessageProcessingThread (&amp;AP);
	return NULL;
}

#define dMyEndian (eAP_littleEndian)

int main()
{
	WSADATA			wsaData;
	pthread_t		IPthread;
	pthread_t		MSthread;



	int rc;

    if ((WSAStartup(MAKEWORD(2, 2), &amp;wsaData))) {
    	printf(&quot;WSAStartup failed!&quot;);
    	return -1;
    }

	time_t t;

	time(&amp;t);
	srand((unsigned int)t);              /* Zufallsgenerator initialisieren */

	int uuid = rand();

	printf (&quot;AP uuid %i\n&quot;,uuid);

	// start up gtk+
	APgtk_start ();

	//rc = APinit(&amp;AP,815,NULL,0,1000,eAP_littleEndian);
	rc = APinit(&amp;AP,(TAPNodeID)uuid,NULL,0,1000,dMyEndian);
	if (rc) {
		printf(&quot;audio processor init failed with error code %i!&quot;,rc);
		goto exit;
	}


#ifdef dAPuseFileIO
	int32_t varC;
	int32_t instrC;

	int32_t * varL;
	int32_t * instrL;
	int endian;

	rc = loadALCfromFile (&quot;../APgen/ALASM/crossOver5Way.alc&quot;,&amp;endian,&amp;varC,&amp;instrC,&amp;varL,&amp;instrL);
	if (rc) goto exit;
	rc = loadProgrammToTheAP (AP.IP,endian,varC,instrC,varL,instrL);
#endif

#ifdef dAPuseExternalAPCode
	rc = loadProgrammToTheAP (&amp;AP);
	if (rc) {
		printf(&quot;load programm failed with %i&quot;, rc);
		goto exit;
	}
#endif

#ifdef dAPuseFileIO
	free (varL);
	free (instrL);
#endif

	rc = APInterpreterSetState (AP.IP,dMyEndian,eAPInterpreterState_run);

	pthread_create(&amp;IPthread,NULL,&amp;APIPthread,NULL);
	pthread_create(&amp;MSthread,NULL,&amp;APMSthread,NULL);

	printf(&quot;press a key to exit&quot;);
	getch();

	rc = APInterpreterSetState (AP.IP,dMyEndian,eAPInterpreterState_halt);


exit:
	APdelete(&amp;AP);

	WSACleanup();

	APgtk_end();

	return EXIT_SUCCESS;
}
</Code><Code idCode="259">// ===============================
// function implementation for assignConstRational(var id = 27)
// description: a = values
// ===============================
void HALfunc_ID27_assignConstRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter iv descr: rational vector
	TAPgenericRationalVector * piv = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter iStart descr: start index
	int32_t iStart = pParams[1].fp_integer;
// parameter num descr: amount of values used
	int32_t num = pParams[2].fp_integer;

	float * pSrc =(float *) &amp;pParams[3].fp_raw;

	APgenericRationalVector_assignConst (piv, (int)iStart, (int)num, pSrc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="260">// ===============================
// function implementation for assignRational(var id = 28)
// description: a = b
// ===============================
void HALfunc_ID28_assignRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[1].fp_pD;

	APgenericRationalVector_assign(pa, pb);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;

};
</Code><Code idCode="261">// ===============================
// function implementation for addRational(var id = 29)
// description: c = a + b
// ===============================
void HALfunc_ID29_addRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_add(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="262">// ===============================
// function implementation for subRational(var id = 30)
// description: c = a - b
// ===============================
void HALfunc_ID30_subRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_sub(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="263">// ===============================
// function implementation for mulRational(var id = 31)
// description: c = a * b
// ===============================
void HALfunc_ID31_mulRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_mul(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="264">// ===============================
// function implementation for divRational(var id = 32)
// description: c = a / b
// ===============================
void HALfunc_ID32_divRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_div(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="265">// ===============================
// function implementation for modRational(var id = 33)
// description: c = mod(a,b)
// ===============================
void HALfunc_ID33_modRational(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter b descr: vector b
	TAPgenericRationalVector * pb = (TAPgenericRationalVector *)pParams[1].fp_pD;
// parameter c descr: vector c
	TAPgenericRationalVector * pc = (TAPgenericRationalVector *)pParams[2].fp_pD;

	APgenericRationalVector_mod(pa, pb, pc);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="266">// ===============================
// function implementation for compareRationalLess(var id = 34)
// description: a &lt; b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID34_compareRationalLess(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib) &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;


};
</Code><Code idCode="267">// ===============================
// function implementation for compareRationalMore(var id = 35)
// description: a &gt; b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID35_compareRationalMore(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib) &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="268">// ===============================
// function implementation for compareRationalEqual(var id = 36)
// description: a == b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID36_compareRationalEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib) == 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="269">// ===============================
// function implementation for compareRationalNEqual(var id = 37)
// description: a != b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID37_compareRationalNEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib)  != 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="270">// ===============================
// function implementation for compareRationalLessEqual(var id = 38)
// description: a &lt;= b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID38_compareRationalLessEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib)  &gt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="271">// ===============================
// function implementation for compareRationalMoreEqual(var id = 39)
// description: a &gt;= b ? CF = 1 : CF = 0
// ===============================
void HALfunc_ID39_compareRationalMoreEqual(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter a descr: vector a
	TAPgenericRationalVector * pa = (TAPgenericRationalVector *)pParams[0].fp_pD;
// parameter ia descr: a index
	int32_t ia = pParams[1].fp_integer;
// parameter b descr: vector b
	TAPgenericRationalVector* pb = (TAPgenericRationalVector *)pParams[2].fp_pD;
// parameter ib descr: b index
	int32_t ib = pParams[3].fp_integer;

	if (APgenericRationalVector_cmpEle(pa, pb, ia, ib)  &lt; 0) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 0;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;CF = 1;
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="272">// ========================================
// dynamics processing (DynProc)
// ========================================
// Literature:
// Udo Zölzer, Digitale Audiosignal Verarbeitung, 3. Auflage
// Udo Zölzer, DAFX - Digital Audio Effects


// short:
// 		AT - attack time
//		RT - release time
//		TAV - average time
//		LT- limiter threshold
//		LS - limiter slope


// ---------------------------------
// helper
// ---------------------------------

float DynProc_calcSlope (
		float x1db, float y1db,
		float x2db, float y2db
	);

float DynProc_calcThreshold (
		float xDB,
		float xMax
	);

float DynProc_calcDB (float v);

float DynProc_calcValueFromDB (float dbVlaue, float xMax);

//! calc time parameter (AT, RT, TAV)
float DynProc_calcTimeParameter (
	float 		Ta, 	//!&lt; (in) sampling period
	float		t		//!&lt; (in) time parameter
	);

float DynProc_calcTimeFromTimeparameter (
		float Ta,
		float Tval
		);


// ---------------------------------
// RMS
// ---------------------------------
// RMS calc after Zölzer @p. 238

// structure for RMS calculation
typedef struct SDynProc_RMS {
	float	TAV;			//!&lt; time average
	float	oneMinusTAV;	//!&lt; 1-TAV
	float	x2Old;			//!&lt; x²(n-1)
} TDynProc_RMS;

//! init rms
void DynProc_InitRMS (
	TDynProc_RMS *	pRMS,	//!&lt; (in/out) structure to be filled
	float			TAV		//!&lt; (in) averaging time coefficient
	);

//! calc rms for one step (!rms = x²!)
float DynProc_calcRMS (
		TDynProc_RMS *	pRMS,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	);

// ---------------------------------
// Peak
// ---------------------------------
// Peak calc after Zölzer

// structure for Peak calculation
typedef struct SDynProc_Peak {
	float	AT;			//!&lt; attack time
	float	RT;			//!&lt; release time
	float	oneMinusAT;	//!&lt; 1 - AT
	float	oneMinusRT;	//!&lt; 1 - RT
	float	peak;		//!&lt; peak
} TDynProc_Peak;


//! init peak
void DynProc_InitPeak (
	TDynProc_Peak *	pPeak,	//!&lt; (in/out) structure to be filled
	float			AT,		//!&lt; (in) attack time
	float			RT		//!&lt; (in) release time
	);

//! calc peak for one step
float DynProc_calcPeak (
		TDynProc_Peak *	pPeak,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	);


// ---------------------------------
// smooth gain
// ---------------------------------
// smooth the gain value
// idea: use a hysteresis curve
//
// formula: g(n) = (1-k) * g(n - 1) + k * f(n)
//
// k = AT or k = RT
// k = (f(n) &gt; f(n-1)) ? AT : RT
// if new value is over the old value -&gt; attack
// else -&gt; release

// structure for attack and release time adjustment calculation
typedef struct SDynProc_SmoothG {
	float 			AT;		//!&lt; attack time
	float 			RT;		//!&lt; release time
	float			fOld;	//!&lt; f(n-1)
	float			gOld;	//!&lt; g(n-1)
} TDynProc_SmoothG;

//! init AT/RT
void DynProc_InitSmoothG (
	TDynProc_SmoothG *	pSG,	//!&lt; (in/out) structure to be filled
	float				AT,		//!&lt; (in) attack time
	float				RT		//!&lt; (in) release time
	);

//! init AT/RT
float DynProc_calcSmoothG (
	float 				fn,		//!&lt; (in) input
	TDynProc_SmoothG *	pSG	//!&lt; (in) structure to be filled
	);

// ---------------------------------
// limiter
// ---------------------------------
// LT - limiter treshold (where the limiter starts working)
// LS - limiter slope (how fast the limiter works)

// structure for dynamic range controler calculation
typedef struct SDynProc_Limiter {
	float 				LTlog;			//!&lt; limiter threshold LT
	float 				LS;				//!&lt; limiter slope LS
	TDynProc_Peak		peakDetector;	//!&lt; the peak detector
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay;			//!&lt; delay at the input - output lane
} TDynProc_Limiter;

//! init AT/RT
void DynProc_InitLimiter (
		TDynProc_Limiter *	pLim,		//!&lt; (in/out) structure to be filled
		float				peakAT,		//!&lt; (in) peak attack time
		float				peakRT,		//!&lt; (in) peak release time
		float				smoothAT,	//!&lt; (in) smoothing attack time
		float				smoothRT,	//!&lt; (in) smoothing release time
		float				LT,			//!&lt; (in) limiter threshold
		float				LS			//!&lt; (in) limiter slope
);

//! init AT/RT
float DynProc_calcLimiter (
		TDynProc_Limiter *	pLim,	//!&lt; (in) the limiter
		float 				x		//!&lt; (in) input signal
	);

// ---------------------------------
// compressor
// ---------------------------------
// CT - compressor treshold (where the compressor starts working)
// CS - compressor slope (how fast the compressor works)

// structure for dynamic range controller calculation
typedef struct SDynProc_Compressor {
	float 				CTlog;				//!&lt; compressor threshold
	float 				CSlog;				//!&lt; compressor slope
	TDynProc_RMS		RMS;			//!&lt; RMS unit
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay[2];		//!&lt; delay at the input - output lane
} TDynProc_Compressor;



//! init compressor
void DynProc_InitCompressor (
	TDynProc_Compressor *	pComp,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					CT,			//!&lt; (in) compressor treshold
	float					CS			//!&lt; (in) compressor slope
);

//! calc compressor
float DynProc_calcCompressor (
		TDynProc_Compressor *	pComp,	//!&lt; (in) the compressor
		float 					x		//!&lt; (in) input signal
	);

// ---------------------------------
// expander
// ---------------------------------
// ET - expander threshold (where the expander starts working)
// ES - expander slope (how fast the expander works)

// structure for dynamic range controller calculation
typedef struct SDynProc_Expander {
	float 				ETlog;		//!&lt; expander threshold log10 (ET)
	float 				ESlog;		//!&lt; expander slope log10 (ES)
	TDynProc_RMS		RMS;			//!&lt; RMS unit
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay[2];		//!&lt; delay at the input - output lane
} TDynProc_Expander;

//! init expander
void DynProc_InitExpander (
	TDynProc_Expander *	pExp,		//!&lt; (in/out) structure to be filled
	float				rmsTAV,		//!&lt; (in) rms time average coefficient
	float				smoothAT,	//!&lt; (in) smoothing attack time
	float				smoothRT,	//!&lt; (in) smoothing release time
	float				ET,			//!&lt; (in) expander treshold in dB
	float				ES			//!&lt; (in) expander slope in dB
);

//! calc expander
float DynProc_calcExpander (
		TDynProc_Expander *	pExp,	//!&lt; (in) the expander
		float 					x		//!&lt; (in) input signal
	);

// ---------------------------------
// noisegate
// ---------------------------------
// NT - noisegate threshold (till the noisegate works)

// structure for dynamic range controller calculation
typedef struct SDynProc_Noisegate {
	float 				NTlog;			//!&lt; noisegate threshold log10 (NT)
	float 				NSlog;			//!&lt; noisegate slope log10 (NS)
	TDynProc_RMS		RMS;			//!&lt; RMS unit
	TDynProc_SmoothG	SmoothG;		//!&lt; AT/RT block
	float				delay[2];		//!&lt; delay at the input - output lane
} TDynProc_Noisegate;

//! init noisegate
void DynProc_InitNoisegate (
	TDynProc_Noisegate *	pNG,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					NT,	//!&lt; (in) noisegate threshold
	float					NS	//!&lt; (in) noisegate slope
);

//! calc noisegate
float DynProc_calcNoisegate (
		TDynProc_Noisegate *	pNG,	//!&lt; (in) the noisegate
		float 					x		//!&lt; (in) input signal
	);

// ========================================
// dynamics processing (DynProc)
// ========================================
// Literature:
// Udo Zölzer, Digitale Audiosignal Verarbeitung, 3. Auflage
// Udo Zölzer, DAFX - Digital Audio Effects


// short:
// 		AT - attack time
//		RT - release time
//		TAV - average time
//		LT- limiter threshold
//		LS - limiter slope

// it works in that way
// Y(n) = G(n) * x(n -D)
// g = {noisegate, expander, compressor, limiter}
// D - delay m - samples


// helper

float DynProc_calcSlope (
		float x1db, float y1db,
		float x2db, float y2db
	) {
	// y = m * x + n; P1 &amp; P2
	// m = (P2y - P1y) / (P2x - P1x)
	return (y2db - y1db) / (x2db - x1db);
}

float DynProc_calcThreshold (
		float xDB,
		float xMax
	) {
	return xMax * powf (10.0f, xDB / 20.0f);
}

float DynProc_calcDB (float x) {
	return 10.0f * logf(x*x); // = 10.0 * log(x²)  = 20.0f * log(x)
}

float DynProc_calcValueFromDB (float dbVlaue, float xMax) {
	return powf(10.0f, dbVlaue / 20.0) * xMax;
}


float DynProc_calcCompressionFactor (float slope) {
	return 1.f / (1.f- slope);
}

//! calc time parameter (AT, RT, TAV)
float DynProc_calcTimeParameter (
	float 		Ta, 	//!&lt; (in) sampling period
	float		t		//!&lt; (in) time parameter
	) {
	// formular and 2.2 explained at &quot;Digitale Audio Signalverarbeitung&quot; @p.237
	return (1.0f - expf((-2.2f * Ta) / t));
}

float DynProc_calcTimeFromTimeparameter (
		float Ta,
		float Tval
		) {
	return (-2.2f * Ta)/ (logf(1-Tval));
}

// ---------------------------------
// RMS
// ---------------------------------
// RMS calc after Zölzer @p. 238

//! init rms
void DynProc_InitRMS (
	TDynProc_RMS *	pRMS,	//!&lt; (in/out) structure to be filled
	float			TAV		//!&lt; (in) averaging time coefficient
	) {
	pRMS-&gt;TAV = TAV;
	pRMS-&gt;oneMinusTAV = 1.0f - TAV;
	pRMS-&gt;x2Old = 0.0f;
}

//! calc rms for one step
float DynProc_calcRMS (
		TDynProc_RMS *	pRMS,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	) {
	float x2RMS;
	// calc forward
	x2RMS = pRMS-&gt;oneMinusTAV * pRMS-&gt;x2Old + pRMS-&gt;TAV * x * x;
	// calc backward
	pRMS-&gt;x2Old = x2RMS;
	return x2RMS;
}

// ---------------------------------
// Peak
// ---------------------------------
// Peak calc after Zölzer

//! init peak
void DynProc_InitPeak (
	TDynProc_Peak *	pPeak,	//!&lt; (in/out) structure to be filled
	float			AT,		//!&lt; (in) attack time
	float			RT		//!&lt; (in) release time
	) {
	pPeak-&gt;AT = AT;
	pPeak-&gt;RT = RT;
	pPeak-&gt;oneMinusAT = 1.0f - AT;
	pPeak-&gt;oneMinusRT = 1.0f - RT;
	pPeak-&gt;peak = 0.0f;
}

//! calc peak for one step
float DynProc_calcPeak (
		TDynProc_Peak *	pPeak,	//!&lt; (in) structure to be filled
		float 			x		//!&lt; (in) input signal witch should be rms
	) {

	// formula from Zölzer @p. 235 wrong!
	// |x(n)| &gt; xPeak(n-1) -&gt; attack
	// |x(n)| &lt;= xPeak(n-1) -&gt; release
	// @attack: xpeak(n) = (1-AT) * xpeak(n-1) + AT * |x(n)|
	// @release: xpeak(n) = (1-RT) * peak(n-1)
	float a;
	a = fabsf(x);

	if (a &gt; pPeak-&gt;peak) {
		pPeak-&gt;peak = pPeak-&gt;oneMinusAT * (pPeak-&gt;peak) + pPeak-&gt;AT * a;
	} else {
		pPeak-&gt;peak = pPeak-&gt;oneMinusRT * (pPeak-&gt;peak) + pPeak-&gt;RT * a;
	}
	return pPeak-&gt;peak;
}

// ---------------------------------
// smooth gain
// ---------------------------------
// smooth the gain value
// idea: use a hysteresis curve
//
// formula: g(n) = (1-k) * g(n - 1) + k * f(n)
//
// k = AT or k = RT
// k = (f(n) &gt; f(n-1)) ? AT : RT
// if new value is over the old value -&gt; attack
// else -&gt; release

//! init AT/RT
void DynProc_InitSmoothG (
	TDynProc_SmoothG *	pSG,	//!&lt; (in/out) structure to be filled
	float				AT,		//!&lt; (in) attack time
	float				RT		//!&lt; (in) release time
	) {
	pSG-&gt;AT = AT;
	pSG-&gt;RT = RT;
	pSG-&gt;fOld = 0.0f;
	pSG-&gt;gOld = 0.0f;
}

//! init AT/RT
float DynProc_calcSmoothG (
	float 				fn,		//!&lt; (in) input
	TDynProc_SmoothG *	pSG	//!&lt; (in) structure to be filled
	) {
	float k;
	float gn;

	// attack or release
	k = (fn &gt; pSG-&gt;fOld) ? pSG-&gt;AT : pSG-&gt;RT;

	// calc gain
	gn = (1.0f-k) * pSG-&gt;gOld + k * fn;
	pSG-&gt;gOld = gn;
	pSG-&gt;fOld = fn;
	return gn;
}

// ---------------------------------
// limiter
// ---------------------------------
// LT - limiter treshold (where the limiter starts working)
// LS - limiter slope (how fast the limiter works)

//! init AT/RT
void DynProc_InitLimiter (
	TDynProc_Limiter *	pLim,		//!&lt; (in/out) structure to be filled
	float				peakAT,		//!&lt; (in) peak attack time
	float				peakRT,		//!&lt; (in) peak release time
	float				smoothAT,	//!&lt; (in) smoothing attack time
	float				smoothRT,	//!&lt; (in) smoothing release time
	float				LT,			//!&lt; (in) limiter threshold
	float				LS			//!&lt; (in) limiter slope
) {
	DynProc_InitPeak(&amp;(pLim-&gt;peakDetector),peakAT,peakRT);
	DynProc_InitSmoothG(&amp;(pLim-&gt;SmoothG),smoothAT,smoothRT);
	pLim-&gt;LTlog = log10f(LT);
	pLim-&gt;LS = LS;
	pLim-&gt;delay = 0.0f;
}

//! init AT/RT
float DynProc_calcLimiter (
		TDynProc_Limiter *	pLim,	//!&lt; (in) the limiter
		float 				x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pLim-&gt;delay;
	// 1.1.) recalc delay
	pLim-&gt;delay = x;

	// 2.) calc limiter gain
	// 2.1) peak detect
	g = DynProc_calcPeak(&amp;(pLim-&gt;peakDetector),x);
	g = log10f(g);
	// 2.3. if we are over the threshold
	if (g &gt; pLim-&gt;LTlog) {
		g = -pLim-&gt;LS * (g - pLim-&gt;LTlog);
	} else {
		g = 0.0;
	}
	g = powf (10.0f, g);
	g = DynProc_calcSmoothG(g, &amp;(pLim-&gt;SmoothG));
	// 3. calc result of delay mul compressor gain
	y *= g;

	// AND return
	return y;
}

// ---------------------------------
// compressor
// ---------------------------------
// CT - compressor treshold (where the compressor starts working)
// CS - compressor slope (how fast the compressor works)

//! init compressor
void DynProc_InitCompressor (
	TDynProc_Compressor *	pComp,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					CT,			//!&lt; (in) compressor treshold
	float					CS			//!&lt; (in) compressor slope
) {
	DynProc_InitRMS(&amp;(pComp-&gt;RMS),rmsTAV);
	DynProc_InitSmoothG(&amp;(pComp-&gt;SmoothG),smoothAT,smoothRT);
	pComp-&gt;CTlog = DynProc_calcDB(CT);
	pComp-&gt;CSlog = -CS;
	pComp-&gt;delay[0] = 0.0f;
	pComp-&gt;delay[1] = 0.0f;
}

//! calc compressor
float DynProc_calcCompressor (
		TDynProc_Compressor *	pComp,	//!&lt; (in) the compressor
		float 					x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pComp-&gt;delay[1];
	// 1.1.) recalc delay
	pComp-&gt;delay[1] = pComp-&gt;delay[0];
	pComp-&gt;delay[0] = x;

	// 2.) calc compressor gain
	// 2.1) peak detect
	g = DynProc_calcRMS(&amp;(pComp-&gt;RMS),x);
	// 2.2) lin/log
	g = log10f(g);
	g *= 10.0f; // rms = x² - &gt; log(x²) = 2 log(x²) -&gt; Xdb = 20*log(x) -&gt; 20 / 2 = 10

	// 2.3. if we are over the threshold
	if (g &gt; pComp-&gt;CTlog) {
		g = pComp-&gt;CSlog*(g-pComp-&gt;CTlog) / 20.0f;
	} else {
		g = 0.0f;
	}
	g = powf (10.0f, g);
	g = DynProc_calcSmoothG(g, &amp;(pComp-&gt;SmoothG));
	// 3. calc result of delay mul compressor gain
	y *= g;

	// AND return
	return y;
}


// ---------------------------------
// expander
// ---------------------------------
// ET - expander threshold (where the expander starts working)
// ES - expander slope (how fast the expander works)

//! init expander
void DynProc_InitExpander (
	TDynProc_Expander *	pExp,		//!&lt; (in/out) structure to be filled
	float				rmsTAV,		//!&lt; (in) rms time average coefficient
	float				smoothAT,	//!&lt; (in) smoothing attack time
	float				smoothRT,	//!&lt; (in) smoothing release time
	float				ET,			//!&lt; (in) expander treshold in dB
	float				ES			//!&lt; (in) expander slope in dB
) {
	DynProc_InitRMS(&amp;(pExp-&gt;RMS),rmsTAV);
	DynProc_InitSmoothG(&amp;(pExp-&gt;SmoothG),smoothAT,smoothRT);
	pExp-&gt;ETlog = DynProc_calcDB(ET);
	pExp-&gt;ESlog = ES;
	pExp-&gt;delay[0] = 0.0f;
	pExp-&gt;delay[1] = 0.0f;
}

//! calc expander
float DynProc_calcExpander (
		TDynProc_Expander *		pExp,	//!&lt; (in) the expander
		float 					x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pExp-&gt;delay[1];
	// 1.1.) recalc delay
	pExp-&gt;delay[1] = pExp-&gt;delay[0];
	pExp-&gt;delay[0] = x;

	// 2.) calc compressor gain
	// 2.1) peak detect
	g = DynProc_calcRMS(&amp;(pExp-&gt;RMS),x);
	// 2.2) lin/log
	g = log10f(g);
	g *= 10.0f; // rms = x² - &gt; log(x²) = 2 log(x²) -&gt; Xdb = 20*log(x) -&gt; 20 / 2 = 10

	// 2.3. if we are over the threshold
	if (g &gt; pExp-&gt;ETlog) {
		g = pExp-&gt;ESlog*(pExp-&gt;ETlog-g) / 20.0;
	} else {
		g = 0.0f;
	}
	g = powf (10.0f, g);
	g = DynProc_calcSmoothG(g, &amp;(pExp-&gt;SmoothG));
	// 3. calc result of delay mul compressor gain
	y *= g;

	// AND return
	return y;
}


// ---------------------------------
// noisegate
// ---------------------------------
// NT - noisegate threshold (till the noisegate works)

//! init noisegate
void DynProc_InitNoisegate (
	TDynProc_Noisegate *	pNG,		//!&lt; (in/out) structure to be filled
	float					rmsTAV,		//!&lt; (in) rms time average coefficient
	float					smoothAT,	//!&lt; (in) smoothing attack time
	float					smoothRT,	//!&lt; (in) smoothing release time
	float					NT,			//!&lt; (in) noisegate threshold
	float					NS			//!&lt; (in) noisegate slope
) {
	DynProc_InitRMS(&amp;(pNG-&gt;RMS),rmsTAV);
	DynProc_InitSmoothG(&amp;(pNG-&gt;SmoothG),smoothAT,smoothRT);
	pNG-&gt;NTlog = DynProc_calcDB(NT);
	pNG-&gt;NSlog = NS;
	pNG-&gt;delay[0] = 0.0f;
	pNG-&gt;delay[1] = 0.0f;
}

//! calc noisegate
float DynProc_calcNoisegate (
		TDynProc_Noisegate *	pNG,	//!&lt; (in) the noisegate
		float 					x		//!&lt; (in) input signal
	) {
	float y;
	float g;

	// 1.) calc direct feedthrough lane
	y = pNG-&gt;delay[1];
	// 1.1.) recalc delay
	pNG-&gt;delay[1] = pNG-&gt;delay[0];
	pNG-&gt;delay[0] = x;

	// 2.) calc noisegate gain
	// 2.1) rms detect
	g = DynProc_calcRMS(&amp;(pNG-&gt;RMS), x);
	// 2.2) lin/log
	g = log10f(g);
	g *= 10.0f; // rms = x² - &gt; log(x²) = 2 log(x²) -&gt; Xdb = 20*log(x) -&gt; 20 / 2 = 10

	// 2.3. if we are over the threshold
	if (g &gt; pNG-&gt;NTlog) {
		// calc linear function at log space
		g = pNG-&gt;NSlog*(g-pNG-&gt;NTlog) / 20.0;
		g = powf(10.f, g);
	} else {
		g = 0.0f;
	}
	// and smooth
	g = DynProc_calcSmoothG(g, &amp;(pNG-&gt;SmoothG));
	// 3. calc result of delay mul noisegate gain
	y *= g;

	// AND return
	return y;
}</Code><Code idCode="273">// ===============================
// function implementation for initNoisegate(var id = 111)
// description: initialize a noisegate
// ===============================
void HALfunc_ID111_initNoisegate(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter ng descr: noisegate
	TDynProc_Noisegate * pNG = (TDynProc_Noisegate *) pParams[0].fp_pD;
// parameter rmsTAV descr: time average value for the rms
	float rmsTAV = pParams[1].fp_rational;
// parameter AT descr: attack value for the smoothing
	float AT = pParams[2].fp_rational;
// parameter RT descr: release value for the smoothing
	float RT = pParams[3].fp_rational;
// parameter NT descr: noise cut off threshold
	float NT = pParams[4].fp_rational;
// parameter NS descr: slope
	float NS = pParams[5].fp_rational;

	DynProc_InitNoisegate(pNG, rmsTAV, AT, RT, NT, NS);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="274">// ===============================
// function implementation for initExpander(var id = 112)
// description: initialize a expander
// ===============================
void HALfunc_ID112_initExpander(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter exp descr: expander
	TDynProc_Expander * pExp = (TDynProc_Expander *) pParams[0].fp_pD;
// parameter rmsTAV descr: time average value for the rms
	float rmsTAV = pParams[1].fp_rational;
// parameter AT descr: attack value for the smoothing
	float AT = pParams[2].fp_rational;
// parameter RT descr: release value for the smoothing
	float RT = pParams[3].fp_rational;
// parameter ET descr: expander threshold
	float ET = pParams[4].fp_rational;
// parameter ES descr: slope
	float ES = pParams[5].fp_rational;

	DynProc_InitExpander(pExp, rmsTAV, AT, RT, ET, ES);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="275">// ===============================
// function implementation for initCompressor(var id = 113)
// description: initialize a compressor
// ===============================
void HALfunc_ID113_initCompressor(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter comp descr: compressor
	TDynProc_Compressor * pComp = (TDynProc_Compressor *) pParams[0].fp_pD;
// parameter rmsTAV descr: time average value for the rms
	float rmsTAV = pParams[1].fp_rational;
// parameter AT descr: attack value for the smoothing
	float AT = pParams[2].fp_rational;
// parameter RT descr: release value for the smoothing
	float RT = pParams[3].fp_rational;
// parameter CT descr: compressor threshold
	float CT = pParams[4].fp_rational;
// parameter CS descr: slope
	float CS = pParams[5].fp_rational;

	DynProc_InitCompressor(pComp, rmsTAV, AT, RT, CT, CS);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="276">// ===============================
// function implementation for initLimiter(var id = 114)
// description: initialize a limiter
// ===============================
void HALfunc_ID114_initLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter lim descr: limiter
	TDynProc_Limiter * pLim = (TDynProc_Limiter *) pParams[0].fp_pD;
// parameter ATpeak descr: attack value for the peak detection
	float ATpeak = pParams[1].fp_rational;
// parameter RTpeak descr: release value for the peak detection
	float RTpeak = pParams[2].fp_rational;
// parameter ATsmooth descr: attack value for the smoothing
	float ATsmooth = pParams[3].fp_rational;
// parameter RTsmooth descr: release value for the smoothing
	float RTsmooth = pParams[4].fp_rational;
// parameter LT descr: limiter threshold
	float LT = pParams[5].fp_rational;
// parameter LS descr: slope
	float LS = pParams[6].fp_rational;

	DynProc_InitLimiter(pLim, ATpeak, RTpeak, ATsmooth, RTsmooth, LT, LS);
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="277">// ===============================
// function implementation for calcNoisegate(var id = 115)
// description: sends a stream of samples through a noisegate
// ===============================
void HALfunc_ID115_calcNoisegate(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter ng descr: noisegate
	TDynProc_Noisegate * pNG = (TDynProc_Noisegate *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcNoisegate(pNG, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="278">// ===============================
// function implementation for calcExpander(var id = 116)
// description: sends a stream of samples through a expander
// ===============================
void HALfunc_ID116_calcExpander(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter exp descr: expander
	TDynProc_Expander * pExp = (TDynProc_Expander *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcExpander(pExp, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="279">// ===============================
// function implementation for calcCompressor(var id = 117)
// description: sends a stream of samples through a compressor
// ===============================
void HALfunc_ID117_calcCompressor(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter comp descr: compressor
	TDynProc_Compressor * pComp = (TDynProc_Compressor *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcCompressor(pComp, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="280">// ===============================
// function implementation for calcLimiter(var id = 118)
// description: sends a stream of samples through a limiter
// ===============================
void HALfunc_ID118_calcLimiter(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter x descr: input
	TAPgenericRationalVector * x = (TAPgenericRationalVector *) pParams[0].fp_pD;
// parameter lim descr: limiter
	TDynProc_Limiter * pLim = (TDynProc_Limiter *) pParams[1].fp_pD;
// parameter y descr: output
	TAPgenericRationalVector * y = (TAPgenericRationalVector *) pParams[2].fp_pD;

	int i;
	for (i = 0; i &lt; x-&gt;num; i++) {
		y-&gt;pVal[i] = DynProc_calcLimiter(pLim, x-&gt;pVal[i]);
	}
	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="281">// ===============================
// variable implementation for a noisegate(var id = 11)
// ===============================

// updates a variable the AP
int HALimpl_11_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_11_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Noisegate));
}
// updates the vars at the other APs
int HALimpl_11_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_11_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_11_delete (void * pVarData) {
	TDynProc_Noisegate * pNG = (TDynProc_Noisegate *) pVarData;
	free (pNG);
}
</Code><Code idCode="282">// ===============================
// variable implementation for a expander(var id = 12)
// ===============================

// updates a variable the AP
int HALimpl_12_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_12_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Expander));

}
// updates the vars at the other APs
int HALimpl_12_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_12_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_12_delete (void * pVarData) {
	TDynProc_Expander * pExp = (TDynProc_Expander *) pVarData;
	free (pExp);

}
</Code><Code idCode="283">// ===============================
// variable implementation for a compressor(var id = 13)
// ===============================

// updates a variable the AP
int HALimpl_13_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_13_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Compressor));
}
// updates the vars at the other APs
int HALimpl_13_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_13_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_13_delete (void * pVarData) {
	TDynProc_Compressor * pCmp = (TDynProc_Compressor *) pVarData;
	free (pCmp);
}
</Code><Code idCode="284">// ===============================
// variable implementation for a limiter(var id = 14)
// ===============================

// updates a variable the AP
int HALimpl_14_recvUpdate (void * pVarData, void * pMsgData) {
	return -1;
}
// create a new variable
void * HALimpl_14_create (unsigned int numberOfElements) {
	if (numberOfElements != 1) return NULL;
	return malloc(sizeof(TDynProc_Limiter));
}
// updates the vars at the other APs
int HALimpl_14_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
	return -1;
}
// decode data for the HAL functions
void * HALimpl_14_decodeData (void * pVarData) {
	return pVarData;
}
// delete the variable
void HALimpl_14_delete (void * pVarData) {
	TDynProc_Limiter * pLim = (TDynProc_Limiter *) pVarData;
	free (pLim);
}
</Code><Code idCode="285">// ===============================
// function implementation for concatStrings(var id = 7)
// description: concat two strings
// ===============================
void HALfunc_ID7_concatStrings(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s1 descr: the string at its end the other string is concated
	TAPstringVector * s1 = (TAPstringVector *) pParams[0].fp_pD;
// parameter i1 descr: index of the string 1
	int i1 = (int) pParams[1].fp_integer;
// parameter s2 descr: the concat string
	TAPstringVector * s2 = (TAPstringVector *) pParams[2].fp_pD;
// parameter i2 descr: index of the string 2
	int i2 = (int) pParams[3].fp_integer;

	if (APstringVector_concat(s1,i1,s2,i2)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}
};
</Code><Code idCode="286">// ===============================
// function implementation for rationalToString(var id = 8)
// description: converts a rational to a string
// ===============================
void HALfunc_ID8_rationalToString(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * s = (TAPstringVector *) pParams[0].fp_pD;
// parameter sIndex descr: index of the string at the array
	int sIndex = (int) pParams[1].fp_integer;
// parameter r descr: rational vector
	TAPgenericRationalVector * r = (TAPgenericRationalVector *) pParams[2].fp_pD;
// parameter rIndx descr: rational vector index
	int rIndx = (int) pParams[3].fp_integer;

	APstringVector_printFloat(s, sIndex, r-&gt;pVal[rIndx]);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="287">// ===============================
// function implementation for integerToString(var id = 9)
// description: converts an integer to a string
// ===============================
void HALfunc_ID9_integerToString(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s descr: the string
	TAPstringVector * s = (TAPstringVector *) pParams[0].fp_pD;
// parameter sIndex descr: index of the string at the array
	int sIndex = (int) pParams[1].fp_integer;
// parameter i descr: integer vector
	TAPgenericIntegerVector * i = (TAPgenericIntegerVector *) pParams[2].fp_pD;
// parameter iIndex descr: integer vector indx
	int iIndex = (int) pParams[3].fp_integer;

	APstringVector_printInt(s, sIndex, i-&gt;pVal[iIndex]);

	((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
};
</Code><Code idCode="288">// ===============================
// function implementation for assignString(var id = 10)
// description: assigns a string to an other
// ===============================
void HALfunc_ID10_assignString(void * pIPcpu, TuAPInterpreterFunctionParameter * pParams) {
// parameter s1 descr: the string at its end the other string is concated
	TAPstringVector * s1 = (TAPstringVector *) pParams[0].fp_pD;
// parameter i1 descr: index of the string 1
	int i1 = (int) pParams[1].fp_integer;
// parameter s2 descr: the concat string
	TAPstringVector * s2 = (TAPstringVector *) pParams[2].fp_pD;
// parameter i2 descr: index of the string 2
	int i2 = (int) pParams[3].fp_integer;

	if (APstringVector_assign(s1,i1,s2,i2)) {
		((TAPInterpreterCPU *)pIPcpu)-&gt;EF = -1;
	} else {
		((TAPInterpreterCPU *)pIPcpu)-&gt;pIP++;
	}

};
</Code><Code idCode="289">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// updates a variable the AP
int HALimpl_1_recvUpdate (void * pVarData, void * pMsgData) {
return -1;
}
// create a new variable
void * HALimpl_1_create (unsigned int numberOfElements) {
return NULL;
}
// updates the vars at the other APs
int HALimpl_1_sendUpdate (void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i) {
return -1;
}
// decode data for the HAL functions
void * HALimpl_1_decodeData (void * pVarData) {
return NULL;
}
// delete the variable
void HALimpl_1_delete (void * pVarData) {

}
</Code><Code idCode="290">// ===============================
// variable implementation for a rational number(var id = 1)
// ===============================

// updates a variable the AP
int HALimpl_1_recvUpdate ( void * pVarData, void * pMsgData ) {
  
}
// create a new variable
void * HALimpl_1_create ( unsigned int numberOfElements ) {
 return NULL; 
}
// updates the vars at the other APs
int HALimpl_1_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
 
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
    int n, N;
    
    int32_t dataAmount = (int32_t) 1 + myDataElements;
    
    // 1 send header
    pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
    
    
    // 2 send vector elementwise
    N = elements at the vector;
    pVD = pVvecD-&gt; first element
    // 2.1 send amount of elements at the vector
    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pVvecD-&gt;element amount);
    // 2.2 send element
    for (n = 0; n &lt; N; n++) {    
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;value);

        pVD++;
    }
    return 0; 
}
// decode data for the HAL functions
void * HALimpl_1_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_1_delete ( void * pVarData ) {
  
}
</Code><Code idCode="291">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
  
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 return NULL; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
 
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
    int n, N;
    
    int32_t dataAmount = (int32_t) 1 + myDataElements;
    
    // 1 send header
    pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
    
    
    // 2 send vector elementwise
    N = elements at the vector;
    pVD = pVvecD-&gt; first element
    // 2.1 send amount of elements at the vector
    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pVvecD-&gt;element amount);
    // 2.2 send element
    for (n = 0; n &lt; N; n++) {    
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b2);

        pVD++;
    }
    return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
  
}
</Code><Code idCode="292">// ===============================
// variable implementation for a biquad filter(var id = 10)
// ===============================

// updates a variable the AP
int HALimpl_10_recvUpdate ( void * pVarData, void * pMsgData ) {
 // rx function template
    uint32_t * pD = (uint32_t *) pMsgData;
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    int i,imax 
    
    // at the first possion at the message is the global var index
    pD++; // skip it (it's the varindex)
    // and now we are at amount of values
    APendianConversation32Bit(pD,eAP_littleEndian);
    imax = (int) *((int32_t *)pD);
    int i;

    resize your vector here
    pD++;

    pVD = pVvecD-&gt;first element
    
    for (i = 0; i &lt; imax; i++) {
		pVD-&gt;a0=*((float *)pD);
		pD++;
		pVD-&gt;a1=*((float *)pD);
		pD++;
		pVD-&gt;a2=*((float *)pD);
		pD++;
		pVD-&gt;b0=*((float *)pD);
		pD++;
		pVD-&gt;b1=*((float *)pD);
		pD++;
		pVD-&gt;b2=*((float *)pD);
		pD++;
        pVD++;
    }

    return 0; 
}
// create a new variable
void * HALimpl_10_create ( unsigned int numberOfElements ) {
 return NULL; 
}
// updates the vars at the other APs
int HALimpl_10_sendUpdate ( void * pVarData, const void * pDrv, uint32_t receiver, uint32_t mNum, int32_t i ) {
     // tx function template
    myVarVectorType * pVvecD = pVarData;
    myVarType * pVD;
    TAPMsgDrv * pMD = (TAPMsgDrv *) pDrv;
    int n, N;
    
    int32_t dataAmount = (int32_t) 1 + total amount of data except length of the vector;
    
    // 1 send header
    pMD-&gt;pfkt_updateVariable(pMD-&gt;pDrvData, receiver, mNum, i, dataAmount);
    
    
    // 2 send vector elementwise
    N = elements at the vector;
    pVD = pVvecD-&gt; first element
    // 2.1 send amount of elements at the vector
    pMD-&gt;pfkt_sendInteger32(pMD,1,&amp;pVvecD-&gt;element amount);
    // 2.2 send element
    for (n = 0; n &lt; N; n++) {
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;a2);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b0);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b1);
		pMD-&gt;pfkt_sendFloat32(pMD,1,&amp;pVD-&gt;b2);
        pVD++;
    }
    return 0; 
}
// decode data for the HAL functions
void * HALimpl_10_decodeData ( void * pVarData ) {
 return NULL; 
}
// delete the variable
void HALimpl_10_delete ( void * pVarData ) {
  
}
</Code></Code_List><Compiler_List><Compiler AR="ar" ASM="as" CC="gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="" CXX="g++" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="" LINK="$SMARTLINK" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="$__RPATH" OBJSUFFIX=".o" OperatingSystem="windows" description="the gcc toolchain" idCompiler="1" name="gcc for Windows"/><Compiler AR="elfar" ASM="easm21k" CC="cc21k" CCCOM="$CC $CFLAGS $CCFLAGS $_CCCOMCOM -O0 -g -c -structs-do-not-overlap -no-multiline -double-size-32 -warn-protos -si-revision 0.1 -proc ADSP-21369 -o $TARGET $SOURCES" CCFLAGS="" CXX="cc21k" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="" LINK="$SMARTLINK" LINKCOM="$LINK -T ../libs/main.ldf -flags-link $SOURCES -o $TARGET -proc ADSP-21369 -si-revision 0.1 -flags-link" LINKFLAGS="$__RPATH" OBJSUFFIX=".o" OperatingSystem="ADSP" description="the ADSP toolchain" idCompiler="2" name="ADSP 21369"/><Compiler AR="msp430-ar" ASM="msp430-as" CC="msp430-gcc" CCCOM="$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CCFLAGS="-mmcu=msp430f169" CXX="msp430-g++" CXXCOM="$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES" CXXFLAGS="-mmcu=msp430f169" LINK="$SMARTLINK" LINKCOM="$LINK -o $TARGET $LINKFLAGS $SOURCES $_LIBDIRFLAGS $_LIBFLAGS" LINKFLAGS="$__RPATH -mmcu=msp430f169" OBJSUFFIX=".o" OperatingSystem="windows &amp; linux" description="the msp430-gcc toolchain" idCompiler="3" name="msp430-gcc for msp430169F"/></Compiler_List><CompilerLib_List/><CompilerLibPath_List><CompilerLibPath idCompiler="1" idCompilerLibPath="1" path="D:\Promotion\python\APgen\libs"/><CompilerLibPath idCompiler="2" idCompilerLibPath="2" path="C:\Program Files\Analog Devices\VisualDSP 5.0\213xx\lib"/></CompilerLibPath_List><CompilerIncludePath_List><CompilerIncludePath idCompiler="1" idCompilerIncludePath="1" path="D:\Promotion\python\APgen\includes"/><CompilerIncludePath idCompiler="2" idCompilerIncludePath="2" path="C:\Program Files\Analog Devices\VisualDSP 5.0\213xx\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="3" path="C:\MinGW\include\gtk-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="4" path="C:\MinGW\include\atk-1.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="5" path="C:\MinGW\include\gdk-pixbuf-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="6" path="C:\MinGW\lib\gtk-2.0\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="7" path="C:\MinGW\include\pango-1.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="8" path="C:\MinGW\include\glib-2.0"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="9" path="C:\MinGW\include\glib-2.0\glib"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="10" path="C:\MinGW\lib\glib-2.0\include"/><CompilerIncludePath idCompiler="1" idCompilerIncludePath="11" path="C:\MinGW\include\cairo"/><CompilerIncludePath idCompiler="3" idCompilerIncludePath="12" path="C:\MinGW\msp430\include"/></CompilerIncludePath_List><ImplHALFunction_List><ImplHALFunction descr="increment / decrement instruction pointer" fid="50" idCode="56" idImplGroup="0" idImplHALFunction="9"/><ImplHALFunction descr="reads a sample form a wav file" fid="60" idCode="81" idImplGroup="3" idImplHALFunction="14"/><ImplHALFunction descr="writes a sample to a wav file" fid="61" idCode="82" idImplGroup="3" idImplHALFunction="15"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="114" idImplGroup="5" idImplHALFunction="32"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="115" idImplGroup="5" idImplHALFunction="33"/><ImplHALFunction descr="processes the IFFT" fid="133" idCode="120" idImplGroup="4" idImplHALFunction="37"/><ImplHALFunction descr="inits the fft structure as real input fft" fid="130" idCode="121" idImplGroup="4" idImplHALFunction="38"/><ImplHALFunction descr="inits the fft structure as ifft" fid="131" idCode="122" idImplGroup="4" idImplHALFunction="39"/><ImplHALFunction descr="processes the FFT" fid="132" idCode="123" idImplGroup="4" idImplHALFunction="40"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="127" idImplGroup="6" idImplHALFunction="41"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="137" idImplGroup="6" idImplHALFunction="46"/><ImplHALFunction descr="reads a block of samples" fid="62" idCode="141" idImplGroup="7" idImplHALFunction="48"/><ImplHALFunction descr="writes a block of samples" fid="63" idCode="142" idImplGroup="7" idImplHALFunction="49"/><ImplHALFunction descr="sets the dimension of the UI" fid="200" idCode="172" idImplGroup="11" idImplHALFunction="59"/><ImplHALFunction descr="inits a panel" fid="201" idCode="177" idImplGroup="11" idImplHALFunction="64"/><ImplHALFunction descr="inits a button" fid="202" idCode="178" idImplGroup="11" idImplHALFunction="65"/><ImplHALFunction descr="inits a display" fid="203" idCode="179" idImplGroup="11" idImplHALFunction="66"/><ImplHALFunction descr="inits a LED" fid="204" idCode="180" idImplGroup="11" idImplHALFunction="67"/><ImplHALFunction descr="check button state" fid="210" idCode="182" idImplGroup="11" idImplHALFunction="68"/><ImplHALFunction descr="set LED state" fid="211" idCode="183" idImplGroup="11" idImplHALFunction="69"/><ImplHALFunction descr="increment / decrement instruction pointer if the CF is set" fid="51" idCode="184" idImplGroup="0" idImplHALFunction="70"/><ImplHALFunction descr="increment / decrement instruction pointer if the CF is not set" fid="52" idCode="185" idImplGroup="0" idImplHALFunction="71"/><ImplHALFunction descr="sets the CF" fid="55" idCode="186" idImplGroup="0" idImplHALFunction="72"/><ImplHALFunction descr="setup string" fid="5" idCode="189" idImplGroup="12" idImplHALFunction="73"/><ImplHALFunction descr="set string chars" fid="6" idCode="190" idImplGroup="12" idImplHALFunction="74"/><ImplHALFunction descr="set display text" fid="212" idCode="191" idImplGroup="11" idImplHALFunction="75"/><ImplHALFunction descr="a = const val" fid="20" idCode="197" idImplGroup="1" idImplHALFunction="76"/><ImplHALFunction descr="a = b" fid="21" idCode="198" idImplGroup="1" idImplHALFunction="77"/><ImplHALFunction descr="c = a + b" fid="22" idCode="199" idImplGroup="1" idImplHALFunction="78"/><ImplHALFunction descr="c = a - b" fid="23" idCode="200" idImplGroup="1" idImplHALFunction="79"/><ImplHALFunction descr="c = a * b" fid="24" idCode="201" idImplGroup="1" idImplHALFunction="80"/><ImplHALFunction descr="c = a / b" fid="25" idCode="202" idImplGroup="1" idImplHALFunction="81"/><ImplHALFunction descr="c = modulo(a ,b)" fid="26" idCode="203" idImplGroup="1" idImplHALFunction="82"/><ImplHALFunction descr="a&lt;b" fid="40" idCode="211" idImplGroup="1" idImplHALFunction="83"/><ImplHALFunction descr="a&gt;b" fid="41" idCode="212" idImplGroup="1" idImplHALFunction="84"/><ImplHALFunction descr="a==b" fid="42" idCode="213" idImplGroup="1" idImplHALFunction="85"/><ImplHALFunction descr="a&lt;&gt;b" fid="43" idCode="214" idImplGroup="1" idImplHALFunction="86"/><ImplHALFunction descr="a&lt;=b" fid="44" idCode="215" idImplGroup="1" idImplHALFunction="87"/><ImplHALFunction descr="a=&gt;b" fid="45" idCode="216" idImplGroup="1" idImplHALFunction="88"/><ImplHALFunction descr="updates a variable" fid="56" idCode="220" idImplGroup="0" idImplHALFunction="89"/><ImplHALFunction descr="sets the dimension of the UI (emty because of real hardware)" fid="200" idCode="241" idImplGroup="8" idImplHALFunction="90"/><ImplHALFunction descr="inits the panel for MSP430-169STK eval board" fid="201" idCode="242" idImplGroup="8" idImplHALFunction="91"/><ImplHALFunction descr="inits the button for MSP430-169STK eval board" fid="202" idCode="243" idImplGroup="8" idImplHALFunction="92"/><ImplHALFunction descr="inits the display for MSP430-169STK eval board" fid="203" idCode="244" idImplGroup="8" idImplHALFunction="93"/><ImplHALFunction descr="inits the LED for MSP430-169STK eval board" fid="204" idCode="245" idImplGroup="8" idImplHALFunction="94"/><ImplHALFunction descr="checks a button at the MSP430-169STK eval board" fid="210" idCode="246" idImplGroup="8" idImplHALFunction="95"/><ImplHALFunction descr="sets a LED at the MSP430-169STK eval board" fid="211" idCode="247" idImplGroup="8" idImplHALFunction="96"/><ImplHALFunction descr="sets a display text at the MSP430-169STK eval board" fid="212" idCode="248" idImplGroup="8" idImplHALFunction="97"/><ImplHALFunction descr="inits a biquad at the cascade as high pass filter" fid="100" idCode="251" idImplGroup="13" idImplHALFunction="98"/><ImplHALFunction descr="inits a biquad at the cascade as low pass filter" fid="101" idCode="253" idImplGroup="13" idImplHALFunction="99"/><ImplHALFunction descr="inits a biquad at the cascade as boost/cut peak filter" fid="102" idCode="254" idImplGroup="13" idImplHALFunction="100"/><ImplHALFunction descr="inits a biquad at the cascade as low frequency boost/cut shelving filter" fid="103" idCode="255" idImplGroup="13" idImplHALFunction="101"/><ImplHALFunction descr="inits a biquad at the cascade as low frequency boost/cut shelving filter" fid="104" idCode="256" idImplGroup="13" idImplHALFunction="102"/><ImplHALFunction descr="convolutes a vector of samples with a biquad cascade" fid="110" idCode="257" idImplGroup="13" idImplHALFunction="103"/><ImplHALFunction descr="a = const val" fid="27" idCode="259" idImplGroup="1" idImplHALFunction="104"/><ImplHALFunction descr="a = b" fid="28" idCode="260" idImplGroup="1" idImplHALFunction="105"/><ImplHALFunction descr="c = a + b" fid="29" idCode="261" idImplGroup="1" idImplHALFunction="106"/><ImplHALFunction descr="c = a - b" fid="30" idCode="262" idImplGroup="1" idImplHALFunction="107"/><ImplHALFunction descr="c = a * b" fid="31" idCode="263" idImplGroup="1" idImplHALFunction="108"/><ImplHALFunction descr="c = a / b" fid="32" idCode="264" idImplGroup="1" idImplHALFunction="109"/><ImplHALFunction descr="c = modulo(a ,b)" fid="33" idCode="265" idImplGroup="1" idImplHALFunction="110"/><ImplHALFunction descr="a&lt;b" fid="34" idCode="266" idImplGroup="1" idImplHALFunction="111"/><ImplHALFunction descr="a&gt;b" fid="35" idCode="267" idImplGroup="1" idImplHALFunction="112"/><ImplHALFunction descr="a==b" fid="36" idCode="268" idImplGroup="1" idImplHALFunction="113"/><ImplHALFunction descr="a&lt;&gt;b" fid="37" idCode="269" idImplGroup="1" idImplHALFunction="114"/><ImplHALFunction descr="a&lt;=b" fid="38" idCode="270" idImplGroup="1" idImplHALFunction="115"/><ImplHALFunction descr="a=&gt;b" fid="39" idCode="271" idImplGroup="1" idImplHALFunction="116"/><ImplHALFunction descr="inits a noisegate" fid="111" idCode="273" idImplGroup="14" idImplHALFunction="117"/><ImplHALFunction descr="inits a expander" fid="112" idCode="274" idImplGroup="14" idImplHALFunction="118"/><ImplHALFunction descr="inits a compressor" fid="113" idCode="275" idImplGroup="14" idImplHALFunction="119"/><ImplHALFunction descr="inits a limiter" fid="114" idCode="276" idImplGroup="14" idImplHALFunction="120"/><ImplHALFunction descr="stream samples through a noisegate" fid="115" idCode="277" idImplGroup="14" idImplHALFunction="121"/><ImplHALFunction descr="stream samples through a expander" fid="116" idCode="278" idImplGroup="14" idImplHALFunction="122"/><ImplHALFunction descr="stream samples through a compressor" fid="117" idCode="279" idImplGroup="14" idImplHALFunction="123"/><ImplHALFunction descr="stream samples through a limiter" fid="118" idCode="280" idImplGroup="14" idImplHALFunction="124"/><ImplHALFunction descr="concat two strings s1 &amp; s2 -&gt; s1" fid="7" idCode="285" idImplGroup="12" idImplHALFunction="125"/><ImplHALFunction descr="converts a rational to a string(size of the string is keept untouched)" fid="8" idCode="286" idImplGroup="12" idImplHALFunction="126"/><ImplHALFunction descr="converts a integer to a string(size of the string is keept untouched)" fid="9" idCode="287" idImplGroup="12" idImplHALFunction="127"/><ImplHALFunction descr="assigns a string to an other" fid="10" idCode="288" idImplGroup="12" idImplHALFunction="128"/></ImplHALFunction_List><ImplHALVariable_List><ImplHALVariable VariableID="20" descr="super generic delay" idCode="90" idImplGroup="1" idImplHALVariable="8"/><ImplHALVariable VariableID="4" descr="complex number used/defined at the fftw3 libary" idCode="99" idImplGroup="4" idImplHALVariable="9"/><ImplHALVariable VariableID="30" descr="FFT / IFFT structure for performing ffts and iffts" idCode="116" idImplGroup="4" idImplHALVariable="10"/><ImplHALVariable VariableID="3" descr="string based on stdlib" idCode="192" idImplGroup="12" idImplHALVariable="17"/><ImplHALVariable VariableID="100" descr="panel type in gtk+ style" idCode="193" idImplGroup="11" idImplHALVariable="18"/><ImplHALVariable VariableID="101" descr="button type in gtk+ style" idCode="194" idImplGroup="11" idImplHALVariable="19"/><ImplHALVariable VariableID="102" descr="LED type in gtk+ style" idCode="195" idImplGroup="11" idImplHALVariable="20"/><ImplHALVariable VariableID="103" descr="display type in gtk+ style" idCode="196" idImplGroup="11" idImplHALVariable="21"/><ImplHALVariable VariableID="2" descr="super generic integer" idCode="210" idImplGroup="1" idImplHALVariable="22"/><ImplHALVariable VariableID="1" descr="super generic rational" idCode="228" idImplGroup="1" idImplHALVariable="23"/><ImplHALVariable VariableID="100" descr="panel type for MSP430-169STK eval board" idCode="237" idImplGroup="8" idImplHALVariable="24"/><ImplHALVariable VariableID="101" descr="button type for MSP430-169STK eval board" idCode="238" idImplGroup="8" idImplHALVariable="25"/><ImplHALVariable VariableID="102" descr="LED type for MSP430-169STK eval board" idCode="239" idImplGroup="8" idImplHALVariable="26"/><ImplHALVariable VariableID="103" descr="display type for MSP430-169STK eval board" idCode="240" idImplGroup="8" idImplHALVariable="27"/><ImplHALVariable VariableID="10" descr="super generic biquad" idCode="252" idImplGroup="13" idImplHALVariable="28"/><ImplHALVariable VariableID="11" descr="generic noisegate" idCode="281" idImplGroup="14" idImplHALVariable="29"/><ImplHALVariable VariableID="12" descr="generic expander" idCode="282" idImplGroup="14" idImplHALVariable="30"/><ImplHALVariable VariableID="13" descr="generic compressor" idCode="283" idImplGroup="14" idImplHALVariable="31"/><ImplHALVariable VariableID="14" descr="generic limiter" idCode="284" idImplGroup="14" idImplHALVariable="32"/><ImplHALVariable VariableID="10" descr="test" idCode="292" idImplGroup="0" idImplHALVariable="33"/></ImplHALVariable_List><ImplMsgDriver_List><ImplMsgDriver descr="winAPdrv" idCode="223" idImplGroup="9" idImplMsgDriver="1"/><ImplMsgDriver descr="ADSPuartDRV" idCode="232" idImplGroup="6" idImplMsgDriver="2"/><ImplMsgDriver descr="MSP430uartDRV" idCode="235" idImplGroup="8" idImplMsgDriver="3"/></ImplMsgDriver_List><ImplAP_List><ImplAP descr="a overlapped frame based wavfile processing AP" idCode="102" idImplAP="4" idImplGroup="5"/><ImplAP descr="a wavfile processing AP" idCode="132" idImplAP="6" idImplGroup="3"/><ImplAP descr="a ADSP AP" idCode="135" idImplAP="7" idImplGroup="6"/><ImplAP descr="a block based wavfile processing AP, x.wav in, y.wav out; both @48000kHz" idCode="143" idImplAP="8" idImplGroup="7"/><ImplAP descr="a super generic AP with multiple threads" idCode="226" idImplAP="10" idImplGroup="10"/><ImplAP descr="a audio processor for the MSP430" idCode="234" idImplAP="11" idImplGroup="8"/></ImplAP_List><ImplGroup_List><ImplGroup idCode="1" idImplGroup="1" name="rational and integer generic"/><ImplGroup idCode="9" idImplGroup="2" name="boost"/><ImplGroup idCode="66" idImplGroup="3" name="libsndfile sample based"/><ImplGroup idCode="98" idImplGroup="4" name="fftw3 &amp; complex"/><ImplGroup idCode="101" idImplGroup="5" name="libsndfile overlapped frame based"/><ImplGroup idCode="124" idImplGroup="6" name="ADSP 21369 blockbased, ADC in, DAC3 &amp; DAC4 out, UART @9600,n,8,1"/><ImplGroup idCode="140" idImplGroup="7" name="libsndfile frame based"/><ImplGroup idCode="145" idImplGroup="8" name="MSP430-169STK"/><ImplGroup idCode="155" idImplGroup="9" name="windows UDP sockets useing pthreads"/><ImplGroup idCode="161" idImplGroup="10" name="pthreads and semaphores"/><ImplGroup idCode="162" idImplGroup="11" name="gtk+ for Windows"/><ImplGroup idCode="187" idImplGroup="12" name="ANSI C strings"/><ImplGroup idCode="250" idImplGroup="13" name="biquad filters (generic)"/><ImplGroup idCode="272" idImplGroup="14" name="audio dynamic processing (generic)"/></ImplGroup_List><AP_List><AP descr="a audio processor witch processes wavfiles" idAP="5" idCodeStartup="134" idCompiler="1" name="wavFileAP"/><AP descr="the generic AP for ADSP devices" idAP="6" idCodeStartup="138" idCompiler="2" name="asdp21369gen"/><AP descr="framebased AP fs=48000kHz, in=x.wav, out=y.wav" idAP="7" idCodeStartup="144" idCompiler="1" name="wavFileAPframebased"/><AP descr="generic multi thread AP for testing" idAP="9" idCodeStartup="152" idCompiler="1" name="AP test"/><AP descr="ADSP with UART driver" idAP="10" idCodeStartup="227" idCompiler="2" name="ADSP AP"/><AP descr="a AP for the MSP430-169STK" idAP="11" idCodeStartup="236" idCompiler="3" name="MSP430"/><AP descr="generic multi thread AP for testing" idAP="12" idCodeStartup="258" idCompiler="1" name="APdummy"/></AP_List><FunctionList_List><FunctionList idAP="5" idFunctionList="38" idImplHALFunction="9"/><FunctionList idAP="5" idFunctionList="39" idImplHALFunction="14"/><FunctionList idAP="5" idFunctionList="40" idImplHALFunction="15"/><FunctionList idAP="6" idFunctionList="47" idImplHALFunction="9"/><FunctionList idAP="6" idFunctionList="54" idImplHALFunction="41"/><FunctionList idAP="6" idFunctionList="55" idImplHALFunction="46"/><FunctionList idAP="7" idFunctionList="58" idImplHALFunction="9"/><FunctionList idAP="7" idFunctionList="62" idImplHALFunction="48"/><FunctionList idAP="7" idFunctionList="63" idImplHALFunction="49"/><FunctionList idAP="10" idFunctionList="101" idImplHALFunction="41"/><FunctionList idAP="10" idFunctionList="102" idImplHALFunction="46"/><FunctionList idAP="10" idFunctionList="103" idImplHALFunction="9"/><FunctionList idAP="10" idFunctionList="104" idImplHALFunction="70"/><FunctionList idAP="10" idFunctionList="105" idImplHALFunction="71"/><FunctionList idAP="10" idFunctionList="106" idImplHALFunction="72"/><FunctionList idAP="10" idFunctionList="107" idImplHALFunction="89"/><FunctionList idAP="11" idFunctionList="108" idImplHALFunction="73"/><FunctionList idAP="11" idFunctionList="109" idImplHALFunction="74"/><FunctionList idAP="11" idFunctionList="110" idImplHALFunction="9"/><FunctionList idAP="11" idFunctionList="111" idImplHALFunction="70"/><FunctionList idAP="11" idFunctionList="112" idImplHALFunction="71"/><FunctionList idAP="11" idFunctionList="113" idImplHALFunction="72"/><FunctionList idAP="11" idFunctionList="114" idImplHALFunction="89"/><FunctionList idAP="11" idFunctionList="115" idImplHALFunction="90"/><FunctionList idAP="11" idFunctionList="116" idImplHALFunction="91"/><FunctionList idAP="11" idFunctionList="117" idImplHALFunction="92"/><FunctionList idAP="11" idFunctionList="118" idImplHALFunction="93"/><FunctionList idAP="11" idFunctionList="119" idImplHALFunction="94"/><FunctionList idAP="11" idFunctionList="120" idImplHALFunction="95"/><FunctionList idAP="11" idFunctionList="121" idImplHALFunction="96"/><FunctionList idAP="11" idFunctionList="122" idImplHALFunction="97"/><FunctionList idAP="11" idFunctionList="129" idImplHALFunction="76"/><FunctionList idAP="11" idFunctionList="130" idImplHALFunction="77"/><FunctionList idAP="11" idFunctionList="131" idImplHALFunction="78"/><FunctionList idAP="11" idFunctionList="132" idImplHALFunction="79"/><FunctionList idAP="11" idFunctionList="133" idImplHALFunction="80"/><FunctionList idAP="11" idFunctionList="134" idImplHALFunction="81"/><FunctionList idAP="11" idFunctionList="135" idImplHALFunction="82"/><FunctionList idAP="11" idFunctionList="136" idImplHALFunction="83"/><FunctionList idAP="11" idFunctionList="137" idImplHALFunction="84"/><FunctionList idAP="11" idFunctionList="138" idImplHALFunction="85"/><FunctionList idAP="11" idFunctionList="139" idImplHALFunction="86"/><FunctionList idAP="11" idFunctionList="140" idImplHALFunction="87"/><FunctionList idAP="11" idFunctionList="141" idImplHALFunction="88"/><FunctionList idAP="12" idFunctionList="142" idImplHALFunction="9"/><FunctionList idAP="12" idFunctionList="143" idImplHALFunction="70"/><FunctionList idAP="12" idFunctionList="144" idImplHALFunction="71"/><FunctionList idAP="12" idFunctionList="145" idImplHALFunction="72"/><FunctionList idAP="12" idFunctionList="146" idImplHALFunction="89"/><FunctionList idAP="12" idFunctionList="147" idImplHALFunction="98"/><FunctionList idAP="12" idFunctionList="148" idImplHALFunction="99"/><FunctionList idAP="12" idFunctionList="149" idImplHALFunction="100"/><FunctionList idAP="12" idFunctionList="150" idImplHALFunction="101"/><FunctionList idAP="12" idFunctionList="151" idImplHALFunction="102"/><FunctionList idAP="12" idFunctionList="152" idImplHALFunction="103"/><FunctionList idAP="12" idFunctionList="153" idImplHALFunction="117"/><FunctionList idAP="12" idFunctionList="154" idImplHALFunction="118"/><FunctionList idAP="12" idFunctionList="155" idImplHALFunction="119"/><FunctionList idAP="12" idFunctionList="156" idImplHALFunction="120"/><FunctionList idAP="12" idFunctionList="157" idImplHALFunction="121"/><FunctionList idAP="12" idFunctionList="158" idImplHALFunction="122"/><FunctionList idAP="12" idFunctionList="159" idImplHALFunction="123"/><FunctionList idAP="12" idFunctionList="160" idImplHALFunction="124"/><FunctionList idAP="9" idFunctionList="161" idImplHALFunction="73"/><FunctionList idAP="9" idFunctionList="162" idImplHALFunction="74"/><FunctionList idAP="9" idFunctionList="163" idImplHALFunction="76"/><FunctionList idAP="9" idFunctionList="164" idImplHALFunction="77"/><FunctionList idAP="9" idFunctionList="165" idImplHALFunction="78"/><FunctionList idAP="9" idFunctionList="166" idImplHALFunction="79"/><FunctionList idAP="9" idFunctionList="167" idImplHALFunction="80"/><FunctionList idAP="9" idFunctionList="168" idImplHALFunction="81"/><FunctionList idAP="9" idFunctionList="169" idImplHALFunction="82"/><FunctionList idAP="9" idFunctionList="170" idImplHALFunction="83"/><FunctionList idAP="9" idFunctionList="171" idImplHALFunction="84"/><FunctionList idAP="9" idFunctionList="172" idImplHALFunction="85"/><FunctionList idAP="9" idFunctionList="173" idImplHALFunction="86"/><FunctionList idAP="9" idFunctionList="174" idImplHALFunction="87"/><FunctionList idAP="9" idFunctionList="175" idImplHALFunction="88"/><FunctionList idAP="9" idFunctionList="176" idImplHALFunction="104"/><FunctionList idAP="9" idFunctionList="177" idImplHALFunction="105"/><FunctionList idAP="9" idFunctionList="178" idImplHALFunction="106"/><FunctionList idAP="9" idFunctionList="179" idImplHALFunction="107"/><FunctionList idAP="9" idFunctionList="180" idImplHALFunction="108"/><FunctionList idAP="9" idFunctionList="181" idImplHALFunction="109"/><FunctionList idAP="9" idFunctionList="182" idImplHALFunction="110"/><FunctionList idAP="9" idFunctionList="183" idImplHALFunction="111"/><FunctionList idAP="9" idFunctionList="184" idImplHALFunction="112"/><FunctionList idAP="9" idFunctionList="185" idImplHALFunction="113"/><FunctionList idAP="9" idFunctionList="186" idImplHALFunction="114"/><FunctionList idAP="9" idFunctionList="187" idImplHALFunction="115"/><FunctionList idAP="9" idFunctionList="188" idImplHALFunction="116"/><FunctionList idAP="9" idFunctionList="189" idImplHALFunction="9"/><FunctionList idAP="9" idFunctionList="190" idImplHALFunction="70"/><FunctionList idAP="9" idFunctionList="191" idImplHALFunction="71"/><FunctionList idAP="9" idFunctionList="192" idImplHALFunction="72"/><FunctionList idAP="9" idFunctionList="193" idImplHALFunction="89"/><FunctionList idAP="9" idFunctionList="194" idImplHALFunction="98"/><FunctionList idAP="9" idFunctionList="195" idImplHALFunction="99"/><FunctionList idAP="9" idFunctionList="196" idImplHALFunction="100"/><FunctionList idAP="9" idFunctionList="197" idImplHALFunction="101"/><FunctionList idAP="9" idFunctionList="198" idImplHALFunction="102"/><FunctionList idAP="9" idFunctionList="199" idImplHALFunction="103"/><FunctionList idAP="9" idFunctionList="200" idImplHALFunction="117"/><FunctionList idAP="9" idFunctionList="201" idImplHALFunction="118"/><FunctionList idAP="9" idFunctionList="202" idImplHALFunction="119"/><FunctionList idAP="9" idFunctionList="203" idImplHALFunction="120"/><FunctionList idAP="9" idFunctionList="204" idImplHALFunction="121"/><FunctionList idAP="9" idFunctionList="205" idImplHALFunction="122"/><FunctionList idAP="9" idFunctionList="206" idImplHALFunction="123"/><FunctionList idAP="9" idFunctionList="207" idImplHALFunction="124"/><FunctionList idAP="9" idFunctionList="208" idImplHALFunction="59"/><FunctionList idAP="9" idFunctionList="209" idImplHALFunction="64"/><FunctionList idAP="9" idFunctionList="210" idImplHALFunction="65"/><FunctionList idAP="9" idFunctionList="211" idImplHALFunction="66"/><FunctionList idAP="9" idFunctionList="212" idImplHALFunction="67"/><FunctionList idAP="9" idFunctionList="213" idImplHALFunction="68"/><FunctionList idAP="9" idFunctionList="214" idImplHALFunction="69"/><FunctionList idAP="9" idFunctionList="215" idImplHALFunction="75"/><FunctionList idAP="12" idFunctionList="216" idImplHALFunction="73"/><FunctionList idAP="12" idFunctionList="217" idImplHALFunction="74"/><FunctionList idAP="12" idFunctionList="218" idImplHALFunction="76"/><FunctionList idAP="12" idFunctionList="219" idImplHALFunction="77"/><FunctionList idAP="12" idFunctionList="220" idImplHALFunction="78"/><FunctionList idAP="12" idFunctionList="221" idImplHALFunction="79"/><FunctionList idAP="12" idFunctionList="222" idImplHALFunction="80"/><FunctionList idAP="12" idFunctionList="223" idImplHALFunction="81"/><FunctionList idAP="12" idFunctionList="224" idImplHALFunction="82"/><FunctionList idAP="12" idFunctionList="225" idImplHALFunction="83"/><FunctionList idAP="12" idFunctionList="226" idImplHALFunction="84"/><FunctionList idAP="12" idFunctionList="227" idImplHALFunction="85"/><FunctionList idAP="12" idFunctionList="228" idImplHALFunction="86"/><FunctionList idAP="12" idFunctionList="229" idImplHALFunction="87"/><FunctionList idAP="12" idFunctionList="230" idImplHALFunction="88"/><FunctionList idAP="12" idFunctionList="231" idImplHALFunction="104"/><FunctionList idAP="12" idFunctionList="232" idImplHALFunction="105"/><FunctionList idAP="12" idFunctionList="233" idImplHALFunction="106"/><FunctionList idAP="12" idFunctionList="234" idImplHALFunction="107"/><FunctionList idAP="12" idFunctionList="235" idImplHALFunction="108"/><FunctionList idAP="12" idFunctionList="236" idImplHALFunction="109"/><FunctionList idAP="12" idFunctionList="237" idImplHALFunction="110"/><FunctionList idAP="12" idFunctionList="238" idImplHALFunction="111"/><FunctionList idAP="12" idFunctionList="239" idImplHALFunction="112"/><FunctionList idAP="12" idFunctionList="240" idImplHALFunction="113"/><FunctionList idAP="12" idFunctionList="241" idImplHALFunction="114"/><FunctionList idAP="12" idFunctionList="242" idImplHALFunction="115"/><FunctionList idAP="12" idFunctionList="243" idImplHALFunction="116"/><FunctionList idAP="12" idFunctionList="244" idImplHALFunction="59"/><FunctionList idAP="12" idFunctionList="245" idImplHALFunction="64"/><FunctionList idAP="12" idFunctionList="246" idImplHALFunction="65"/><FunctionList idAP="12" idFunctionList="247" idImplHALFunction="66"/><FunctionList idAP="12" idFunctionList="248" idImplHALFunction="67"/><FunctionList idAP="12" idFunctionList="249" idImplHALFunction="68"/><FunctionList idAP="12" idFunctionList="250" idImplHALFunction="69"/><FunctionList idAP="12" idFunctionList="251" idImplHALFunction="75"/><FunctionList idAP="12" idFunctionList="252" idImplHALFunction="125"/><FunctionList idAP="12" idFunctionList="253" idImplHALFunction="126"/><FunctionList idAP="12" idFunctionList="254" idImplHALFunction="127"/><FunctionList idAP="12" idFunctionList="255" idImplHALFunction="128"/><FunctionList idAP="9" idFunctionList="256" idImplHALFunction="125"/><FunctionList idAP="9" idFunctionList="257" idImplHALFunction="126"/><FunctionList idAP="9" idFunctionList="258" idImplHALFunction="127"/><FunctionList idAP="9" idFunctionList="259" idImplHALFunction="128"/></FunctionList_List><VariableList_List><VariableList idAP="5" idImplHALVariable="8" idVariableList="16"/><VariableList idAP="9" idImplHALVariable="17" idVariableList="23"/><VariableList idAP="9" idImplHALVariable="18" idVariableList="24"/><VariableList idAP="9" idImplHALVariable="19" idVariableList="25"/><VariableList idAP="9" idImplHALVariable="20" idVariableList="26"/><VariableList idAP="9" idImplHALVariable="21" idVariableList="27"/><VariableList idAP="9" idImplHALVariable="22" idVariableList="28"/><VariableList idAP="10" idImplHALVariable="23" idVariableList="29"/><VariableList idAP="11" idImplHALVariable="22" idVariableList="30"/><VariableList idAP="11" idImplHALVariable="17" idVariableList="31"/><VariableList idAP="11" idImplHALVariable="24" idVariableList="32"/><VariableList idAP="11" idImplHALVariable="25" idVariableList="33"/><VariableList idAP="11" idImplHALVariable="26" idVariableList="34"/><VariableList idAP="11" idImplHALVariable="27" idVariableList="35"/><VariableList idAP="12" idImplHALVariable="22" idVariableList="37"/><VariableList idAP="12" idImplHALVariable="23" idVariableList="38"/><VariableList idAP="12" idImplHALVariable="28" idVariableList="39"/><VariableList idAP="12" idImplHALVariable="29" idVariableList="40"/><VariableList idAP="12" idImplHALVariable="30" idVariableList="41"/><VariableList idAP="12" idImplHALVariable="31" idVariableList="42"/><VariableList idAP="12" idImplHALVariable="32" idVariableList="43"/><VariableList idAP="9" idImplHALVariable="23" idVariableList="44"/><VariableList idAP="9" idImplHALVariable="28" idVariableList="45"/><VariableList idAP="9" idImplHALVariable="29" idVariableList="46"/><VariableList idAP="9" idImplHALVariable="30" idVariableList="47"/><VariableList idAP="9" idImplHALVariable="31" idVariableList="48"/><VariableList idAP="9" idImplHALVariable="32" idVariableList="49"/><VariableList idAP="12" idImplHALVariable="17" idVariableList="50"/><VariableList idAP="12" idImplHALVariable="18" idVariableList="51"/><VariableList idAP="12" idImplHALVariable="19" idVariableList="52"/><VariableList idAP="12" idImplHALVariable="20" idVariableList="53"/><VariableList idAP="12" idImplHALVariable="21" idVariableList="54"/></VariableList_List><DriverList_List><DriverList idAP="9" idDriverList="1" idImplMsgDriver="1"/><DriverList idAP="10" idDriverList="2" idImplMsgDriver="2"/><DriverList idAP="11" idDriverList="3" idImplMsgDriver="3"/></DriverList_List><APList_List><APList idAP="5" idAPList="5" idImplAP="6"/><APList idAP="6" idAPList="6" idImplAP="7"/><APList idAP="7" idAPList="7" idImplAP="8"/><APList idAP="9" idAPList="9" idImplAP="10"/><APList idAP="10" idAPList="10" idImplAP="7"/><APList idAP="11" idAPList="11" idImplAP="11"/><APList idAP="12" idAPList="12" idImplAP="10"/></APList_List><ALASMprogramm_List><ALASMprogramm code="" idALASMprogramm="1"/><ALASMprogramm code="" idALASMprogramm="2"/><ALASMprogramm code="" idALASMprogramm="3"/></ALASMprogramm_List><pythonScript_List><pythonScript code="# the python implementation  import scipy import numpy  from scipy.io import wavfile from scipy.signal import lfilter  import floatwavefile import stjMatPython  def calcLP (fg, fs):     # n - numerator     # d - denumerator     k=numpy.tan(numpy.pi*fg/fs)     k2 = k * k     sqrtTwo = numpy.sqrt(2)     dn = (1+sqrtTwo*k+k2)          n0=k2/dn     n1=2*k2/dn     n2=k2/dn     d0=1     d1=(2*(k2-1))/dn     d2=(1-sqrtTwo*k+k2)/dn     return [[n0,n1,n2],[d0,d1,d2]]  def calcHP (fg, fs):     # n - numerator     # d - denumerator     k=numpy.tan(numpy.pi*fg/fs)     k2 = k * k     sqrtTwo = numpy.sqrt(2)     dn = (1+sqrtTwo*k+k2)          n0=1/dn     n1=-2/dn     n2=1/dn     d0=1     d1=(2*(k2-1))/dn     d2=(1-sqrtTwo*k+k2)/dn     return [[n0,n1,n2],[d0,d1,d2]]  def normFilterCoeff (n,d):     rn = numpy.divide(n,d[0])     rd = numpy.divide(d,d[0])     return rn, rd  def initCrossOver (fLp, fHp, fs): # scipy has an own bilinear transformation method to go from a sjw to z space #from scipy.signal import bilinear #LP = bilinear(b, a, fs)     # calc filter coefficents ...     n, d = calcLP(fLp, fs)     n, d = normFilterCoeff(n,d)     LP = {'n' : n, 'd' : d}     n, d = calcHP(fHp, fs)     n, d = normFilterCoeff(n,d)     HP = {'n' : n, 'd' : d}     return LP, HP  def convoluteSignalWithFilter (n, d, xA):     s1 = float(0.)     s2 = float(0.)     l = len(xA)     yA = numpy.zeros(l)     i = 0     for x in xA:         d1 = -d[2]*s2-d[1]*s1+d[0]*x         y = n[2]*s2+n[1]*s1+n[0]*d1         s2 = s1         s1 = d1         yA[i] = y         i += 1     return yA  def measureCrossOver (CO, Xsig):     LP = CO[0]     HP = CO[1]     yLP = lfilter (LP['n'],LP['d'],Xsig)     yHP = lfilter (HP['n'],HP['d'],Xsig)     #yLP = convoluteSignalWithFilter(LP['n'],LP['d'],Xsig)     #yHP = convoluteSignalWithFilter(HP['n'],HP['d'],Xsig)          return yLP,yHP   if __name__ == '__main__':     # set the sample frequency     N = int(2**16)     fs = float(44100)          xScalor = fs / N          # read data from the wave file         [rate, x] = floatwavefile.readFloatWAV('noise.wav')          #display read data      # convolute data with the crossover filter     CO = initCrossOver(1000,2000,fs)     yLP, yHP = measureCrossOver(CO,x)      wv = numpy.array(yLP,dtype=numpy.float32)          floatwavefile.writeFloatWAV('pythonLP.wav', fs, wv)      wv = numpy.array(yHP,dtype=numpy.float32)          floatwavefile.writeFloatWAV('pythonHP.wav', fs, wv)" idpythonScript="1"/><pythonScript code="# the python initiation script import scipy import numpy  from scipy.io import wavfile from scipy.signal import lfilter  import floatwavefile  # set the sample frequency N = int(2**16) fs = float(44100)      xScalor = fs / N      # create the amplitude and phase array # all fequencies have an amplitude of 1      # we have to keep in mind that we want to produce an real signal # this means that the fft specturm is mirrored at N/2      # generate random phase angle witch is uniform distributed phi = numpy.random.uniform(low=-1*numpy.pi, high=numpy.pi, size=N/2) Y = numpy.ones(N/2, dtype=complex)      # merge phase and amplitude # z = A * e^(jw) i = 0 for p in phi:     Y[i] = numpy.exp(1.j *p)     i += 1 # set the DC value to 0 Y[0] = 0 + 0.j  # ifft to gain a real signal x = numpy.fft.irfft(Y)  # dump wave file wv = numpy.array(x,dtype=numpy.float32)      floatwavefile.writeFloatWAV('noise.wav', fs, wv)" idpythonScript="2"/><pythonScript code="# the python close script import scipy import numpy  import floatwavefile import stjMatPython  import matplotlib.pyplot as plt  print ('analyse results')  N = int(2**16) fs = float(44100)  xScalor = fs / N  [rate, x] = floatwavefile.readFloatWAV('noise.wav')  [rate, yPLP] = floatwavefile.readFloatWAV('pythonLP.wav') [rate, yPHP] = floatwavefile.readFloatWAV('pythonHP.wav') [rate, yMLP] = floatwavefile.readFloatWAV('matlabLP.wav') [rate, yMHP] = floatwavefile.readFloatWAV('matlabHP.wav') [rate, yAPLP] = floatwavefile.readFloatWAV('apLP.wav') [rate, yAPHP] = floatwavefile.readFloatWAV('apHP.wav')    stjMatPython.poltBode (211,212,numpy.fft.rfft(yAPLP),N,xScalor,'red',1,0.4,'audio processor') stjMatPython.poltBode (211,212,numpy.fft.rfft(yAPHP),N,xScalor,'red',1,0.4,None) stjMatPython.poltBode (211,212,numpy.fft.rfft(yPLP),N,xScalor,'green',1,0.5,'python') stjMatPython.poltBode (211,212,numpy.fft.rfft(yPHP),N,xScalor,'green',1,0.5,None) stjMatPython.poltBode (211,212,numpy.fft.rfft(yMLP),N,xScalor,'blue',1,0.3,'matlab') stjMatPython.poltBode (211,212,numpy.fft.rfft(yMHP),N,xScalor,'blue',1,0.3,None)   lpDif = yPLP - yMLP hpDif = yPHP - yMHP  plt.show()" idpythonScript="3"/><pythonScript code="# the python implementation" idpythonScript="4"/><pythonScript code="# the python initiation script" idpythonScript="5"/><pythonScript code="# the python close script" idpythonScript="6"/><pythonScript code="# the python implementation" idpythonScript="7"/><pythonScript code="# the python initiation script" idpythonScript="8"/><pythonScript code="# the python close script" idpythonScript="9"/></pythonScript_List><MatlabProgramm_List><MatlabProgramm code="% the matlab program clear clc % const N = 2^16; fs = 44100.0; fHP = 2000; fLP = 1000;  % calc filter HP = calcHP(fs, fHP); LP = calcLP (fs, fLP);  %normize filter HP = normFilterCoeff(HP); LP = normFilterCoeff(LP);  %load noise signal x = wavread('noise.wav');  % convolute filter with the signal yHP = filter(HP(1,:),HP(2,:),x); yLP = filter(LP(1,:),LP(2,:),x);   % save results to file wavwrite (yLP,fs,32,'matlabLP.wav'); wavwrite (yHP,fs,32,'matlabHP.wav');" idMatlabProgramm="1"/><MatlabProgramm code="% the matlab program" idMatlabProgramm="2"/><MatlabProgramm code="% the matlab program" idMatlabProgramm="3"/></MatlabProgramm_List><testPattern_List><testPattern descr="test crossover filter" idALASMprogramm="1" idAP="1" idMatlabProgramm="1" idPythonExitScript="3" idPythonInitScript="2" idpythonProgramm="1" idtestPattern="1" name="cof"/><testPattern descr="embeeded world conference crossover test" idALASMprogramm="2" idAP="1" idMatlabProgramm="2" idPythonExitScript="6" idPythonInitScript="5" idpythonProgramm="4" idtestPattern="2" name="ebw"/><testPattern descr="DAFx 2012 testpattern" idALASMprogramm="3" idAP="6" idMatlabProgramm="3" idPythonExitScript="9" idPythonInitScript="8" idpythonProgramm="7" idtestPattern="3" name="DAFXx 2012"/></testPattern_List></APDB>